# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1294124929 18000
# Node ID 1d85595d94a4cfc74ad446f4ed4e11caf8fa8627
# Parent  120c07be6358d93bcff503363d379c26b8342f2b
Applied all of the previous quadratic/bilinear form/space/lattice patches from sage-4.1.1.

diff -r 120c07be6358 -r 1d85595d94a4 sage/matrix/matrix0.pyx
--- a/sage/matrix/matrix0.pyx	Sat Oct 30 16:00:40 2010 -0700
+++ b/sage/matrix/matrix0.pyx	Tue Jan 04 02:08:49 2011 -0500
@@ -14,6 +14,7 @@
 
 ################################################################################
 #       Copyright (C) 2005, 2006 William Stein <wstein@gmail.com>
+#                     2010 Jonathan Hanke <jonhanke@gmail.com>
 #
 #  Distributed under the terms of the GNU General Public License (GPL).
 #  The full text of the GPL is available at:
@@ -2838,6 +2839,35 @@
         """
         return self._nrows == self._ncols
 
+
+    def is_diagonal(self):
+        """
+        Return True precisely if this matrix is diagonal (i.e., all non-diagonal entries are zero)
+        but allows for non-square diagonal matrices.
+        
+        EXAMPLES:
+            sage: matrix(QQ,2,2,range(4)).is_diagonal()
+            False
+            sage: matrix(QQ,2,3,range(6)).is_diagonal()
+            False
+            sage: matrix(QQ,2,3,[5,0,0, 0,3,0]).is_diagonal()
+            True
+            sage: matrix(QQ,3,2,[5,0,0, 0,3,0]).is_diagonal()
+            False
+
+        AUTHOR:
+            Jonathan Hanke
+        """
+        ## Look for a non-zero off-diagonal entry
+        for i in range(self._nrows):
+            for j in range(self._ncols):
+                if (i != j) and self.get_unsafe(i,j) != 0:
+                    return False
+
+        ## Otherwise, the matrix is diagonal
+        return True
+
+
     def is_invertible(self):
         r"""
         Return True if this matrix is invertible.
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/all.py
--- a/sage/quadratic_forms/all.py	Sat Oct 30 16:00:40 2010 -0700
+++ b/sage/quadratic_forms/all.py	Tue Jan 04 02:08:49 2011 -0500
@@ -14,3 +14,27 @@
 
 from constructions import BezoutianQuadraticForm, HyperbolicPlane_quadratic_form
 
+from sage.quadratic_forms.projective_iterators import normalized_finite_projective_space_generator
+
+
+from square_classes import local_squareclass_representatives_list, is_SquareClass, SquareClass
+
+from weak_approx import weak_approx_for_numbers_over_QQ, weak_approx_for_squareclasses_over_QQ,\
+                                            strong_approx_for_squareclasses_by_QQ_except_at_one_prime
+
+from quadratic_space import QuadraticSpace, local_quadratic_space_anisotropic_dimension_by_invariants, \
+                                            local_quadratic_space_core_invariants_from_invariants, \
+                                            local_quadratic_space_by_invariants,\
+                                            local_quadratic_space_GHY_to_Standard_invariants, \
+                                            local_quadratic_space_Standard_to_GHY_invariants, \
+                                            find_locally_represented_number, \
+                                            rational_quadratic_space_from_local_space_list
+
+from quadratic_lattice import QuadraticLattice
+
+from symmetric_bilinear import DiagonalMatrix, SymmetricBilinearSpace, SymmetricBilinearLattice
+
+from lattice import Lattice
+
+from localization import Qv
+
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/lattice.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/lattice.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,197 @@
+
+
+from sage.modules.free_module import FreeModule_submodule_with_basis_pid
+
+from copy import deepcopy
+
+
+
+################################
+## Code for the Lattice class ##
+################################
+
+class Lattice():
+    """
+    This is a class that gives a finitely generated submodule of a
+    K-vectorspace over its ring of integers O_K, where K is a number
+    field.
+
+    TO DO: Eventually add support for S-integers as well, where S is a
+    set of places of K.
+    """
+
+
+    def __init__(self, V, basis):
+        """
+        Initializes with the syntax:
+
+            Lattice(V, list_of_generators)
+            Lattice(V, row_matrix_of_generators)
+
+
+
+        Note:  When subclassing this class overload the __init__() and ambient_space() methods, and change the internal variable.
+        """
+        ## Check that V is a vectorspace over a number field or its completion at a place
+
+
+        ## Check that basis is a matrix or list of vectors
+        
+
+        ## Check that the ring of integers is a PID
+        #raise NotImplementedError, "Presently we only have support for modules over principal ideal domains."
+        
+
+        ## Initilize the lattice
+        self.__lattice_module = FreeModule_submodule_with_basis_pid(V, basis)
+        self.__base_ring = V.base_field().ring_of_integers()
+
+
+    def __repr__(self):
+        """
+        Returns a string representing the lattice.
+
+        EXAMPLES:
+            sage: L = Lattice(QQ^3, [[1,0,0], [1,2,3]])
+            sage: L.__repr__()
+            Lattice in Vector space of dimension 3 over Rational Field generated by over the ring Integer Ring by
+            [
+            (1, 0, 0),
+            (1, 2, 3)
+            ]
+        """
+        return "Lattice in " + str(self.ambient_space()) + \
+               " generated by over the ring " + str(self.base_ring()) + \
+               " by \n" + str(self.generators())
+
+
+
+    def ambient_space(self):
+        """
+        Returns the ambient vector space that this lattice sits in.
+        """
+        return self.__lattice_module.ambient_vector_space()
+
+
+    def ambient_dimension(self):
+        """
+        Returns the ambient vector space that this lattice sits in.
+        """
+        return self.ambient_space().dim()
+
+
+    def base_ring(self):
+        """
+        Returns the ring for which this is a module.
+        """
+        return deepcopy(self.__base_ring)
+
+
+
+    def rank(self):
+        """
+        Determines if the lattice spans the ambient vector space.
+        """
+        return self.__lattice_module.rank()
+        
+
+    def is_full_rank(self):
+        """
+        Determines if the lattice spans the ambient vector space.
+        """
+        return self.rank() == self.ambient_dimension()
+
+
+    def is_free(self):
+        """
+        Determines if the lattice has a (free) basis.
+        """
+        return True
+
+
+    def sum_with(self, other):
+        """
+        Find the sum of this lattice with the lattice L (in the same vector space).
+        """
+        ## Check that both lattices live on the same ambient space
+        if not self.ambient_space() == other.ambient_space():
+            raise TypeError, "The two lattices live on different ambient spaces!"
+
+        ## Return the lattice generated by generators of both lattices
+        return self.__init__(self.ambient_space(), self.generators() + other.generators())
+
+
+    def intersect_with(self, other):
+        """
+        Find the intersection of this lattice with the lattice L (in the same vector space).
+        """
+        ## Check that both lattices live on the same ambient space
+        if not self.ambient_space() == other.ambient_space():
+            raise TypeError, "The two lattices live on different ambient spaces!"
+
+        ## Return the intersection of the two quadratic latties
+        intersection_basis = self.__lattice_free_module.intersection(other.__lattice_free_module).basis()
+        return self.__init__(self.quadratic_space(), intersection_basis)
+    
+
+
+    def basis(self):
+        """
+        Returns the list of the basis vectors for the lattice, if the generators form a basis.
+        """
+        return self.__lattice_module.basis()
+
+
+    def basis_matrix_of_columns(self):
+        """
+        Returns a matrix whose columns are the ordered basis for the lattice (if a basis exists).
+        """
+        return self.__lattice_module.basis_matrix().transpose()
+
+
+    def basis_matrix_of_rows(self):
+        """
+        Returns a matrix whose rows are the ordered basis for the lattice (if a basis exists).
+        """
+        return self.__lattice_module.basis_matrix()
+
+
+
+    def generators(self):
+        """
+        Returns the list of generating vectors for the lattice.
+        """
+        return self.__lattice_module.basis()
+
+
+    def generator_matrix_of_columns(self):
+        """
+        Returns a matrix whose columns are the (ordered) generators for the lattice.
+        """
+        return self.__lattice_module.basis_matrix().transpose()
+
+    
+    def generator_matrix_of_rows(self):
+        """
+        Returns a matrix whose rows are the (ordered) generators for the lattice.
+        """
+        return self.__lattice_module.basis_matrix()
+
+
+
+    def apply_linear_transformation_on_left(self, U):
+        """
+        Returns the lattice generated by the generators of this
+        lattice (as a matrix of row vectors), after left-multiplying
+        by the matrix U.
+        """
+        return self.__init__(self.ambient_space(), U * self.generator_matrix_of_rows())
+
+
+    def apply_linear_transformation_on_right(self, U):
+        """
+        Returns the lattice generated by the generators of this
+        lattice (as a matrix of column vectors), after right-multiplying
+        by the matrix U.
+        """
+        return self.__init__(self.ambient_space(), U * self.generator_matrix_of_columns())
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/localization.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/localization.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,36 @@
+
+
+## Routines related to localization of QQ at various places
+
+
+
+
+from sage.rings.padics.factory import Qp
+from sage.rings.real_mpfr import RR
+from sage.rings.infinity import Infinity
+
+
+
+
+def Qv(v):
+    """
+    Returns the localization of the rational numbers QQ at the place v.
+
+    INPUT:
+        v -- a positive prime number or Infinity
+
+    OUTPUT:
+        a local field (RR or Qp(v))
+
+    EXAMPLES:
+        sage: Qv(5) == Qp(5)
+        True
+        sage: Qv(Infinity) == RR
+        True
+    
+    """
+    if v == Infinity:
+        return RR
+    else:
+        return Qp(v)
+
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/maximal_extras.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/maximal_extras.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,419 @@
+
+from sage.misc.misc import verbose
+
+from random import random
+from sage.functions.other import floor, sqrt
+from sage.matrix.constructor import matrix
+from sage.matrix.matrix import is_Matrix
+from sage.rings.arith import valuation, kronecker_symbol, legendre_symbol, hilbert_symbol, is_prime
+from sage.rings.rational_field import QQ
+from sage.rings.integer_ring import ZZ
+from sage.rings.infinity import infinity
+from sage.misc.functional import squarefree_part
+
+from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
+from sage.rings.all import GF
+from sage.modules.free_module_element import vector
+
+
+
+
+
+def find_isotropic_vector_at_prime(G):
+    """
+    Returns a vector for the bilinear form G over GF(p) which is
+    isotropic, and False if there is no such vector.
+
+    INPUT:
+        G -- the Gram matrix of a form over GF(p)
+
+    OUTPUT:
+        a vector over GF(p)
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.maximal_extras import find_isotropic_vector_at_prime
+        sage: A = matrix(GF(3), 2, 2, [3,1,1,3])
+        sage: v = find_isotropic_vector_at_prime(A)
+        sage: v*A*v.transpose() == 0
+        True
+
+    """
+    d = G.nrows()
+
+
+    ## Deal with dimension 0 forms 
+    if d == 0:
+        return False
+
+
+    p = G.parent().base_ring().characteristic()
+    ## Check that G % p is non-degenerate... or allow it an use the kernel.
+
+    ## DIAGNSOTIC
+    verbose("G = " + str(G))
+
+    G_det = G.det()                             #################  WARNING -- THIS IS A SAGE ERROR OVER GF(2)!!!
+    if G_det == 0:
+        raise NotImplementedError, "Must input a non-degenerate matrix over GF(p)." 
+
+
+    ## Deal with dimension 1 forms 
+    if d == 1:
+        return False
+
+    ## Deal with dimension 2 forms 
+    if d == 2:
+        if (p != 2) and (legendre_symbol(-G_det.lift(), p) != 1):       ## Check if we don't have a hyperbolic plane!   
+            return False
+
+
+    ## Deal with dimension >=3 forms or hyperbolic plane (so we have isotropic vectors)!
+    PR = PolynomialRing(GF(p), 'y')
+    y = PR.gen()
+
+    while True:                                                  ## This must terminate since n >= 3
+        ## Choose a random (non-zero) linear polynomial vector in L#/L
+        v1 = vector([PR(ZZ.random_element(p))  for i in range(d)])
+        while v1 == v1.parent().zero_vector():
+            v1 = vector([PR(ZZ.random_element(p))  for i in range(d)])
+        v2 = vector([PR(ZZ.random_element(p))  for i in range(d)])
+        while v2 == v2.parent().zero_vector():
+            v2 = vector([PR(ZZ.random_element(p))  for i in range(d)])
+        v = v1 + y * v2
+
+        G1 = matrix(PR, G)
+        F = (v * G1 * v.transpose())[0]
+
+        ## Deal with every vector being isotropic
+        if F == 0:
+            return vector(GF(p), v1)
+
+        ## Otherwise find roots
+        F_roots = F.roots()
+        if len(F_roots) != 0:
+            a = F_roots[0][0]  ## Take the first root over F_p
+
+            new_v = v1 + a*v2   
+            if new_v != new_v.parent().zero_vector():
+                return vector(GF(p), new_v)
+
+
+
+def find_basis_of_maximal_isotropic_subspace(G):
+    """
+    Find a basis of a maximal isotropic subspace of G over GF(p).
+
+    INPUT:
+        G -- the Gram matrix of a form over GF(p)
+
+    OUTPUT:
+        a matrix of row vectors over GF(p)
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.maximal_extras import find_basis_of_maximal_isotropic_subspace
+
+        sage: MM = matrix(GF(5), 6, 6, [0, 0, 1, 2, 2, 2, 0, 0, 0, 1, 0, 1, 1, 0, 2, 2, 3, 0, 2, 1, 2, 3, 1, 2, 2, 0, 3, 1, 1, 0, 2, 1, 0, 2, 0, 1])
+        sage: find_basis_of_maximal_isotropic_subspace(MM)  ## random
+        [2 0 0 3 0 2]
+        [0 3 0 1 3 1]
+        [0 0 2 2 2 3]
+
+    """
+    n = G.nrows()
+    p = G.parent().base_ring().characteristic()
+
+    ## Make the transformation matrix (of rows!!!)
+    T = matrix(GF(p), 0, n, [])
+
+    ## Find one isotropic vector
+    v = find_isotropic_vector_at_prime(G)
+
+    ## Check if we're done.
+    if v == False:
+        return T
+
+    ## Find a basis for V^\perp
+    K = (G * v.transpose()).kernel().basis_matrix()
+
+    ## DIAGNOSTIC
+    verbose("v = " + str(v))
+    verbose("K = " + str(K))
+
+    ## Find the first non-zero entry of v, to use to decide which kernel basis vector to replace with v.
+    for i in range(n):
+        if v[i] != 0:
+            v_nz_index = i
+            break
+    ## Find the associated basis vector (using heavily the row echelon form of the output)
+    for i in range(K.nrows()):
+        if K[i, v_nz_index] != 0:
+            K_nz_index = i
+            break
+
+    ## DIAGNOSIC
+    verbose("v_nz_index = " + str(v_nz_index))
+    verbose("K_nz_index = " + str(K_nz_index))
+
+    ## Extract the kernel basis excluding v
+    K1 = K.matrix_from_rows([j for j in range(K.nrows())  if j != K_nz_index])
+    G1 = K1 * G * K1.transpose()
+
+    ## Perform the recursion
+    T1 = find_basis_of_maximal_isotropic_subspace(G1)
+    T_last = T1 * K1
+    T_new = (T_last.transpose().augment(v.transpose())).transpose()   ## Augment T_last by adding the row v
+
+    ## DIAGNOSTIC
+    verbose("Found T_new of dimension " + str(T_new.nrows()))
+    
+    return T_new
+
+
+
+def even_neighbor_of_bilinear_gram_matrix(Gram):
+    """
+    Returns an even neighbor of an odd lattice, which is the lattice
+    itself if Gram is even, and the even sublattice of Gram if there
+    is no even neighbor.
+
+    INPUT:
+        G -- the symmetric (Gram) matrix of a form over ZZ
+
+    OUTPUT:
+        a symmetric matrix over ZZ with even diagonal
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.maximal_extras import even_neighbor_of_bilinear_gram_matrix
+
+        sage: B =  matrix(ZZ, 8, 8, [1  for i in range(64)]) + 2
+        sage: E, T = even_neighbor_of_bilinear_gram_matrix(B)
+        sage: E
+        [12  8  8  8  8  8  8  8]
+        [ 8  8  6  6  6  6  6  6]
+        [ 8  6  8  6  6  6  6  6]
+        [ 8  6  6  8  6  6  6  6]
+        [ 8  6  6  6  8  6  6  6]
+        [ 8  6  6  6  6  8  6  6]
+        [ 8  6  6  6  6  6  8  6]
+        [ 8  6  6  6  6  6  6  8]
+        sage: T
+        [2 1 1 1 1 1 1 1]
+        [0 1 0 0 0 0 0 0]
+        [0 0 1 0 0 0 0 0]
+        [0 0 0 1 0 0 0 0]
+        [0 0 0 0 1 0 0 0]
+        [0 0 0 0 0 1 0 0]
+        [0 0 0 0 0 0 1 0]
+        [0 0 0 0 0 0 0 1]
+
+        sage: B = matrix(ZZ, 8, 8, 1)
+        sage: E, T = even_neighbor_of_bilinear_gram_matrix(B)  ## This should be the E8 lattice!
+        sage: E
+        [  4   2   2   2   2   9  -7  -7]
+        [  2   2   1   1   1   5  -4  -4]
+        [  2   1   2   1   1   5  -4  -4]
+        [  2   1   1   2   1   5  -4  -4]
+        [  2   1   1   1   2   5  -4  -4]
+        [  9   5   5   5   5  22 -17 -17]
+        [ -7  -4  -4  -4  -4 -17  14  13]
+        [ -7  -4  -4  -4  -4 -17  13  14]
+        sage: T
+        [   2    1    1    1    1  9/2 -7/2 -7/2]
+        [   0    1    0    0    0  1/2 -1/2 -1/2]
+        [   0    0    1    0    0  1/2 -1/2 -1/2]
+        [   0    0    0    1    0  1/2 -1/2 -1/2]
+        [   0    0    0    0    1  1/2 -1/2 -1/2]
+        [   0    0    0    0    0  1/2  1/2 -1/2]
+        [   0    0    0    0    0  1/2 -1/2  1/2]
+        [   0    0    0    0    0  1/2 -1/2 -1/2]
+        sage: E.det()
+        1
+    """
+    n = Gram.nrows()
+    T = matrix(ZZ, n, n, 1)
+
+    Gram_even,trans_even,is_even = even_sublattice_of_bilinear_gram_matrix(Gram)
+
+    ## we already have found an even lattice
+    if is_even:
+    	return Gram, T
+
+
+################################################################################################
+    ## better way 
+    # Diagonalise the  Gram_of_max_lat modulo 2 (if this is odd, otherwise we are fine anyhow)
+    # Then either the even sublattice is already the maximal even overlattice 
+    # or this is generated by the even sublattice and 1/2 of the sum of all (n or (n-1)) 
+    # basisvectors of odd norm
+
+    Gram_diag, trans_diagmod2, numberofodd = diagonalise_mod_2(Gram) 
+
+    #print "Gram = \n" + str(Gram)
+    #print "Gramdiag = \n" + str(Gram_diag)
+    #print "trans_diagmod2 = \n" + str(trans_diagmod2)
+    #print "numberofodd = \n" + str(numberofodd)
+
+
+    	## should return a unimodular integral matrix s.t. Gram_diag = trans_diagmod2.transpose()*Gram_of_max_lat*trans_diagmod2 
+    	## is a diagonal matrix modulo 2
+    	## and an integer numberofodd, such that the first numberofodd vectors in trans_diagmod2 have odd norm
+    	## the others have even norm (so if det = 2 then numberoofodd = n-1 else n ) 
+    oddity = 0
+    for i in range(numberofodd):
+   	 oddity += Gram_diag[i,i]
+    if oddity % 8 == 0:
+    	halfcolumns = vector([1  for j in range(numberofodd)] + [0  for j in range(numberofodd, n)])
+    	newtrans =  matrix(ZZ,(2*trans_diagmod2).augment(halfcolumns.transpose())).transpose()
+        newtrans_lll = newtrans.LLL().matrix_from_rows(range(1,n+1)).transpose()  
+
+        #print "halfcolumns = \n" + str(halfcolumns)
+        #print "newtrans = \n" + str(newtrans)
+        #print "newtrans_lll = \n" + str(newtrans_lll)
+        #print "newtrans_lll.transpose() * Gram_even * newtrans_lll/4 = \n" + str(newtrans_lll.transpose() * Gram_even * newtrans_lll/4)
+
+
+        ## Make the new matrix and transformation for non-zero oddity (mod 8)
+        new_A = newtrans_lll.transpose() * Gram_even * newtrans_lll / 4
+        new_T = trans_even * newtrans_lll / 2
+        print "new_A = \n", new_A
+        print "new_T = \n", new_T
+        return matrix(ZZ, new_A), new_T
+
+    return Gram_even,  trans_even   ## if oddity is not zero mod 8 then the even sublattice is already maximal even
+
+
+
+
+
+
+
+
+
+def split_one_odd_vector_mod2(A):
+    """
+    This function returns G,T, where T is a unimodular integral matrix
+    G = T^tr A T which has first diagonal entry odd and all other
+    entries in the first row and column of G are even such that the
+    lower right (n-1) submatrix is again odd or has all entries
+    divisible by 2.  The flag mult2 says whether the lower right is
+    zero mod 2.
+ 
+    (Note: Here internally we are working again with vectors as columns) 
+
+    INPUT:
+        A -- an odd symmetric matrix
+
+    OUTPUT:
+        G -- odd symmetric matrix with first row/column zero except for the upper left entry (which is odd).
+        T -- integral unimodular matrix
+        mult2 -- boolean
+
+    EXAMPLES:
+
+    """
+    n = A.nrows()
+    T = matrix(ZZ,n,n,0)
+    ## Find the first odd diagonal entry
+    odd_ind = -1
+    for i in range(n):
+        if A[i,i] % 2 != 0:
+            odd_ind = i
+            break
+       
+    ## Find the associated transformation (shifting the odd entry to the upper-left corner, and we clear the first row/column of the form)
+    T[odd_ind, 0] = 1   
+    for i in range(odd_ind):
+        T[i, i+1] = 1
+        if A[odd_ind, i] % 2 == 1:
+            T[odd_ind, i+1] = 1
+    for i in range(odd_ind+1, n):
+        T[i,i] = 1
+        if A[odd_ind, i] % 2 == 1:
+            T[odd_ind, i] = 1
+
+    ## Make the new matrix and check if it is odd anywhere on the diagonal (in which case we return)
+    G = T.transpose() * A * T
+    for i in range(1,n):
+        if G[i,i] % 2 == 1:
+            return G, T, False
+
+    ## Check the off-diagonal entries looking for odd entries
+    mult2 = True
+    for i in range(1, n):
+        if mult2 == False:
+            break
+        for j in range(i+1, n):
+            if G[i,j] % 2 == 1:
+                mult2 = False 
+                odd_i = i
+                break
+
+    if mult2 == True:
+        return G, T, mult2
+
+    ## Deal with the presence of odd entries:    [ WARNING: THIS DOESN'T SEEM TO USE A UNIMODULAR MATRIX HERE! ]
+    ##--------------------------------------
+    T1 = matrix(ZZ,n,n,0)
+
+    ## Find the associated transformation (to arrange that the associated submatrix has one diagonal entry)
+    T1[odd_i, 0] = 1   
+    T1[0, 0] = 1   
+    for i in range(1, n):
+        T1[i,i] = 1
+        if (G[0, i] + G[odd_i, i]) % 2 == 1:
+            T1[0, i] = 1
+
+    ## Return the new matrix
+    T2 = T * T1
+    G = T2.transpose() * A * T2
+    return G, T2, False
+
+
+
+    
+
+def diagonalise_mod_2(A):
+    """
+    A is an odd symmetric matrix. 
+    this function returns G,T,a, where T is a unimodular integral matrix
+    G = T^tr A T (work again with columns) is diagonal modulo 2
+    where the first a diagonal entries of G are odd and all other entries of G are even
+
+    INPUT:
+        A -- an odd symmetrix matrix of a form over ZZ
+
+    OUTPUT:
+        G -- a symmetric matrix, 
+        T -- a det 1 integral matrix
+        a -- an integer
+
+    EXAMPLES:
+
+
+    """
+    n = A.nrows()
+    T = matrix(ZZ,n,n,1)
+
+    ## Find the first odd diagonal entry
+    odd_ind = -1
+    for i in range(n):
+        if A[i,i] % 2 != 0:
+            odd_ind = i
+            break
+    if odd_ind == -1: 
+    	raise TypeError,"matrix is even"
+
+    mult2 = False
+    G = matrix(ZZ,A)
+    dimodd = 0
+    while not mult2:
+    	G, T1, mult2 = split_one_odd_vector_mod2(G) 
+        T = T * (matrix(ZZ, dimodd, dimodd, 1)).block_sum(T1)   
+        G.subdivide(1,1)
+        G = G.subdivision(1,1)
+        dimodd += 1
+    return T.transpose()*A*T, T, dimodd 
+    
+  
+
+
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/projective_iterators.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/projective_iterators.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,132 @@
+
+
+
+from sage.rings.all import ZZ, Field, Ring
+from sage.modules.free_module_element import vector
+from sage.rings.arith import is_prime, divisors
+from itertools import product
+from sage.misc.misc import prod
+
+
+def normalized_finite_projective_space_generator(n, R):
+        """
+        Iterator for looping over all normalized vectors in a finite
+        projective space P^n(Z/R*Z) or P^n(R) for a finite ring R.  We
+        say a vector v is normalized if it has the form
+
+            v = (0, ..., 0, 1, *, ..., *)
+
+        where * represents freely chosen elements of R which are non-zero
+
+        This assumes that R has an iterator and that either R is a
+        field, or has methods R.is_unit() and R.is_zero()
+
+
+        TO DO: This could be moved to a generator in the file
+        sage.schemes.generic.projective_space once it supports
+        constructions like:
+
+            #sage: R = QuotientRing(ZZ, 7*ZZ)
+            #sage: ProjectiveSpace(3, R)     
+
+        which currently raises an error!
+
+        
+        INPUT:
+            n -- an integer >= 1
+            R -- either an integer > 1 or a finite ring.
+
+        OUTPUT:
+            a vector of length n, with coefficients in ZZ or in R
+
+        EXAMPLES:
+            sage: for v in normalized_finite_projective_space_generator(3, 2):  print "v = ", v
+            v =  (1, 0, 0)
+            v =  (1, 0, 1)
+            v =  (1, 1, 0)
+            v =  (1, 1, 1)
+            v =  (0, 1, 0)
+            v =  (0, 1, 1)
+            v =  (0, 0, 1)
+            
+            sage: for v in normalized_finite_projective_space_generator(3, 3):  print "v = ", v
+            v =  (1, 0, 0)
+            v =  (1, 0, 1)
+            v =  (1, 0, 2)
+            v =  (1, 1, 0)
+            v =  (1, 1, 1)
+            v =  (1, 1, 2)
+            v =  (1, 2, 0)
+            v =  (1, 2, 1)
+            v =  (1, 2, 2)
+            v =  (0, 1, 0)
+            v =  (0, 1, 1)
+            v =  (0, 1, 2)
+            v =  (0, 0, 1)
+        
+	    sage: R = QuotientRing(ZZ, 3*ZZ)
+	    sage: for v in normalized_finite_projective_space_generator(3, R):  print "v = ", v
+	    Traceback (most recent call last):
+	    ...
+	    NotImplementedError: object does not support iteration
+
+        """
+        ## Sanity Check -- n >= 1
+        if not ((n in ZZ) and (n > 0)):
+            raise TypeError, "The number n (giving the dimension of projective space) must be an integer > 0."
+
+
+        ## Setup the first vector, depending on the field_info:
+        ## ----------------------------------------------------
+
+        ## Enumerate over [0, ..., R-1]
+        if (R in ZZ) and (R > 1):
+            if is_prime(R):
+                Field_flag = True
+            else:
+                Field_flag = False
+                
+            for i in range(n):
+                for d in divisors(R)[:-1]:          ## Run through all proper positive divisors of R.
+                    for v in product( * (n-1-i)*[range(R)]):
+
+                        ## Ensure that each non-unit component of v is zero  (which is automatically true over a field).  
+                        if Field_flag or (prod([gcd(v[k], R) == 1  for k in range(len(v))]) == 1):     
+                            yield vector([ZZ(0) for k in range(i)] + [ZZ(d)] + list(v))
+
+
+
+        ## Enumerate over a (presumably finite) ring 
+        elif isinstance(R, Ring):
+
+            if isinstance(R, Field):
+                Field_flag = True
+                nonzero_ideal_generators = [1]
+            else:
+                Field_flag = False
+                units = [u   for u in R  if u.is_unit()]
+
+                ## Find all non-zero ideal generators
+                nonzero_ideal_generators = [1]
+                for x in R:
+                    if not x.is_zero() and not x.is_unit():
+
+                        ## Add x to the list of no associate if it is already listed
+                        if [u  for u in units  if x*u in nonzero_ideal_generators] == []:
+                            nonzero_ideal_generators.append(x)
+                            
+                        
+            for i in range(n):
+                for d in nonzero_ideal_generators:
+                    for v in product( * (n-1-i)*[R]):
+                        
+                        ## Ensure that each non-unit component of v is zero  (which is automatically true over a field).  
+                        if Field_flag or (prod([v[k].is_unit() or v[k].is_zero()  for k in range(len(v))]) == 1):     
+                            yield vector([R(0) for k in range(i)] + [d] + list(v))
+
+
+        ## Raise an exception if we don't have a ring or an integer > 1.
+        else:
+            raise TypeError, "Invalid R was passed in.  We need a finite ring or an integer > 1."
+ 
+
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_form.py
--- a/sage/quadratic_forms/quadratic_form.py	Sat Oct 30 16:00:40 2010 -0700
+++ b/sage/quadratic_forms/quadratic_form.py	Tue Jan 04 02:08:49 2011 -0500
@@ -292,10 +292,22 @@
     from sage.quadratic_forms.quadratic_form__siegel_product import \
             siegel_product
 
+
+    ## Routines to compute genus and spinor genus representatives
+    from sage.quadratic_forms.quadratic_form__genus_enumeration import \
+            class_number, \
+            genus_representatives, \
+            spinor_genus_representatives
+
+
     ## Routines to compute p-neighbors
     from sage.quadratic_forms.quadratic_form__neighbors import \
-            find_primitive_p_divisible_vector__random, \
-            find_primitive_p_divisible_vector__next, \
+            p_neighbors_up_to_isometry, \
+            p_neighbors_up_to_isometry__with_mass_check, \
+            p_neighbor_graph, \
+            compute_p_neighbor_once, \
+            compute_p_neighbors, \
+            compute_p_neighbor_from_vector, \
             find_p_neighbor_from_vec
 
     ## Routines to reduce a given quadratic form
@@ -314,6 +326,7 @@
 
     ## Routines to compute local masses for ZZ.
     from sage.quadratic_forms.quadratic_form__mass import \
+            has_class_number_one, \
             shimura_mass__maximal, \
             GHY_mass__maximal
     from sage.quadratic_forms.quadratic_form__mass__Siegel_densities import \
@@ -339,6 +352,11 @@
 #            conway_generic_mass, \
 #            conway_p_mass_adjustment
 
+    ## Routines to compute maximally integral quadratic form
+#    from sage.quadratic_forms.quadratic_form__maximal import \
+#            is_maximal, \
+#            maximal_form
+
     ## Routines to check local representability of numbers
     from sage.quadratic_forms.quadratic_form__local_representation_conditions import \
             local_representation_conditions, \
@@ -372,13 +390,31 @@
             is_locally_equivalent_to, \
             has_equivalent_Jordan_decomposition_at_prime
 
-    def __init__(self, R, n=None, entries=None, unsafe_initialization=False, number_of_automorphisms=None, determinant=None):
+    def __init__(self, R, n=None, entries=None, unsafe_initialization=False, number_of_automorphisms=None, \
+                 determinant=None, init_from_gram_matrix=False):
         """
         EXAMPLES::
     
             sage: s = QuadraticForm(ZZ, 4, range(10))
             sage: s == loads(dumps(s)) 
             True
+
+
+            sage: QuadraticForm(QQ, Matrix(ZZ, 2, 2, 1), init_from_gram_matrix=False)
+            Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1/2 0 ]
+            [ * 1/2 ]
+
+            sage: QuadraticForm(QQ, Matrix(ZZ, 2, 2, 1), init_from_gram_matrix=True)
+            Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+
+            sage: QuadraticForm(GF(2), Matrix(ZZ, 2, 2, 1), init_from_gram_matrix=True)
+            Quadratic form in 2 variables over Finite Field of size 2 with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            
         """
         ## Deal with:  QuadraticForm(ring, matrix)
         matrix_init_flag = False
@@ -397,8 +433,8 @@
         ## Deal with:  QuadraticForm(matrix) 
         if is_Matrix(R) and (n == None):
 
-            ## Test if R is symmetric and has even diagonal
-            if not self._is_even_symmetric_matrix_(R):
+            ## Test if R is symmetric and has even diagonal (when appropriate)
+            if not init_from_gram_matrix and not self._is_even_symmetric_matrix_(n, R):
                 raise TypeError, "Oops!  The matrix is not a symmetric with even diagonal."
     
             ## Rename the matrix and ring
@@ -411,12 +447,25 @@
             self.__n = M.nrows()
             self.__base_ring = M_ring
             self.__coeffs = []
-            for i in range(M.nrows()):
-                for j in range(i, M.nrows()):
-                    if (i == j):
-                        self.__coeffs += [ M_ring(M[i,j] / 2) ]
-                    else:
-                        self.__coeffs += [ M_ring(M[i,j]) ]    
+
+
+            ## Usual initialize from Hessian matrix
+            if not init_from_gram_matrix:
+                for i in range(M.nrows()):
+                    for j in range(i, M.nrows()):
+                        if (i == j):
+                            self.__coeffs += [ M_ring(M[i,j] / 2) ]
+                        else:
+                            self.__coeffs += [ M_ring(M[i,j]) ]    
+
+            ## The occasional initialize from a Gram matrix
+            else:
+                for i in range(M.nrows()):
+                    for j in range(i, M.nrows()):
+                        if (i == j):
+                            self.__coeffs += [ M_ring(M[i,j]) ]
+                        else:
+                            self.__coeffs += [ M_ring(M[i,j] * 2) ]    
         
             return
     
@@ -629,11 +678,7 @@
             raise RuntimeError, "Oops!  This coefficient can't be coerced to an element of the base ring for the quadratic form."
 
 
-######################################
-# TO DO:    def __cmp__(self, other):
-######################################
-
-    def __eq__(self, right):
+    def __eq__(self, other):
         """
         Determines if two quadratic forms are equal.
     
@@ -656,9 +701,81 @@
             False
     
         """    
-        if not isinstance(right, QuadraticForm):
+        if not isinstance(other, QuadraticForm):
             return False
-        return (self.__base_ring == right.__base_ring) and (self.__coeffs == right.__coeffs)
+        return (self.__base_ring == other.__base_ring) and (self.__coeffs == other.__coeffs)
+
+
+
+    def __ne__(self, other):
+        """
+        Determines if two quadratic forms are not equal.
+    
+        INPUT:
+            other -- a quadratic form
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,4,10])
+            sage: Q != Q
+            False
+    
+            sage: Q1 = QuadraticForm(QQ, 2, [1,4,10])
+            sage: Q != Q1
+            True
+    
+            sage: Q2 = QuadraticForm(ZZ, 2, [1,4,-10])
+            sage: Q != Q1
+            True
+            sage: Q != Q2
+            True
+            sage: Q1 != Q2
+            True
+    
+        """    
+        return not self.__eq__(other)
+
+
+
+
+######################################
+# TO DO:    def __cmp__(self, other):
+######################################
+
+
+
+    def __cmp__(self, other):
+        """
+        This is the default comparison routine for <, <=, >, >= if
+        no special comparison operator is defined.  These operations
+        are not defined at present, and it is not clear what anything
+        but equality would mean in this context, so we raise a
+        NotImplementedError.
+
+        INPUT:
+            other -- a quadratic form
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: Q1 = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+            sage: Q2 = Q1(Matrix(ZZ, 3, 3, [1,2,3,0,2,4,0,0,3]))
+            sage: Q1.__cmp__(Q2)
+            Traceback (most recent call last):
+            ...
+            NotImplementedError: Warning: The comparison operation just used is not presently defined.
+            sage: Q1 > Q2
+            Traceback (most recent call last):
+            ...
+            NotImplementedError: Warning: The comparison operation just used is not presently defined.
+            
+
+        """
+        raise NotImplementedError, "Warning: The comparison operation just used is not presently defined."
+
 
 
     def __add__(self, right):
@@ -1015,7 +1132,8 @@
             Rational Field
         
         """
-        return (ZZ(1) / ZZ(2)) * self.matrix()
+        R = self.base_ring()
+        return (R(1) / R(2)) * self.Hessian_matrix()
 
 
     def Gram_matrix(self):
@@ -1042,14 +1160,15 @@
             Integer Ring
             
         """
-        A = (ZZ(1) / ZZ(2)) * self.matrix()
+        R = self.base_ring()
+        A = self.Hessian_matrix() * (R(1) / R(2))  
         n = self.dim()
     
         ## Test to see if it has an integral Gram matrix
         Int_flag = True
         for i in range(n):
             for j in range(i,n):
-                Int_flag = Int_flag and A[i,j] in self.base_ring()
+                Int_flag = Int_flag and (A[i,j] in R)   ## Note the single = (for assignment) is correct here!
     
         ## Return the Gram matrix, or an error
         if Int_flag: 
@@ -1190,7 +1309,7 @@
             2
         
         """
-        return self.__n
+        return deepcopy(self.__n)
 
 
     def base_ring(self):
@@ -1204,7 +1323,7 @@
             Integer Ring
         
         """
-        return self.__base_ring
+        return deepcopy(self.__base_ring)
 
 
     def coefficients(self):
@@ -1219,7 +1338,7 @@
             [1, 2, 3]
         
         """
-        return self.__coeffs
+        return deepcopy(self.__coeffs)
 
     
     def det(self):
@@ -1308,8 +1427,8 @@
         ## Check that a canonical coercion is possible
         if not is_Ring(R):
             raise TypeError, "Oops!  R is not a ring. =("
-        if not R.has_coerce_map_from(self.base_ring()):
-            raise TypeError, "Oops!  There is no canonical coercion from " + str(self.base_ring()) + " to R."
+        if not R.has_coerce_map_from(self.__base_ring):
+            raise TypeError, "Oops!  There is no canonical coercion from " + str(self.__base_ring) + " to R."
         
         ## Return the coerced form
         return QuadraticForm(R, self.dim(), [R(x) for x in self.coefficients()])
@@ -1343,7 +1462,7 @@
         """
         ## Try to return the cached level
         try:
-            return self.__level
+            return deepcopy(self.__level)
         except:
         
             ## Check that the base ring is a PID
@@ -1385,7 +1504,7 @@
 
             ## Cache and return the level
             self.__level = lvl
-            return lvl
+            return deepcopy(lvl)
             
 
 
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_form__automorphisms.py
--- a/sage/quadratic_forms/quadratic_form__automorphisms.py	Sat Oct 30 16:00:40 2010 -0700
+++ b/sage/quadratic_forms/quadratic_form__automorphisms.py	Tue Jan 04 02:08:49 2011 -0500
@@ -356,7 +356,7 @@
 
 
 
-def number_of_automorphisms(self, recompute=False):
+def number_of_automorphisms(self, recompute=False, use_code="Souvigner"):
     """
     Return a list of the number of automorphisms (of det 1 and -1) of
     the quadratic form.
@@ -410,8 +410,14 @@
         
     ## Otherwise cache and return the result
     #print "Recomputing the number of automorphisms based on the list of automorphisms."
-    #self.__number_of_automorphisms = len(self.automorphisms())                                     ## This is now deprecated.
-    self.__number_of_automorphisms = self.number_of_automorphisms__souvigner()        
+    if use_code == "Souvigner":
+        self.__number_of_automorphisms = self.number_of_automorphisms__souvigner()    ## This is the default  
+    elif use_code == "Python":
+        self.__number_of_automorphisms = len(self.automorphisms())                 ## This is now deprecated.
+    else:
+        raise TypeError, "The option for use_code you passed is not recognized.  Try 'Souvigner' (default) or 'Python' (very slow)."
+
+
     try:
         self._external_initialization_list.remove('number_of_automorphisms')
     except:
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_form__genus_enumeration.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/quadratic_form__genus_enumeration.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,180 @@
+
+
+## Routines to enumerate classes in a genus or spinor genus, and spinor genera in a genus.
+
+
+
+
+from sage.rings.all import ZZ
+from sage.rings.arith import next_prime, prime_divisors
+from sage.rings.fast_arith import prime_range
+
+
+
+
+
+
+
+def class_number(self):
+    """
+    Returns the number of (improper) classes in the genus of the given quadratic form.
+
+    TO DO: Add Caching ability!
+
+
+
+    INPUT:
+        None
+
+    OUTPUT:
+        a positive integer
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,48,144])
+        sage: Q.class_number() == 4
+        True
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q.class_number() == 1
+        True
+
+    """
+    ## Use a cached value of the class number if it exists!
+
+
+    ## Test if the class number is 1 quickly
+    if self.conway_mass() == 1/self.number_of_automorphisms():
+        return 1
+       
+    ## Compute the class number by counting the genus representatives
+    return len(self.genus_representatives())
+
+
+
+
+
+
+def genus_representatives(self):
+    """
+    Find a set of inequivalent representatives for the classes in the
+    genus of the given quadratic form.
+
+    Warning: If there is a problem now -- the algorithm will not
+    terminate.  It's better to compute the spinor genera in the gennus
+    adelically first, so we know which primes to use!
+
+    
+    INPUT:
+        None
+
+    OUTPUT:
+        A list of non-isometric quadratic forms representing all classes in the genus.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 48, 144])
+        sage: GR = Q.genus_representatives()
+        sage: len(GR)
+        4
+        sage: GR
+        [Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 1 0 0 ]
+        [ * 48 0 ]
+        [ * * 144 ]
+        ,
+         Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 697 0 3168 ]
+        [ * 48 0 ]
+        [ * * 3600 ]
+        ,
+         Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 25 96 192 ]
+        [ * 1200 1920 ]
+        [ * * 912 ]
+        ,
+         Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 97 576 864 ]
+        [ * 1200 960 ]
+        [ * * 3792 ]
+        ]
+
+
+
+    """
+    ## Sanity Check:  Base ring = ZZ only!
+    if self.base_ring() != ZZ:
+        raise NotImplementedError, "The genus representatives routine is only implemented over the base ring ZZ."
+
+
+    ## TO DO: USE A CACHED RESULT IF POSSIBLE...
+
+
+
+    ## Compute p-neighbors for some prime p>2 not dividing det(Q)
+    p_initial = next_prime(max([2] + prime_divisors(self.det())) + 1)
+    genus_reps_list = self.p_neighbors_up_to_isometry(p_initial)
+
+    
+    ## Compute the mass and see if we're done
+    mass = self.conway_mass()
+    reps_auto_list = [ZZ(1)/Q.number_of_automorphisms()  for Q in genus_reps_list]
+    mass_of_reps = sum(reps_auto_list)
+
+     
+
+
+    ## Look for primes where one p-neighbors gives an new inequivalent form, until the mass formula is satisfied
+    new_prime_list = []
+    for p in prime_range(next_prime(p_initial), 200):                              ## THIS IS AWFUL -- CHANGE THIS TO HAVE AN EXIT CONDITION!
+
+        ## Check if the automorphisms fill out the mass (so we're done)
+        if mass == mass_of_reps:
+            return genus_reps_list
+        elif mass < mass_of_reps:
+            raise RuntimeError, "We have a problem since the mass = " + str(mass) + \
+                " < the mass of our genus representatives " + str(mass_of_reps) + \
+                ", which have reciprocal automorphism sizes " + str(reps_auto_list) + "."
+
+        ## Generate a p-neighbor
+        tmp_neighbor = self.p_neighbor_once(p)
+
+        ## Test that it is not isometric to any known forms
+        new_flag = True
+        if tmp_neighbor.is_globally_equivalent_to(genus_reps_list[j]):
+            new_flag = False
+            break              ## Don't test past one successful isometry      
+
+        ## Generate its p_initial neighbors if we get a new form.
+        new_prime_list.append(p)
+        new_reps_list = tmp_neighbor.p_neighbors_up_to_isometry(p)
+        reps_auto_list += [Q.number_of_automorphisms()  for Q in new_reps_list]
+        mass_of_reps = sum(reps_auto_list)
+
+
+    ## Sanity Check:
+    raise RuntimeError,  "After checking the primes < 200, we didn't make the entire genus... =("
+
+
+
+
+def spinor_genus_representatives(self):
+    """
+    Returns the spinor genus of the given quadratic form.
+
+    TO DO: WE NEED TO FIND A PRIME WHICH ONLY GIVES ONE SPINOR GENUS FROM ITS NEIGHBORS!
+
+
+    INPUT:
+        None
+
+    OUTPUT:
+        A list of integrally inequivalent quadratic forms
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,48,144])
+        sage: len(Q.spinor_genus_representatives()) == 2
+        True
+
+    """
+    raise NotImplementedError, "We need to find the correct prime to use first!"
+
+
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_form__mass.py
--- a/sage/quadratic_forms/quadratic_form__mass.py	Sat Oct 30 16:00:40 2010 -0700
+++ b/sage/quadratic_forms/quadratic_form__mass.py	Tue Jan 04 02:08:49 2011 -0500
@@ -32,7 +32,41 @@
 ###################################################
 
 
-def shimura_mass__maximal(self,):
+
+def has_class_number_one(self):
+    """
+    Uses the mass formula to check that the class number of the
+    quadratic form is one.  (I.e., the quadratic form has one class in
+    its genus.)
+
+    TO DO/FIX: This gives the wrong result for one variable forms,
+    which should always have class number one!
+    
+
+    INPUT:
+        None
+
+    OUTPUT:
+        Boolean
+
+    EXAMPLES:
+        sage: CN1_truth = [DiagonalQuadraticForm(ZZ, n*[1]).has_class_number_one()  for n in range(2, 10)]; CN1_truth
+        [True, True, True, True, True, True, True, False, False, False]        
+
+    """
+    ## See if the mass is realized by this one class.
+    mass = self.conway_mass()
+    num_of_autos = self.number_of_automorphisms()
+    return mass == 1/num_of_autos
+
+
+
+
+
+
+
+
+def shimura_mass__maximal(self):
     """
     Use Shimura's exact mass formula to compute the mass of a maximal
     quadratic lattice. This works for any totally real number field,
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py
--- a/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py	Sat Oct 30 16:00:40 2010 -0700
+++ b/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py	Tue Jan 04 02:08:49 2011 -0500
@@ -8,6 +8,7 @@
 from sage.misc.misc import prod
 from sage.quadratic_forms.special_values import gamma__exact, zeta__exact, quadratic_L_function__exact
 from sage.functions.all import floor
+from sage.symbolic.expression import Expression, is_Expression
 
 
 
@@ -554,12 +555,12 @@
     ## Some useful variables
     n = self.dim()
     if n % 2 == 0:
-        s = n / 2
+        s = n / ZZ(2)
     else:
-        s = (n+1) / 2
+        s = (n+1) / ZZ(2)
 
     ## Compute the inverse of the generic p-mass
-    p_mass_inv = 2 * prod([1-p**(-i)  for i in range(2, 2*s, 2)]) 
+    p_mass_inv = ZZ(2) * prod([1-p**(-i)  for i in range(2, 2*s, 2)]) 
     if n % 2 == 0:
         D = (-1)**s * self.det() * (2**n)   ##   We should have something like  D = (-1)**s * self.det() / (2**n), but that's not an integer and here we only care about the square-class.
         #d = self.det()   ## Note: No normalizing power of 2 is needed since the power is even.
@@ -659,8 +660,12 @@
         for p in prime_divisors(2*d):
             mass *= (Q.conway_p_mass(p) / Q.conway_standard_p_mass(p))
 
+        ## Simplify any radicals that may appear in the mass
+        if isinstance(mass, Expression):
+            mass = mass.simplify_radical()
+
         ## Cache and return the (simplified) result
-        self.__conway_mass = QQ((mass**ZZ(2))**(ZZ(1)/ZZ(2)))
+        self.__conway_mass = QQ(abs(mass))
         return self.__conway_mass
 
 
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_form__maximal.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/quadratic_form__maximal.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,305 @@
+
+###########################################
+## Routines relating to maximal lattices ##
+###########################################
+
+from sage.misc.misc import verbose
+from copy import deepcopy
+
+from sage.rings.all import ZZ, QQ
+from sage.rings.all import GF
+from sage.matrix.constructor import matrix
+from sage.functions.other import sqrt
+from sage.misc.functional import squarefree_part
+from sage.rings.arith import prime_divisors
+
+from sage.quadratic_forms.maximal_extras import \
+    find_basis_of_maximal_isotropic_subspace, \
+    diagonalise_mod_2, \
+    even_neighbor_of_bilinear_gram_matrix
+
+
+#from sage.quadratic_forms.quadratic_form import DiagonalQuadraticForm
+
+#from sage.quadratic_forms.quadratic_form import QuadraticForm
+
+
+
+def is_maximal(self):
+    """
+    Returns if the current quadratic form is maximal (i.e. the
+    quadratic form of a maximal integer-valued lattice in its rational
+    quadratic space).
+
+    INPUT:
+        none
+    
+    OUTPUT:
+        boolean
+
+    EXAMPLES:
+        sage: Q3 = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q3.is_maximal()
+        True
+
+        sage: Q4 = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q4.is_maximal()
+        False
+
+        sage: Q4_sub = QuadraticForm(ZZ, 4, [1, 0, 0, 1,  1, 0, 1,  1, 1,  1])
+        sage: Q4_sub.is_maximal()
+        True
+        
+    """
+    Q_maximal = self.maximal_form()
+    if self.det() == Q_maximal.det():
+        return True
+    else:
+        return False
+    
+
+
+
+
+
+
+
+
+
+
+def maximal_form__Deprecated(self, return_transformation=False):
+    """
+    Return a quadratic form (for a maximal lattice) containing the
+    given form.
+
+    If return_transformation is True, then we also return the integral
+    linear transformation that achieves this.
+    
+    INPUT:
+
+    OUTPUT:
+        a quadratic form Q, or a pair (Q,T) where T is a square matrix of size Q.dim()
+
+    EXAMPLES:
+        sage: Q3 = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q3.maximal_form()
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 2 2 0 ]
+        [ * 1 0 ]
+        [ * * 1 ]
+
+        sage: Q4 = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q4.maximal_form()
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 2 2 2 2 ]
+        [ * 1 1 1 ]
+        [ * * 1 1 ]
+        [ * * * 1 ]
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [1])
+        sage: Q1.maximal_form()
+        Quadratic form in 1 variables over Integer Ring with coefficients: 
+        [ 1 ]
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [4])
+        sage: Q1.maximal_form()
+        Quadratic form in 1 variables over Integer Ring with coefficients: 
+        [ 1 ]
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [18])
+        sage: Q1.maximal_form()
+        Quadratic form in 1 variables over Integer Ring with coefficients: 
+        [ 2 ]
+
+    """
+    n = self.dim()
+
+    Big_trans = matrix(QQ, n, n, 1)    ## The cumulative transformation to arrive at the Watson form B
+ 
+
+    ## Compute the exponent of L#/L
+    B = self.matrix()
+
+    ## Precompute the exponent/index data once
+    ed = B.elementary_divisors()
+    max_ed = ed[-1]
+    f = max_ed.squarefree_part()
+    fa = sqrt(f * max_ed)
+    a = fa / f
+
+    #print
+    #print "f = ", f 
+    #print "a = ", a 
+    #print "fa = ", fa 
+    
+    ## Try to find the Watson superlattice
+    while a != 1:
+        B_inv = B.inverse()
+        generator_mat = matrix(ZZ, max_ed * B_inv)
+        X = generator_mat.augment(matrix(ZZ, n, n, a))
+        gen_lll = X.transpose().LLL().transpose().matrix_from_columns(range(n,2*n)) 
+        ##assume that the last rows returned by LLL constitue the basis of the lattice
+
+        B = matrix(ZZ, gen_lll.transpose() * B * gen_lll / (a*a))
+    
+        ## Save the transformation matrix
+        Big_trans = Big_trans * gen_lll/a 
+
+        ## Recompute the index/exponent data for L#/L
+        ed = B.elementary_divisors()
+        max_ed = ed[-1]
+
+        f = max_ed.squarefree_part()
+
+        ## DIAGNOSTIC
+        #print "X = ", X
+        #print "gen_lll = ", gen_lll
+        verbose("B = " + str(B))
+        verbose("")
+        verbose("f = " + str(f)) 
+    
+        fa = sqrt(f * max_ed)
+        a = fa / f
+
+        ## DIAGNOSTIC
+        verbose("a = " + str(a)) 
+        verbose("fa = " + str(fa)) 
+
+
+
+    ## Deal with the 1-dimensional case:
+    if n == 1:
+        new_coeff = squarefree_part(self[0,0])
+        Q_maximal = deepcopy(self)
+        Q_maximal.__init__(ZZ, 1, [new_coeff])
+        if return_transformation:
+            return Q_maximal, Matrix(QQ, 1, 1, [sqrt(self[0,0]/new_coeff)])
+        else:
+            return Q_maximal
+
+
+
+
+
+    ## Return the Watson form (for a superlattice)
+    verbose("Watson lattice B = " + str(B))
+    verbose("Big_trans = " + str(Big_trans))
+
+
+    ## even_sublattice_of_bilinear_gram_matrix
+
+
+
+
+    ## Deal with the remaining form
+    pp1 = prime_divisors(max_ed)
+    pp2 = prime_divisors(ed[-2])      ## This is ok, since n>=2 here.
+    ##pp2 = [p  for p in prime_divisors(ed[-2])  if p != 2]      ## QUICK FIX TO AVOID SAGE ERROR WHEN P=2 -- CHANGE THIS!
+
+    verbose("pp1 = " + str(pp1))
+    verbose("pp2 = " + str(pp2))
+
+    B1 = matrix(ZZ, max_ed * B.inverse())     ## This is a fix to deal with integer matrices
+    D, T, S = B1.smith_form()
+
+    ## These columns give a basis for the dual lattice L# mod L.
+    dual_columns = B1 * S
+
+    ## Loop through all primes to find a maximal isotropic space for each.
+    T_huge = matrix(ZZ,n,n,max_ed)    
+    for p in pp2:
+
+        ## DIAGNSOTIC
+        verbose("p = " + str(p))
+
+        cofacp = max_ed/p
+        d_p = n
+        for i in range(n):
+            if D[i,i] % p == 0:
+                d_p = i         ## Dim of L#/L
+                break
+
+
+        dp_cols_small = dual_columns.matrix_from_columns(range(d_p))
+        small_gram = matrix(ZZ,dp_cols_small.transpose() * B * dp_cols_small / max_ed)  
+        ## Divide out by max_ed only once, because we'll need this later.
+        ## print "small_gram = ", small_gram
+        ## print "small_gram_det = ", small_gram.det()
+        ## print "small_gram_ed = ", small_gram.elementary_divisors()
+        Tp = find_basis_of_maximal_isotropic_subspace(matrix(GF(p), small_gram))
+
+        ## DIAGNOSTIC
+        verbose("Finished finding maximal isotropic subspace at prime " + str(p))
+
+        TZ = dp_cols_small * matrix(ZZ,Tp).transpose()
+        T_huge = T_huge.augment(cofacp*TZ)
+
+
+    ## Return a basis for the maximal form.
+    ## print "pre-lll"
+    ## print "T_huge has ", T_huge.nrows(), " rows and ", T_huge.ncols(), "columns."
+    ## print type(T_huge), T_huge.parent()
+    ## print T_huge.rows()
+    nr = T_huge.ncols()  ## after LLL the last rows form a basis, the first ones are 0
+    T_lll = T_huge.transpose().LLL().matrix_from_rows(range(nr-n,nr)).transpose()  
+    ## print "post-lll"
+    Gram_of_max_lat = matrix(ZZ, T_lll.transpose() * B * T_lll / (max_ed* max_ed))
+
+
+    Gram_new, T_new = even_neighbor_of_bilinear_gram_matrix(Gram_of_max_lat)
+    T_newnew = Big_trans * T_lll * T_new / max_ed
+
+
+
+    ## Return the appropriate result
+    Q_maximal = deepcopy(self)
+    Q_maximal.__init__(Gram_new)
+    if return_transformation:
+        return Q_maximal, T_newnew
+    else:
+        return Q_maximal
+
+
+
+
+###########################
+## COMMENTS -- TO DELETE ##
+################################################################################################
+
+    Gram_even,trans_even,is_even = even_sublattice_of_bilinear_gram_matrix(Gram_of_max_lat)
+    if is_even:
+    	return Gram_of_max_lat, Big_trans * T_lll / max_ed  ## we already have found an even lattice
+################################################################################################
+    ## better way 
+    # Diagonalise the  Gram_of_max_lat modulo 2 (if this is odd, otherwise we are fine anyhow)
+    # Then either the even sublattice is already the maximal even overlattice 
+    # or this is generated by the even sublattice and 1/2 of the sum of all (n or (n-1)) 
+    # basisvectors of odd norm
+
+    Gram_diag,trans_diagmod2,numberofodd = diagonalise_mod_2(Gram_of_max_lat) 
+
+    	## should return a unimodular integral matrix s.t. Gram_diag = trans_diagmod2.transpose()*Gram_of_max_lat*trans_diagmod2 
+    	## is a diagonal matrix modulo 2
+    	## and an integer numberofodd, such that the first numberofodd vectors in trans_diagmod2 have odd norm
+    	## the others have even norm (so if det = 2 then numberoofodd = n-1 else n ) 
+    oddity = 0
+    for i in range(numberofodd):
+   	 oddity += Gram_diag[i,i]
+
+    if oddity % 8 == 0:
+    	halfcolunms = vector([1  for j in range(numberofodd)] + [0  for j in range(numberofodd, n)])
+    	newtrans =  matrix(ZZ,(2*trans_diagmod2).augment(halfcolumns.transpose())).transpose()
+        newtrans_lll = newtrans.LLL().matrix_from_rows(range(1,n+1)).transpose()  
+
+        ## Make the new matrix and transformation for non-zero oddity (mod 8)
+        new_A = newtrans_lll.transpose() * Gram_even * newtrans_lll / 4
+        new_T = Big_trans * T_lll * trans_even * newtrans_lll / (2* max_ed)
+        print "new_A = \n", new_A
+        print "new_T = \n", new_T
+        return matrix(ZZ, new_A), new_T
+
+    return Gram_even,  Big_trans * T_lll * trans_even / max_ed  ## if oddity is not zero mod 8 then the even sublattice is already maximal even
+    
+    
+################################################################################################
+################################################################################################
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_form__neighbors.py
--- a/sage/quadratic_forms/quadratic_form__neighbors.py	Sat Oct 30 16:00:40 2010 -0700
+++ b/sage/quadratic_forms/quadratic_form__neighbors.py	Tue Jan 04 02:08:49 2011 -0500
@@ -232,7 +232,7 @@
     for i in range(2,n):
         ith_prod = (good_basis[i] * self.matrix()).dot_product(v)
         c = (ith_prod / v1w_prod) % p
-        good_basis[i] = good_basis[i] - c * w  ## Ensures that this extension has <v_i, v> = 0 (mod p)
+        good_basis[i] = good_basis[i] - c * w  ## Ensures that this extenstion has <v_i, v> = 0 (mod p)
 
     ## DIAGNOSTIC
     #print "original good_basis = ", good_basis
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_lattice.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/quadratic_lattice.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,1013 @@
+
+
+## Routines that allow one to compute with quadratic lattices (i.e., a lattice in a quadratic space)
+
+
+
+from sage.rings.all import ZZ
+from sage.modules.free_module import FreeModule
+from sage.rings.principal_ideal_domain import is_PrincipalIdealDomain
+from sage.quadratic_forms.quadratic_form import QuadraticForm
+from sage.matrix.constructor import Matrix
+from copy import deepcopy
+
+
+class QuadraticLattice():
+    """
+
+    This class represents a (possibly not full rank) lattice in a
+    fixed quadratic space (V, Q), which is regarded as a discrete
+    additive subgroup of V which we may also require to be an R-module
+    where the quotient field of R has a natural inclusion to the base
+    field of V.  Here we do not distinguish the basis describing L as
+    ordered, though we do store an internal set of generators, which
+    we require to be a basis when the integers of the base field are
+    not free.
+
+    """
+
+
+
+    def __init__(self, QS, list_of_lattice_generators=None, base_ring=ZZ):
+        """
+
+        If no list of lattice generators is passed, then use the
+        standard basis by default.
+
+
+
+        TO DO:
+            Add support for a matrix (of column vectors) whose span defines the lattice.
+
+        
+
+        INPUT:
+            QS -- a quadratic space
+            lattice_info -- a list of vectors whose span defines the lattice
+            base_ring -- the ring over which our lattice is a module
+            
+        OUTPUT:
+            a quadratic lattice
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1]))
+            sage: L = QuadraticLattice(QS, [[1,1], [1,-1]]); L
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((1, 1), (0, 2)).            
+        
+        """
+        ## Check that the base ring is compatible with the quadratic space
+        if base_ring != ZZ:
+            raise NotmplementedError, "Presently we only support the base-ring ZZ."
+
+        ## Store the ambient quadratic space and base ring
+        self.__quadratic_space = QS
+        self.__base_ring = base_ring
+
+        ## Setup and store an ambient free module, and another one corresponding to the lattice.
+        FM = FreeModule(ZZ, QS.dim())
+        self.__ambient_free_module = FM
+        if list_of_lattice_generators == None:
+            LM = FM.span(Matrix(ZZ, QS.dim(), QS.dim(), 1).columns())   ## Use the standard basis by default
+        else:
+            LM = FM.span(list_of_lattice_generators)
+        self.__lattice_free_module = LM
+
+
+
+
+    def __repr__(self):
+        """
+        Print a string describing the quadratic lattice.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a string
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1]))
+            sage: L = QuadraticLattice(QS, [[1,1], [1,-1]]); L
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((1, 1), (0, 2)).            
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,2]))
+            sage: L = QuadraticLattice(QS); L
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 2 ]
+            spanned by ((1, 0), (0, 1)).            
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, []))
+            sage: L = QuadraticLattice(QS); L
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 0 variables over Rational Field with coefficients:
+            spanned by ().
+
+        """
+        return "Quadratic Lattice in " + str(self.quadratic_space()) + "spanned by " + str(self.__lattice_free_module.gens()) + "."
+
+
+
+    def __call__(self, v):
+        """
+        Evaluate the value of the ambient quadratic form on the given
+        vector in the quadratic space.
+
+        Note: This is evaluated as an element of the base field of the
+        quadratic space, since the vectormay not be integer-valued.
+
+
+        INPUT:
+            a vector, tuple or list of n numbers in the base_field
+
+        OUTPUT:
+            a number in the base field
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,2]))
+            sage: L = QuadraticLattice(QS); L
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 2 ]
+            spanned by ((1, 0), (0, 1)).            
+            sage: L([1,1]) == 3
+            True
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, []))
+            sage: L = QuadraticLattice(QS); L
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 0 variables over Rational Field with coefficients:
+            spanned by ().
+            sage: L([]) == 0
+            True
+            
+        """
+        return self.__quadratic_space(v)
+
+
+
+    def __eq__(self, other):
+        """
+
+        Determine if two quadratic lattices are equal (meaning that
+        they have the same underlying quadratic space V and give the
+        same subset of V).
+
+
+        INPUT:
+            other -- a quadratic lattice
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,2]))
+            sage: L1 = QuadraticLattice(QS)
+            sage: L2 = QuadraticLattice(QS, [[3, 4], [3,3], [1,0], [0,0]])
+            sage: L2 == L1
+            True
+            sage: L1 == L2
+            True
+
+            sage: QS_new = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [2,1]))
+            sage: L_new = QuadraticLattice(QS_new)
+            sage: L1 == L_new
+            False
+            sage: L2 == L_new
+            False
+            sage: L_new == L1
+            False
+            sage: L_new == L2
+            False
+
+        """
+        ## Check that ambient quadratic spaces are equal
+        if self.__quadratic_space != other.__quadratic_space:
+            return False
+
+        ## Check that the lattices have the same span in the quadratic space
+        return self.__lattice_free_module == other.__lattice_free_module
+
+        
+
+
+
+    def base_ring(self):
+        """
+        Returns the base ring over which we consider the quadratic
+        lattice as a module.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a ring
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,2]))
+            sage: L = QuadraticLattice(QS)
+            sage: L.base_ring()
+            Integer Ring
+
+            #sage: QS = QuadraticSpace(FiniteField(3), DiagonalQuadraticForm(ZZ, [1, 2, 3, 4, 5]))
+            #sage: L = QuadraticLattice(QS)
+            #sage: L.base_ring()
+            #Integer Ring              ## We would like this to be 'Finite Field of size 3', but we'll need to think about how to say the image of ZZ in a given field...
+
+
+        """
+        return deepcopy(self.__base_ring)
+
+
+
+    def quadratic_space(self):
+        """
+        Returns the ambient quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a quadratic space
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1, 5, 0, 1]))
+            sage: L = QuadraticLattice(QS)
+            sage: L.quadratic_space()
+            Quadratic space defined by the Quadratic form in 4 variables over Rational Field with coefficients:
+            [ 1 0 0 0 ]
+            [ * 5 0 0 ]
+            [ * * 0 0 ]
+            [ * * * 1 ]
+
+        """
+        return deepcopy(self.__quadratic_space)
+
+    
+
+    def lattice_free_module(self):
+        """
+        Returns the free module giving the lattice.
+
+        TO DO: Fix this!
+
+
+        INPUT:
+            None
+
+        OUTPUT:
+            The free module representing the lattice.
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1, 5]))
+            sage: L = QuadraticLattice(QS, [[1,1], [0, -1]])
+            sage: L.lattice_free_module()
+            Free module of degree 2 and rank 2 over Integer Ring
+            Echelon basis matrix:
+            [1 0]
+            [0 1]
+
+        """
+        return self.__lattice_free_module            ## Note:  This doesn't need (and can't use) deepcopy because freemodules are immutable! =)
+    
+
+
+
+    def quadratic_form__integral(self):
+        """
+        Returns a quadratic form associated to the quadratic lattice
+        (if it is free) in the given basis for the lattice, which is
+        the restriction of the quadratic form on the ambient quadratic
+        space.  If it is not free, then we raise an exception.
+
+        This quadratic form is defined over the base field of the
+        quadratic space, since there are no guarantees that it is
+        integer-valued.
+
+        TO DO: We would really like to think of the associated
+        quadratic form as being rational-valued, with the equivalence
+        for it defined as integral equivalence.  Unfortunately,
+        support for this kind of quadratic form has not been added.
+
+        
+        INPUT:
+            None
+
+        OUTPUT:
+            A quadratic form over a field.
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, QuadraticForm(ZZ, 3, range(1,7)))
+            sage: L = QuadraticLattice(QS)
+            sage: L.quadratic_form__integral()
+            Quadratic form in 3 variables over Integer Ring with coefficients:
+            [ 1 2 3 ]
+            [ * 4 5 ]
+            [ * * 6 ]
+
+        """
+        ## Check that the lattice is free
+        if not self.is_free():
+            return NotImplementedError, "Presently support for testing freeness is not supported for non-PID's."
+
+        ## Make a quadratic form using the Gram inner product on the underlying quadratic space.
+        Basis = self.basis()
+        r = len(Basis)
+        new_QF = QuadraticForm(self.base_ring(), r)
+        for i in range(r):
+            for j in range(i, r):
+                if i == j:
+                    new_QF[i,j] = self.__quadratic_space.inner_product__gram(Basis[i], Basis[j])
+                else:
+                    new_QF[i,j] = 2 * self.__quadratic_space.inner_product__gram(Basis[i], Basis[j])
+
+        ## Return the quadratic form
+        return new_QF
+
+
+
+    def quadratic_form__rational(self):
+        """
+        Returns a quadratic form associated to the quadratic lattice
+        (if it is free) in the given basis for the lattice, which is
+        the restriction of the quadratic form on the ambient quadratic
+        space.  If it is not free, then we raise an exception.
+
+        This quadratic form is defined over the base field of the
+        quadratic space, since there are no guarantees that it is
+        integer-valued.
+
+        TO DO: We would really like to think of the associated
+        quadratic form as being rational-valued, with the equivalence
+        for it defined as integral equivalence.  Unfortunately,
+        support for this kind of quadratic form has not been added.
+
+        
+        INPUT:
+            None
+
+        OUTPUT:
+            A quadratic form over a field.
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, QuadraticForm(ZZ, 3, range(1,7)))
+            sage: L = QuadraticLattice(QS)
+            sage: L.quadratic_form__rational()
+            Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 1 2 3 ]
+            [ * 4 5 ]
+            [ * * 6 ]
+
+        """
+        ## Check that the lattice is free
+        if not self.is_free():
+            return NotImplementedError, "Presently support for testing freeness is not supported for non-PID's."
+
+        ## Make a quadratic form using the Gram inner product on the underlying quadratic space.
+        Basis = self.basis()
+        r = len(Basis)
+        new_QF = QuadraticForm(self.__quadratic_space.base_field(), r)
+        for i in range(r):
+            for j in range(i, r):
+                if i == j:
+                    new_QF[i,j] = self.__quadratic_space.inner_product__gram(Basis[i], Basis[j])
+                else:
+                    new_QF[i,j] = 2 * self.__quadratic_space.inner_product__gram(Basis[i], Basis[j])
+
+        ## Return the quadratic form
+        return new_QF
+
+
+
+    def is_free(self):
+        """
+        Determines if the given lattice is a free over its base
+        ring.
+
+        TO DO:  IMPLEMENT THIS IN ANY NON-TRIVIAL CASE -- LIKE ORDERS IN NUMBER FIELDS!!!
+
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1]))
+            sage: L = QuadraticLattice(QS)
+            sage: L.is_free()
+            True
+
+            #sage: x = polygen(QQ, 'x')
+            #sage: F.<a> = NumberField(x^2 + 5)
+            #sage: R = F.ring_of_integers()
+            #sage: QS = QuadraticSpace(F, DiagonalQuadraticForm(QQ, [1,1]))
+            #sage: L1 = QuadraticLattice(QS)
+            #sage: L1.is_free()
+            #True
+            #
+            #sage: L2 = QuadraticLattice(QS, [[1,0], [0, 1 + a]])
+            #sage: L2.is_free()
+            #False
+        
+        """
+        ## Check if the base ring is a PID
+        if is_PrincipalIdealDomain(self.__base_ring) == True:
+            return True
+
+        ## IMPLEMENT THIS!!!
+        return NotImplementedError, "Presently support for testing freeness is not supported for non-PID's."
+ 
+    
+
+    def is_full_rank(self):
+        """
+        Determines if the lattice has full rank in the ambient
+        quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1]))
+
+            sage: L = QuadraticLattice(QS) 
+            sage: L.is_full_rank()
+            True
+
+            sage: L = QuadraticLattice(QS, []) 
+            sage: L.is_full_rank()
+            False
+
+            sage: L = QuadraticLattice(QS, [[1,1]]) 
+            sage: L.is_full_rank()
+            False
+
+            sage: L = QuadraticLattice(QS, [[1,1], [2,2]]) 
+            sage: L.is_full_rank()
+            False
+
+            sage: L = QuadraticLattice(QS, [[1,1], [1,0]]) 
+            sage: L.is_full_rank()
+            True
+
+        """
+        if self.__base_ring == ZZ:
+            return self.__lattice_free_module.rank() == self.__quadratic_space.dim()
+        else:
+            raise NotImplementedError, "Rank finding is not supported unless we're over ZZ."
+
+
+
+
+    def basis(self):
+        """
+        Returns a basis for the quadratic lattice if it is free, and
+        an error otherwise.
+
+        INPUT:
+            None
+        
+        OUTPUT:
+            A list of vectors
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1]))
+
+            sage: L = QuadraticLattice(QS, [[1,1], [2,2]]) 
+            sage: L.basis()
+            [
+            (1, 1)
+            ]
+            
+            sage: L = QuadraticLattice(QS, [[1,1], [1,0]]) 
+            sage: L.basis()
+            [
+            (1, 0),
+            (0, 1)
+            ]
+        
+        """
+        if self.is_free():
+            return self.__lattice_free_module.basis()
+        else:
+            raise NotImplementedError, "Basis finding is not supported unless we're over ZZ."
+
+        
+
+
+    def generators(self):
+        """
+        Returns a set of generators for the quadratic lattice, as a
+        module over its base ring.
+
+        TO DO: Add some non-trivial example where the basis and
+        generators are distinct! (I.e. a non-free module!)
+
+
+        INPUT:
+            None
+        
+        OUTPUT:
+            A list of vectors
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1]))
+
+            sage: L = QuadraticLattice(QS, [[1,1], [2,2]]) 
+            sage: L.generators()
+            ((1, 1),)
+            
+            sage: L = QuadraticLattice(QS, [[1,1], [1,0]]) 
+            sage: L.generators()
+            ((1, 0), (0, 1))
+
+        """
+        return self.__lattice_free_module.gens()
+
+
+
+
+    def has_same_quadratic_space(self, other):
+        """
+        Determines if self and other are lattices in the same
+        quadratic space (as an equality, not just an isomorphism).
+
+        INPUT:
+            other -- a quadratic lattice
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS1 = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1]))
+            sage: QS2 = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,4]))
+
+            sage: L1 = QuadraticLattice(QS1)
+            sage: L2 = QuadraticLattice(QS2)
+            sage: L3 = QuadraticLattice(QS1, [[1,1]])
+        
+            sage: L1.has_same_quadratic_space(L1)
+            True
+
+            sage: L1.has_same_quadratic_space(L2)
+            False
+            sage: L2.has_same_quadratic_space(L1)
+            False
+            
+            sage: L1.has_same_quadratic_space(L3)
+            True
+
+            sage: L2.has_same_quadratic_space(L3)
+            False
+
+        """
+        return self.__quadratic_space == other.__quadratic_space
+
+
+
+    def intersect_with(self, other):
+        """
+        Returns the quadratic lattice defined as the intersection of
+        the two given lattices (which must be defined on the same
+        ambient quadratic space, or an error is raised).
+
+        TO DO:  Fix this to use initialization of quadratic spaces from free modules when this is supported!
+
+
+        INPUT:
+            other -- a quadratic lattice on the same (equal) quadratic space
+
+        OUTPUT:
+           a quadratic lattice
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1]))
+            sage: L1 = QuadraticLattice(QS, [[1, 1]])
+            sage: L2 = QuadraticLattice(QS, [[5, 0], [0, 3]])
+
+            sage: L3 = L1.intersect_with(L2)
+            sage: L3 == L2.intersect_with(L1)
+            True
+            
+            sage: L3
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((15, 15),).
+            
+        """
+        ## Check that both lattices live on the same quadratic space
+        if not self.has_same_quadratic_space(other):
+            raise TypeError, "The two quadratic lattices live on different quadratic spaces!"
+
+        ## Return the intersection of the two quadratic latties
+        return QuadraticLattice(self.quadratic_space(), self.__lattice_free_module.intersection(other.__lattice_free_module).basis())
+
+
+
+    def sum_with(self, other):
+        """
+        Returns the quadratic lattice defined as the sum of the two
+        given lattices (which must be defined on the same ambient
+        quadratic space, or an error is raised).
+
+        INPUT:
+            other -- a quadratic lattice on the smae ambient quadratic space
+
+        OUTPUT:
+            a quadratic lattice on the same quadratic space
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1]))        
+
+            sage: L1 = QuadraticLattice(QS, [[1, 1]]) 
+            sage: L2 = QuadraticLattice(QS, [[1, -1]])
+            sage: L3 = L1.sum_with(L2); L3
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((1, 1), (0, 2)).
+
+            sage: L3 == L2.sum_with(L1)
+            True
+
+            sage: L4 = QuadraticLattice(QS, [[3, 3]]) 
+            sage: L5 = QuadraticLattice(QS, [[5, 5]])
+            sage: L6 = L4.sum_with(L5); L6
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((1, 1),).
+
+        """
+        ## Check that both lattices live on the same quadratic space
+        if not self.has_same_quadratic_space(other):
+            raise TypeError, "The two quadratic lattices live on different quadratic spaces!"
+
+        ## Return the lattice generated by generators of both lattices
+        return QuadraticLattice(self.quadratic_space(), self.generators() + other.generators())
+
+
+
+
+    def is_integer_valued(self):
+        """
+        Determines if the ambient quadratic space assumes only integer
+        values (by which we mean values in the base_ring) on the
+        quadratic lattice.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,4]))
+            sage: L1 = QuadraticLattice(QS, [[1, 1]])
+            sage: L1.is_integer_valued()
+            True
+
+            sage: L2 = QuadraticLattice(QS)
+            sage: L2.is_integer_valued()
+            True
+
+            sage: L3 = QuadraticLattice(QS, [[0, 1/2]])
+            sage: L3.is_integer_valued()
+            True
+
+            sage: L4 = QuadraticLattice(QS, [[1/2, 0]])
+            sage: L4.is_integer_valued()
+            False
+        
+
+        """
+        try:
+            self.quadratic_form__integral()
+            return True
+        except:
+            return False
+
+
+
+    def apply_linear_transformation_on_left(self, T):
+        """
+        Return the lattice given by applying the linear transformation
+        T to the given lattice (where T acts on column vectors by
+        left-multiplication!).  Here T can also be a scalar.
+
+        INPUT:
+            T -- a matrix giving a linear transformation on
+                     the underlying quadratic space, or a scalar.
+
+        OUTPUT:
+            a quadratic lattice
+
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1])) 
+            sage: L = QuadraticLattice(QS, [[1, 1]])
+            sage: T1 = Matrix(ZZ, 2, 2, [1,2,3,4])
+            sage: L1 = L.apply_linear_transformation_on_left(T1); L1
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((3, 7),).
+
+            sage: T2 = Matrix(ZZ, 2, 2, -1)
+            sage: L2 = L.apply_linear_transformation_on_left(T2); L2
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((1, 1),).
+
+            sage: L2 == L
+            True
+
+        """
+        gens = self.generators()
+        new_L = QuadraticLattice(self.quadratic_space(), [T * gens[i]  for i in range(len(gens))])
+        return new_L
+
+
+
+    def apply_linear_transformation_on_right(self, T):
+        """
+        Return the lattice given by applying the linear transformation
+        T to the given lattice (where T acts on column vectors by
+        right-multiplication!).  Here T can also be a scalar.
+
+        INPUT:
+            T -- a matrix giving a linear transformation on
+                     the underlying quadratic space, or a scalar.
+
+        OUTPUT:
+            a quadratic lattice
+
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1])) 
+            sage: L = QuadraticLattice(QS, [[1, 1]])
+            sage: T1 = Matrix(ZZ, 2, 2, [1,2,3,4])
+            sage: L1 = L.apply_linear_transformation_on_right(T1); L1
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((4, 6),).
+
+            sage: T2 = Matrix(ZZ, 2, 2, -1)
+            sage: L2 = L.apply_linear_transformation_on_right(T2); L2
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((1, 1),).
+
+            sage: L2 == L
+            True
+
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1,1]))
+            sage: M = Matrix(ZZ, 3, 3, range(9)); M
+            [0 1 2]
+            [3 4 5]
+            [6 7 8]
+            sage: QL =  QuadraticLattice(QS, [M.column(i)  for i in range(2)]); QL
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 1 0 0 ]
+            [ * 1 0 ]
+            [ * * 1 ]
+            spanned by ((1, 1, 1), (0, 3, 6)).
+            sage: QL.apply_linear_transformation_on_right(M[:2, :3])
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 1 0 0 ]
+            [ * 1 0 ]
+            [ * * 1 ]
+            spanned by ((1, 4, 7), (0, 9, 18)).
+
+        """
+        ## Check that the linear transformation has the correct size!
+
+        ## Perform the linear transformation
+        gens = self.generators()
+        M = Matrix(self.quadratic_space().base_field(), len(gens), self.quadratic_space().dim(), gens).transpose()  ## Makes the column matrix
+        new_L = QuadraticLattice(self.quadratic_space(), (M * T).columns())
+        return new_L
+
+
+
+
+    def inner_product__hessian(self, v, w):
+        """        
+        Compute the (Hessian) inner product of the given vectors in
+        the quadratic space.  This inner product is also used for
+        computing the dual lattice.
+
+        INPUT:
+            v, w -- vectors, lists or tuples defining a vector in the ambient quadratic space of the quadratic lattice.
+
+        OUTPUT:
+            an element of the base field of the quadratic space
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,-1]))
+            sage: L = QuadraticLattice(QS)     
+            sage: L.inner_product__hessian((1,0), (1,0))
+            2
+            sage: L.inner_product__hessian((1,0), (0,1))
+            0
+
+        """
+        return self.__quadratic_space.inner_product__hessian(v, w)
+
+
+
+    def Hessian_matrix(self, rational_matrix=False):
+        """
+        Compute the Hessian matrix w.r.t the basis of this quadratic lattice.
+        """
+        B = self.basis()
+        n = len(B)
+        if rational_matrix:
+            F = self.quadratic_space().base_field()
+            return Matrix(F, n, n, [self.inner_product__hessian(B[i], B[j])  for i in range(n)  for j in range(n)])
+        else:
+            R = self.base_ring()
+            return Matrix(R, n, n, [self.inner_product__hessian(B[i], B[j])  for i in range(n)  for j in range(n)])
+
+
+    def dual_lattice(self):
+        """
+        Compute the dual lattice with respect to the Hessian bilinear
+        form associated to the quadratic form on the underlying
+        quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a quadratic lattice in the same ambient quadratic space.
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1])) 
+            sage: L = QuadraticLattice(QS)
+            sage: L_dual = L.dual_lattice(); L_dual
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((1/2, 0), (0, 1/2)).
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [2,45/11,1/12]))
+            sage: L = QS.integral_lattice()
+            sage: L.dual_lattice()
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 2 0 0 ]
+            [ * 45/11 0 ]
+            [ * * 1/12 ]
+            spanned by ((1/4, 0, 0), (0, 1/90, 0), (0, 0, 1)).
+
+        """
+        ## Check that the lattice is free -- useful for now, but can be easily circumvented by dealing with generators instead!
+        if not self.is_free():
+            raise NotImplementedError, "We currently don't have an implementation for non-free lattices..." 
+
+        ## Compute the dual basis w.r.t. the Hessian bilinear form.
+        H = self.__quadratic_space.hessian_matrix()      ## Hessian matrix in std basis
+        A = self.__lattice_free_module.basis_matrix()       ## Matrix of basis for L, as row vectors.
+
+        ## Solve A * H * B = Id to get a basis of the dual lattice 
+        B = (A * H).inverse()
+
+        return QuadraticLattice(self.quadratic_space(), B.columns())
+        
+
+
+def Watson_superlattice(self):
+    """
+    
+    Find the Watson superlattice of the given lattice, defined by the
+    formula
+
+    
+    Note: Presenty this code comes from the
+    QuadraticForm.maximal_form() method.
+
+    """
+
+    ## Compute the exponent of L#/L
+    B = self.matrix()
+
+    ## Precompute the exponent/index data once
+    ed = B.elementary_divisors()
+    max_ed = ed[-1]
+    f = max_ed.squarefree_part()
+    fa = sqrt(f * max_ed)
+    a = fa / f
+
+    #print
+    #print "f = ", f 
+    #print "a = ", a 
+    #print "fa = ", fa 
+    
+    ## Try to find the Watson superlattice
+    while a != 1:
+        B_inv = B.inverse()
+        generator_mat = matrix(ZZ, max_ed * B_inv)
+        X = generator_mat.augment(matrix(ZZ, n, n, a))
+        gen_lll = X.transpose().LLL().transpose().matrix_from_columns(range(n,2*n)) 
+        ##assume that the last rows returned by LLL constitue the basis of the lattice
+
+        B = matrix(ZZ, gen_lll.transpose() * B * gen_lll / (a*a))
+    
+        ## Save the transformation matrix
+        Big_trans = Big_trans * gen_lll/a 
+
+        ## Recompute the index/exponent data for L#/L
+        ed = B.elementary_divisors()
+        max_ed = ed[-1]
+
+        f = max_ed.squarefree_part()
+
+        ## DIAGNOSTIC
+        #print "X = ", X
+        #print "gen_lll = ", gen_lll
+        verbose("B = " + str(B))
+        verbose("")
+        verbose("f = " + str(f)) 
+    
+        fa = sqrt(f * max_ed)
+        a = fa / f
+
+        ## DIAGNOSTIC
+        verbose("a = " + str(a)) 
+        verbose("fa = " + str(fa)) 
+
+
+
+    ## Deal with the 1-dimensional case:
+    if n == 1:
+        new_coeff = squarefree_part(self[0,0])
+        Q_maximal = deepcopy(self)
+        Q_maximal.__init__(ZZ, 1, [new_coeff])
+        if return_transformation:
+            return Q_maximal, Matrix(QQ, 1, 1, [sqrt(self[0,0]/new_coeff)])
+        else:
+            return Q_maximal
+
+
+
+
+
+    ## Return the Watson form (for a superlattice)
+    verbose("Watson lattice B = " + str(B))
+    verbose("Big_trans = " + str(Big_trans))
+
+
+
+
+
+
+## ====================================================================================================================    
+
+
+#    def maximal_integer_valued_superlattice(self):
+#        """
+#        Produces some integer-valued superlattice of the given
+#        quadratic lattice, assuming that the given lattice is
+#        integer-valued.  If not, then an exception/error is raised.
+#
+#        """
+#        pass
+
+
+
+## ====================================================================================================================
+
+
+#    def neighbors_of_index(self, m):
+#        """
+#        Returns the set of m-neighbors of the given quadratic lattice.
+#
+#        """
+#        pass
+
+
+
+
+#    def discriminant_group(self):
+#        """
+#
+#        Returns the discriminant group, which is a module with an
+#        induced (QQ/ZZ)-valued quadratic form.
+#
+#        """
+#        pass
+
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/quadratic_space.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/quadratic_space.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,2753 @@
+
+
+
+
+
+
+
+## Required structures:
+## --------------------
+
+
+
+from sage.quadratic_forms.square_classes import SquareClass, local_squareclass_representatives_list, local_squareclass_radius_val
+from sage.quadratic_forms.weak_approx import weak_approx_for_numbers_over_QQ, \
+                                             weak_approx_for_squareclasses_over_QQ, \
+                                             strong_approx_for_squareclasses_by_QQ_except_at_one_prime
+
+from sage.quadratic_forms.localization import Qv
+
+from sage.quadratic_forms.quadratic_lattice import QuadraticLattice
+
+
+
+from sage.rings.arith import hilbert_symbol, legendre_symbol, valuation, is_square, is_prime, prime_divisors, is_squarefree
+from sage.rings.integer_ring import ZZ
+from sage.rings.finite_field import GF
+
+
+from sage.functions.other import floor, sqrt
+
+
+from sage.misc.functional import squarefree_part, is_even, is_odd
+from sage.misc.misc import prod, verbose
+
+
+from sage.quadratic_forms.quadratic_form import QuadraticForm, DiagonalQuadraticForm
+from sage.quadratic_forms.extras import sgn, least_quadratic_nonresidue
+from sage.matrix.all import is_Matrix
+from sage.matrix.constructor import matrix, Matrix
+
+from sage.rings.field import Field
+
+
+from sage.rings.rational_field import is_RationalField, QQ, RationalField
+from sage.rings.real_mpfr import RealField
+from sage.rings.all import is_ComplexField, is_pAdicField, is_FiniteField
+
+
+
+from sage.rings.infinity import Infinity
+from sage.rings.padics.factory import Qp
+
+from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
+from sage.modules.free_module_element import vector
+
+
+from copy import deepcopy
+
+
+#from sage.rings.arith import is_square, is_prime, valuation, legendre_symbol
+
+from sage.quadratic_forms.symmetric_bilinear_space import SymmetricBilinearSpace
+
+
+
+###################################################
+## Create a QuadraticSpace class which defines a ##
+## quadratic space over a local or global field. ##
+###################################################
+
+class QuadraticSpace():
+    """
+    Defines a quadratic space, by which we mean a diagonal quadratic form over a field.
+    """
+
+
+    def __init__(self, K, coeffs=None, matrix_type='Gram'):
+        """
+        Initializes a quadratic space over a given field from:
+            1) a symmetric matrix (either Gram or Hessian)
+            2) a list of diagonal entries
+            ##3) local invariants (for a local field)
+
+        If the coefficients are not elements of the base field, then
+        they must automatically coerce into it or a RuntimeError will
+        be raised.  
+
+        Valid syntax possibilities:
+            QuadraticSpace(Q) -- where Q is a quadratic form defined over a field
+            QuadraticSpace(K, Q) -- where Q is a quadratic form/space with coefficients coercible to the field K
+            QuadraticSpace(K, [a_1, a_2, ..., a_n]) -- where K is a field and the elements a_1, ..., a_n are coercible to elements of K.
+
+        The option 'matrix_type' is only used if we are respectively
+        given a matrix or quadratic form as input.  The setting
+        matrix_type describes the type of matrix that is passed in.
+        If matrix_type is 'Hessian', then we create a quadratic space
+        whose Hessian matrix agrees with this form (by taking half of
+        this matrix first).
+
+        CONVENTION/BIG ASSUMPTION: The matrix associated to a
+        quadratic space is always its Gram matrix, and we assume that
+        the field is of characteristic not 2 (since this is the
+        customary usage for most people!).
+
+
+        INPUT:
+            K -- a local or global field, or possibly a symmetric matrix or a quadratic form defined over a field.
+            coeffs -- either a list of diagonal coefficients, a quadratic form or a symmetric matrix
+            matrix_type -- either 'Gram' or 'Hessian'
+
+        OUTPUT:
+            none
+
+        INTERNAL VARIABLES:
+            self.__quadratic_form -- the underlying quadratic form, used for printing or evaluation in the standard basis
+            self.__diagonal_form -- used for internal computations of invariants
+            self.__gram_matrix -- used for computing inner products
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(DiagonalQuadraticForm(QQ, [1,2,3])); QS
+            Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 1 0 0 ]
+            [ * 2 0 ]
+            [ * * 3 ]
+            
+            sage: QS = QuadraticSpace(Qp(5), DiagonalQuadraticForm(QQ, [1,2,3])); QS
+            Quadratic space defined by the Quadratic form in 3 variables over 5-adic Field with capped relative precision 20 with coefficients:
+            [ 1 + O(5^20) 0 0 ]
+            [ * 2 + O(5^20) 0 ]
+            [ * * 3 + O(5^20) ]
+
+            sage: QS = QuadraticSpace(QQ, DiagonalMatrix(QQ,[1,2,3]), matrix_type="Gram"); QS
+            Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 1 0 0 ]
+            [ * 2 0 ]
+            [ * * 3 ]
+            sage: QS.gram_matrix()
+            [1 0 0]
+            [0 2 0]
+            [0 0 3]
+
+
+            sage: A = matrix(QQ, 2, 2, [3,1,1,3])
+            sage: QS = QuadraticSpace(QQ, A, matrix_type="Gram"); QS
+            Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 3 2 ]
+            [ * 3 ]
+            sage: QS.gram_matrix() == A
+            True
+
+            sage: QS = QuadraticSpace(QQ, A, matrix_type="Hessian"); QS
+            Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 3/2 1 ]
+            [ * 3/2 ]
+            sage: QS.hessian_matrix() == A
+            True
+            
+        """
+        ## Validate the input:
+        ## -------------------
+        if not isinstance(K, (Field, QuadraticForm)):
+            raise TypeError, "The first argument must be either a field or a quadratic form!"
+
+        if (coeffs != None) and not (is_Matrix(coeffs) or isinstance(coeffs, (list, QuadraticForm, QuadraticSpace))):
+            raise TypeError, "The second argument entry must be either a list of coefficients, a quadratic form, a quadratic space or a (symmetric) matrix!"
+
+
+        ## INPUT #1:  Check for the syntax QuadraticSpace(Q) where Q is a QuadraticForm defined over a base_ring which is a field.
+        if is_Matrix(K) or isinstance(K, QuadraticForm):
+
+            ## Sanity Check: Verify that coeffs has not been set redundantly.
+            if (coeffs != None):
+                raise TypeError, "Invalid Syntax -- only one argument is allowed when the first argument is a matrix or a quadratic form."
+
+            coeffs = K
+
+            ## Check that the quadratic form is defined over a field.
+            base_field = coeffs.base_ring()
+            if not isinstance(base_field, Field):
+                raise TypeError, "The syntax QuadraticSpace(Q) requires that the QuadraticForm (or QuadraticSpace or Matrix) Q is defined over a field -- it is defined over " + str(Q.base_ring()) + "."
+
+        ## INPUT #2  Check for the syntax QuadraticSpace(K, Q) where K is a field and Q is a quadratic form or a quadratic space
+        else:
+            base_field = K
+
+            ## Test for fields of characteristic 2      -- This is only partially supported for now!  self.anisotropic_dim() should work! =)
+            #if K.characteristic() == 2:
+            #    raise NotImplementedError, "Fields of characteristic 2 are not currently supported."
+            
+            
+
+        ## Initialize the quadratic space:
+        ## -------------------------------
+
+        ## Initialize from a QuadraticSpace
+        if isinstance(coeffs, QuadraticSpace):
+            self.__quadratic_form = coeffs.defining_quadratic_form().base_change_to(base_field)
+            self.__hessian_bilinear_space = SymmetricBilinearSpace(base_field, self.__quadratic_form.Hessian_matrix())
+            #self.__gram_matrix = self.__quadratic_form.Gram_matrix()
+            self.__diagonal_form = self.__quadratic_form.rational_diagonal_form()
+            self.__diagonal_squareclass_list = [SquareClass(self.base_field(), self.__diagonal_form[i,i])  for i in range(self.dim())]   
+
+        ## Initialize from a list of coefficients
+        elif isinstance(coeffs, list):
+            self.__quadratic_form = DiagonalQuadraticForm(base_field, coeffs)
+            self.__hessian_bilinear_space = SymmetricBilinearSpace(base_field, self.__quadratic_form.Hessian_matrix())
+            #self.__gram_matrix = self.__quadratic_form.Gram_matrix()
+            self.__diagonal_form = self.__quadratic_form
+            self.__diagonal_squareclass_list = [SquareClass(self.base_field(), self.__diagonal_form[i,i])  for i in range(self.dim())]   
+
+        ## Initialize from a Matrix (by converting it to a quadratic form)
+        elif is_Matrix(coeffs):
+            if not coeffs.is_symmetric():
+                raise TypeError, "The given input matrix \n" + str(coeffs) + "\nmust be symmetric."
+
+            ## Create the associated quadratic form Q for this matrix (so that the Gram Matrix of Q is the quadratic form on the ambient quadratic space.)
+            if matrix_type == "Gram":
+                self.__quadratic_form = QuadraticForm(base_field, coeffs, init_from_gram_matrix=True)
+                #self.__quadratic_form = QuadraticForm(base_field, coeffs).scale_by_factor(ZZ(2))  
+                self.__hessian_bilinear_space = SymmetricBilinearSpace(base_field, self.__quadratic_form.Hessian_matrix())
+                #self.__gram_matrix = self.__quadratic_form.Gram_matrix()
+                self.__diagonal_form = self.__quadratic_form.rational_diagonal_form()
+                self.__diagonal_squareclass_list = [SquareClass(self.base_field(), self.__diagonal_form[i,i])  for i in range(self.dim())]   
+            elif matrix_type == "Hessian":
+                try:
+                    self.__quadratic_form = QuadraticForm(base_field, coeffs)  
+                    self.__hessian_bilinear_space = SymmetricBilinearSpace(base_field, self.__quadratic_form.Hessian_matrix())
+                    #self.__gram_matrix = self.__quadratic_form.Gram_matrix()
+                    self.__diagonal_form = self.__quadratic_form.rational_diagonal_form()
+                    self.__diagonal_squareclass_list = [SquareClass(self.base_field(), self.__diagonal_form[i,i])  for i in range(self.dim())]   
+                except:
+                    raise RuntimeError, "There is a problem with division by 2 in your field -- does it have characteristic 2?"
+            else:
+                raise TypeError, "The matrix_type must be either 'Gram' or 'Hessian'."
+
+        ## Initialize from a Quadratic Form
+        elif isinstance(coeffs, QuadraticForm):
+            self.__quadratic_form = coeffs.base_change_to(base_field)
+            self.__hessian_bilinear_space = SymmetricBilinearSpace(base_field, self.__quadratic_form.Hessian_matrix())
+            #self.__gram_matrix = self.__quadratic_form.Gram_matrix()
+            self.__diagonal_form = self.__quadratic_form.rational_diagonal_form()
+            self.__diagonal_squareclass_list = [SquareClass(self.base_field(), self.__diagonal_form[i,i])  for i in range(self.dim())]   
+
+
+
+    def __repr__(self):
+        """
+        Print a string describing the quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a string
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(DiagonalQuadraticForm(QQ, [1/2, 11]))
+            sage: QS.__repr__()
+            'Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients: \n[ 1/2 0 ]\n[ * 11 ]\n'
+        """
+        return "Quadratic space defined by the " + str(self.__quadratic_form)
+
+
+
+    def anisotropic_dim(self, QQ_place=None):
+        """
+
+        Return the dimension of the maximal anisotropic subspace of
+        the quadratic space.  If the quadratic form is defined over
+        QQ, then an additional place may be passed to compute the
+        anisptropic dimension of the localization of that quadratic
+        space at that place.
+
+        Since the computation of the anisotropic dimension depends on
+        the base field, currently the only the finite fields, real and
+        complex fields, p-adic fields (Qp only), and QQ are supported.
+
+        INPUT:
+            QQ_place -- a prime number or Infinity
+                (an optional argument which only makes sense if the
+                base field is QQ).
+        
+        OUTPUT:
+            an integer >= 0
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -1, 2, 3]))
+            sage: QS.anisotropic_dim()
+            2
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -1, 1, -1]))
+            sage: QS.anisotropic_dim()
+            0
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, 1, 1, 1, 1, 1]))
+            sage: QS.anisotropic_dim()
+            6
+            
+        """
+        ## Deal with (Hessian) degenerate quadratic spaces!
+        if self.is_degenerate():
+            (R, C) = self.__hessian_bilinear_space.find_basis_of_radical_subspace()
+            #print "self = " + str(self)
+            #print "R = " + str(R)
+            #print "C = " + str(C)
+            F = self.base_field()
+            if C != []:
+                M_nondeg = Matrix(F, C).transpose()          ## Matrix of columns giving a basis for a maximal (Hessian) non-degenerate quadratic space
+                nondeg_QS = QuadraticSpace(self.base_field(), self.__quadratic_form(M_nondeg))
+                nondeg_aniso_dim = nondeg_QS.anisotropic_dim()
+            else:
+                nondeg_aniso_dim = 0    ## If there are no matrix entries, then there is no anisotripic vector!
+
+            ## In characteristic 2, adjust by the number of non-zero diagonal entries (See Kitaoka's book, Thrm 1.2.1 on pp4-5.)
+            if F.characteristic() == 2:
+                if R != []:
+                    M_deg = Matrix(F, R).transpose()          ## Matrix of columns giving a basis for the maximal (Hessian) degenerate quadratic space
+                    deg_QF = self.__quadratic_form(M_deg)
+                    t = 0
+                    for i in range(deg_QF.dim()):
+                        if deg_QF[i,i] != 0:
+                            t += 1
+                else:
+                    t = 0      ## If there are no matrix entries, then there is no anisotripic vector!  
+
+                return nondeg_aniso_dim + t
+
+            else:
+                return nondeg_aniso_dim
+
+
+            ## TO DO:  We can simplify the above code by allowing a 0x0 matrix transformation to always return the empty QF, and never raise an error!
+            ## (We could even allow a flag that permits this behavior, if we don't want to allow it in general.)
+
+
+        
+        ## Deal with non-degenerate quadratic spaces:
+        ## ------------------------------------------
+        F = self.base_field()
+        n = self.dim()
+
+        ## Case 1: Finite Fields (with char > 2 or char == 2)
+        if is_FiniteField(F):
+            if n % 2 == 1:
+                return 1
+            else:   
+
+                ## Perform Square-testing to see if the last binary space splits
+                if F.characteristic() == 2:
+                    return 0                  ## All elements are squares in characteristic 2
+                else:                    
+                    d = self.determinant().representative()
+                    d_aniso = d * (-1)**((n-2)/2)
+
+                    if (-d_aniso)**((F.order() - 1) / 2) == 1:   ## Use the Legendre symbol test for characteristic > 2
+                        return 0
+                    else:
+                        return 2
+
+        ## Case 2: p-adic fields Q_p
+        elif is_pAdicField(F) or (is_RationalField(F) and is_prime(QQ_place)):
+            d = self.determinant().representative()
+            p = self.base_field().prime()
+            if not is_prime(p):
+                raise RunTimeError, "We only support the p-adic fields Q_p where p is a prime for now."
+            return local_quadratic_space_anisotropic_dimension_by_invariants(p, n, d, self.hasse_invariant(p))
+
+        ## Case 3: Real Fields
+        elif isinstance(F, RealField) or (is_RationalField(F) and (QQ_place == Infinity)):
+            return abs(self.__quadratic_form.signature())
+
+        ## Case 4: Complex Fields
+        elif is_ComplexField(F):
+            return n % 2
+
+        ## Case 5: The Rational Numbers QQ:
+        ## --------------------------------
+        elif is_RationalField(F):
+
+            ## Find the anisotropic dimension at all "bad" places
+            d = self.determinant().normalized_representative()
+            bad_prime_list = prime_divisors(2*d)
+            real_aniso_dim = abs(self.__quadratic_form.signature())
+            aniso_dim_list = [local_quadratic_space_anisotropic_dimension_by_invariants(p, n, d, self.hasse_invariant(p))  for p in bad_prime_list] + [real_aniso_dim]
+
+            ## Compute the generic local anisotropic dimension
+            if n % 2 != 0:
+                generic_aniso_dim = 1
+            else:
+                d_aniso = d * (-1)**((n-2)/2)
+                ## Check if the 2-dim'l is split over QQ, which determines the even-dim'l generic anisotropic dimension
+                if is_square(-d_aniso):
+                    generic_aniso_dim = 0
+                else:
+                    generic_aniso_dim = 2
+
+            ## Compute the actual anisotropic dimension
+            aniso_QQ_dim = max(aniso_dim_list + [generic_aniso_dim])
+            return aniso_QQ_dim
+
+
+        ## Case 6: UNSUPPORTED
+        else:
+            raise NotImplementedError, "The anisotropic dimension calculation is not supported yet for this basefield."
+
+
+
+
+
+
+    def anisotropic_det(self):
+        """
+        Return the determinant (squareclass) of the maximal anisotropic subspace of the quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a non-zero squareclass
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -1, 2, 3]))
+            sage: QS.anisotropic_det()
+            The squareclass represented by 6 over Rational Field
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -1, 1, -1]))
+            sage: QS.anisotropic_det()
+            The squareclass represented by 1 over Rational Field
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, 1, 1, 1, 1, 1]))
+            sage: QS.anisotropic_det()
+            The squareclass represented by 1 over Rational Field
+        
+        """
+        aniso_dim = self.anisotropic_dim()
+        return self.determinant() * (-1)**((self.dim() - aniso_dim) / 2)
+
+
+
+
+    def base_field(self):
+        """
+        Returns the base field of scalars for the quadratic space as a vectorspace.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a field
+
+        EXAMPLES:
+            sage: QF = DiagonalQuadraticForm(ZZ, [1, 1])
+        
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.base_field()
+            Rational Field
+
+            sage: QS = QuadraticSpace(Qp(17), QF)
+            sage: QS.base_field()
+            17-adic Field with capped relative precision 20
+            
+            sage: QS = QuadraticSpace(RR, QF) 
+            sage: QS.base_field()
+            Real Field with 53 bits of precision
+            
+            sage: QS = QuadraticSpace(CC, QF) 
+            sage: QS.base_field()
+            Complex Field with 53 bits of precision
+            
+            sage: QS = QuadraticSpace(FiniteField(11), QF) 
+            sage: QS.base_field()
+            Finite Field of size 11            
+        
+        """
+        return self.__quadratic_form.base_ring()
+
+
+
+    def defining_quadratic_form(self):
+        """
+        Returns the defining quadratic form (i.e. the quadratic form
+        of the quadratic space in the standard basis) for the
+        quadratic space, coerced to the base_field of the quadratic space.
+
+        TO DO: Change the name to 'quadratic_form()', since eventually
+        this will not be canonical when we are working with non-free
+        lattices!
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a quadratic form
+
+        EXAMPLES:
+            sage: QF = QuadraticForm(ZZ, 3, range(6))
+
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.defining_quadratic_form()
+            Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 0 1 2 ]
+            [ * 3 4 ]
+            [ * * 5 ]
+            
+            sage: QS = QuadraticSpace(CC, QF)
+            sage: QS.defining_quadratic_form()
+            Quadratic form in 3 variables over Complex Field with 53 bits of precision with coefficients:
+            [ 0 1.00000000000000 2.00000000000000 ]
+            [ * 3.00000000000000 4.00000000000000 ]
+            [ * * 5.00000000000000 ]
+
+            sage: QS = QuadraticSpace(FiniteField(5), QF)
+            sage: QS.defining_quadratic_form()
+            Quadratic form in 3 variables over Finite Field of size 5 with coefficients:
+            [ 0 1 2 ]
+            [ * 3 4 ]
+            [ * * 0 ]
+                 
+        """
+        return deepcopy(self.__quadratic_form)
+
+
+    def dim(self):
+        """
+        Returns the dimension (as a vectorspace over the base field)
+        of the quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            an integer >= 0
+
+        EXAMPLES:
+            sage: QF = QuadraticForm(ZZ, 3, range(6))
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.dim()
+            3
+
+        """
+        return self.__quadratic_form.dim()
+
+
+
+
+    def det_Gram(self):
+        """
+        Returns the determinant of the Gram matrix of the defining
+        quadratic form for the quadratic space (in the standard basis).
+
+        INPUT:
+            None
+            
+        OUTPUT:
+            an element of the base field
+
+        EXAMPLES:
+            sage: QF = QuadraticForm(ZZ, 3, range(6))
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.det_Gram()
+            -9/4
+        
+        """
+        return self.__quadratic_form.Gram_det()
+
+    
+    def det_Hessian(self):
+        """
+        Returns the determinant of the Hessian matrix of the defining
+        quadratic form for the quadratic space (in the standard basis).
+
+        INPUT:
+            None
+            
+        OUTPUT:
+            an element of the base field
+
+        EXAMPLES:
+            sage: QF = QuadraticForm(ZZ, 3, range(6))
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.det_Hessian()
+            -18
+
+        """
+        return self.__quadratic_form.det()      ## TO DO: This should be changed to Hessian_det() in QF, and not only be the default.
+
+
+       
+    def determinant(self):
+        """
+        Returns the squareclass of the Gram determinant of the given
+        quadratic form.  This determinant is the product of the
+        diagonal entries when the form is diagonal (which it can
+        always be arranged to be).
+
+        TO DO:  CHANGE THIS TO 'det_squareclass()', SO THE USER DOESN'T EXPECT A NUMBER!
+
+        INPUT:
+            None
+            
+        OUTPUT:
+            an element of the base field
+
+        EXAMPLES:
+            sage: QF = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.determinant()
+            The squareclass represented by 1 over Rational Field            
+
+            sage: QS.det_Hessian()
+            8
+
+            sage: QS.det_Gram()
+            1
+
+        """
+        return SquareClass(self.base_field(), self.det_Gram())
+    
+    
+    def determinant_signed(self):
+        """
+        Returns the squareclass of the signed Gram determinant of the
+        given quadratic form.  This determinant is the product of the
+        diagonal entries when the form is diagonal (which it can
+        always be arranged to be), multiplied by (-1)^(n*(n-1)/2)
+        where n is the dimension of the quadratic space.
+
+        TO DO: Change the name to 'det_signed_Gram()' to be consistent
+        with the other method notation!
+
+        REFERENCE:
+            This is defined in Lam's book section II.2 on p30.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            an element of the base field
+
+        EXAMPLES:
+            sage: QF = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.determinant_signed()
+            -1
+
+        """
+        n = self.dim()
+        return self.det_Gram() * (-1)**(n*(n-1)/2)
+
+
+
+    def diagonal_squareclass_list(self):
+        """
+        Returns a list of the self.dim() squareclasses defined by some
+        (usually not unique) diagonalization of the quadratic form on
+        this quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a list of squareclasses defined over the base field
+
+        EXAMPLES:
+            sage: QF = DiagonalQuadraticForm(QQ, [1, 2, 1/18])
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.diagonal_squareclass_list()
+            [The squareclass represented by 1 over Rational Field, The squareclass represented by 2 over Rational Field, The squareclass represented by 1/18 over Rational Field]
+
+        """
+        return deepcopy(self.__diagonal_squareclass_list)
+
+
+
+    def gram_matrix(self):
+        """
+        Returns the gram matrix (which defines all Gram inner
+        products) for this quadratic space.
+
+        """
+        return self.__quadratic_form.matrix() * ZZ(1)/ZZ(2)
+
+
+
+    def hasse_invariant(self, QQ_place=None):
+        """
+        Returns the Hasse invariant of the quadratic form, which is
+        defined as the product of the Hilbert symbols (a_i, a_j) where
+        i < j.  This is defined for any field of characteristic not 2.
+        
+        If the quadratic space is defined over QQ, then we must pass in
+        QQ_place as either a prime p > 0 or Infinity.  In this case we
+        will return the local Hasse invariant over the associated
+        local field.
+
+        INPUT:
+            QQ_place -- a prime number or Infinity
+                (an argument required if the base field is QQ).
+        
+        OUTPUT:
+            an integer >= 0
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(Qp(5), DiagonalQuadraticForm(QQ, [1, -1, 2, 3]))
+            sage: QS.hasse_invariant()
+            1
+
+            sage: QS = QuadraticSpace(RR, DiagonalQuadraticForm(QQ, [1, -1, 1, -1]))
+            sage: QS.hasse_invariant()
+            -1
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, 1, 1, 1, -1, -1]))
+            sage: QS.hasse_invariant(Infinity)
+            -1
+            sage: QS.hasse_invariant(2)
+            -1
+            sage: QS.hasse_invariant(3)
+            1
+            sage: QS.hasse_invariant(5)
+            1
+
+        """
+        hasse_temp = 1
+        n = self.dim()
+        DSL = self.__diagonal_squareclass_list
+ 
+        for j in range(n-1):
+            for k in range(j+1, n):
+                hasse_temp = hasse_temp * DSL[j].hilbert_symbol(DSL[k], QQ_place)
+
+        return hasse_temp
+
+        
+
+
+    def hessian_matrix(self):
+        """        
+        Returns the Hessian matrix (which defines all Hessian inner
+        products) for this quadratic space.
+
+        """
+        return self.__quadratic_form.matrix()
+
+
+
+    def scale_by_factor(self, c):
+        """
+        Gives the current quadratic space scaled by the constant factor c.
+
+        Note: Think about coercing c into a global element first.
+        Also check the creation conventions to make sure we're
+        compatibile with them.
+
+        INPUT:
+            c -- a number coercible to the base field
+
+        OUTPUT:
+            a quadratic space
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -2, 3]))   ## Scaling a 3-dim'l form
+            sage: QS3 = QS.scale_by_factor(3)
+            sage: QS.det_Hessian() * 3**QS.dim() == QS3.det_Hessian()
+            True
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, []))    ## Try scaling a 0-dim'l form
+            sage: QS3 = QS.scale_by_factor(3)
+            sage: QS.det_Hessian() == QS3.det_Hessian()
+            True
+
+        """
+        ## Validate the constant c -- TO DO!
+        try:
+            c1 = self.base_field()(c)
+        except:
+            raise RuntimeError, "The scaling factor " + str(c) + " is not coercible to the base field " + str(self.base_field()) + "." 
+
+        ## Return the scaled quadratic space
+        return QuadraticSpace(self.__quadratic_form.scale_by_factor(c))
+
+
+
+
+
+
+
+
+    def hasse_primes_of_QQ(self):
+        """
+        Give a list of the finitely many primes p where the quadratic space
+        has Hasse invariant c_p = -1.
+
+        NOTE: HERE THE QUADRATIC FORM MUST BE DEFINED OVER QQ!
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a list of prime numbers
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, 3, 3]))
+            sage: QS.hasse_primes_of_QQ()
+            [2, 3]
+
+        """
+        ## Check that we're over QQ
+        if self.base_field() != QQ:
+            raise TypeError, "This method only applies to quadratic forms over global fields, and only QQ for now."
+
+        ## List all primes dividing the discriminant (and also add p = 2)
+        possible_prime_list = [p  for p in prime_divisors(2 * self.normalized_space().det_Gram())]
+
+        ## Check which primes have some exceptional behavior
+        prime_list = []
+        d = self.determinant()
+        for p in possible_prime_list:
+            if (self.hasse_invariant(p) == -1):
+                prime_list.append(p)
+
+        ## Return the list of primes
+        return prime_list
+
+
+
+
+
+
+    def local_characteristic_primes_of_QQ(self):
+        """
+        Give a list of the finitely many characteristic (bad) primes
+        of a quadratic space defined over QQ where either the
+        discriminant squareclass is not unit, or the Hasse invariant
+        is -1.
+
+        NOTE: HERE THE QUADRATIC FORM MUST BE DEFINED OVER QQ!
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a list of prime numbers
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -2, 3]))
+            sage: QS.local_characteristic_primes_of_QQ()
+            [2, 3]
+
+        """
+        ## Check that we're over QQ
+        if self.base_field() != QQ:
+            raise TypeError, "This method only applies to quadratic forms over global fields, and only QQ for now."
+
+        ## List all primes dividing the discriminant (and also add p = 2)
+        possible_prime_list = [p  for p in prime_divisors(2 * self.normalized_space().det_Gram())]
+
+        ## Check which primes have some exceptional behavior
+        prime_list = []
+        d = self.determinant()
+        for p in possible_prime_list:
+            if (self.hasse_invariant(p) == -1) or (d.valuation(p) == 1):
+                prime_list.append(p)
+
+        ## Return the list of primes
+        return prime_list
+
+
+
+
+
+    def local_characteristic_places_of_QQ(self):
+        """
+        Give a list of the finitely many characteristic (bad) places
+        (including Infinity first) of a quadratic space defined over
+        QQ where either the discriminant squareclass is not unit, or
+        the Hasse invariant is -1, or the place is archimedean.
+
+        NOTE: HERE THE QUADRATIC FORM MUST BE DEFINED OVER QQ!
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a list of places (i.e. Infinity and prime numbers) starting with Infinity
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -2, 3]))
+            sage: QS.local_characteristic_places_of_QQ()
+            [+Infinity, 2, 3]
+
+        """
+        ## Add Infinity and return the list of places
+        return [Infinity] + self.local_characteristic_primes_of_QQ()
+
+
+
+    def local_characteristic_space_list(self):
+        """
+        Give a list of local quadratic spaces at the characteristic
+        (i.e. bad) local places of the given quadratic space over QQ.
+        These local spaces will determine the global (rational) space
+        up to isomorphism by the Hasse-Minkowski Theorem.
+
+        NOTE: HERE THE QUADRATIC FORM MUST BE DEFINED OVER QQ!
+
+        (TO DO: PERHAPS CHANGE THE NAME TO BE CONSISTENT WITH
+        'local_characteristic_places_of_QQ()'?)
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a list of places (i.e. Infinity and prime numbers) starting with Infinity
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -2, 3]))
+            sage: QS.local_characteristic_space_list()
+            [Quadratic space defined by the Quadratic form in 3 variables over Real Field with 53 bits of precision with coefficients:
+            [ 1.00000000000000 0.000000000000000 0.000000000000000 ]
+            [ * -2.00000000000000 0.000000000000000 ]
+            [ * * 3.00000000000000 ]
+            , Quadratic space defined by the Quadratic form in 3 variables over 2-adic Field with capped relative precision 20 with coefficients:
+            [ 1 + O(2^20) 0 0 ]
+            [ * 2 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + 2^8 + 2^9 + 2^10 + 2^11 + 2^12 + 2^13 + 2^14 + 2^15 + 2^16 + 2^17 + 2^18 + 2^19 + 2^20 + O(2^21) 0 ]
+            [ * * 1 + 2 + O(2^20) ]
+            , Quadratic space defined by the Quadratic form in 3 variables over 3-adic Field with capped relative precision 20 with coefficients:
+            [ 1 + O(3^20) 0 0 ]
+            [ * 1 + 2*3 + 2*3^2 + 2*3^3 + 2*3^4 + 2*3^5 + 2*3^6 + 2*3^7 + 2*3^8 + 2*3^9 + 2*3^10 + 2*3^11 + 2*3^12 + 2*3^13 + 2*3^14 + 2*3^15 + 2*3^16 + 2*3^17 + 2*3^18 + 2*3^19 + O(3^20) 0 ]
+            [ * * 3 + O(3^21) ]
+            ]
+
+        """
+        ## Check that we're over QQ
+        if self.base_field() != QQ:
+            raise TypeError, "This method only applies to quadratic forms over global fields, and only QQ for now."
+
+        ## Make the list by localizing at the characteristic places
+        local_space_list = []
+        for v in self.local_characteristic_places_of_QQ():
+            local_space_list.append(self.localize_at_place(v)) 
+
+        return local_space_list
+
+
+
+    def localize_at_place(self, v):
+        """
+        Return the localization of the current quadratic space at the
+        place v.
+
+        INPUT:
+            v -- a place of the basefield (currently only the base
+            field QQ is supported, so in this case v is either a prime
+            number or Infinity).
+
+        OUTPUT:
+            a quadratic space over the localization of the base field at v.
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -2, 3]))
+            sage: QS.localize_at_place(Infinity)
+            Quadratic space defined by the Quadratic form in 3 variables over Real Field with 53 bits of precision with coefficients: 
+            [ 1.00000000000000 0.000000000000000 0.000000000000000 ]
+            [ * -2.00000000000000 0.000000000000000 ]
+            [ * * 3.00000000000000 ]
+        
+            sage: QS.localize_at_place(7)
+            Quadratic space defined by the Quadratic form in 3 variables over 7-adic Field with capped relative precision 20 with coefficients:
+            [ 1 + O(7^20) 0 0 ]
+            [ * 5 + 6*7 + 6*7^2 + 6*7^3 + 6*7^4 + 6*7^5 + 6*7^6 + 6*7^7 + 6*7^8 + 6*7^9 + 6*7^10 + 6*7^11 + 6*7^12 + 6*7^13 + 6*7^14 + 6*7^15 + 6*7^16 + 6*7^17 + 6*7^18 + 6*7^19 + O(7^20) 0 ]
+            [ * * 3 + O(7^20) ]
+
+        """
+        ## Check that we're over QQ
+        if self.base_field() != QQ:
+            raise TypeError, "This method only applies to quadratic forms over global fields, and only QQ for now."
+
+        ## Construct the local field from the place
+        if v == Infinity:
+            F = RealField()
+        elif is_prime(v):
+            F = Qp(v)
+        else:
+            raise RuntimeError, "The place " + str(v) + " you passed is not recognized."
+
+        ## Return the localized quadratic space
+        return QuadraticSpace(F, self)
+    
+
+
+    def inner_product__gram(self, x, y):
+        """
+        Compute the Gram inner product of two vectors, which is the
+        inner product <.,.> satisfying Q(x) = <x,x> for all vectors x.
+
+        Note:  This loop could be sped up by more careful coding.
+
+        """
+        G = self.gram_matrix()
+
+        ## Check that x and y are vectors of the appropriate length, and defined over the base_field.
+
+        
+        ## Compute the (Gram) inner product
+        n = self.dim()
+        tmp_sum = self.__quadratic_form.base_ring()(0)
+        for i in range(n):
+            for j in range(n):
+                tmp_sum += x[i] * G[i, j] * y[j]
+
+        ## Return the inner product
+        return tmp_sum
+
+
+
+    def inner_product__hessian(self, x, y):
+        """
+        Compute the Hessian inner product of two vectors, which is the
+        inner product <.,.> satisfying 2*Q(x) = <x,x> for all vectors x.
+
+        Note:  This loop could be sped up by more careful coding.
+
+        """
+        H = self.hessian_matrix()
+        
+        ## Check that x and y are vectors of the appropriate length, and defined over the base_field.
+
+        
+        ## Compute the (Gram) inner product
+        n = self.dim()
+        tmp_sum = self.__quadratic_form.base_ring()(0)
+        for i in range(n):
+            for j in range(n):
+                tmp_sum += x[i] * (H[i, j]) * y[j]
+
+        ## Return the inner product
+        return tmp_sum
+
+
+
+
+
+
+    def __call__(self, x):
+        """
+        Evaluate the underlying quadratic form on the given vector x.
+        See also QuadraticForm.__call__() for more details.
+
+        INPUT:
+            x -- a vector, list, ot tuple of numbers coercible to the base field
+
+        OUTPUT:
+            a number in the base field
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1, -2, 3]))
+            sage: QS.__call__([1,0,0])
+            1
+            sage: QS.__call__([0,1,0])
+            -2
+            sage: QS.__call__([1,1,1])
+            2
+
+            sage: QS.__call__([1,1,1]) == QS([1,1,1])
+            True
+            
+        """
+        return self.__quadratic_form(x)
+        
+
+
+    def __eq__(self, other):
+        """
+        Perform equality testing, which means that the base_field,
+        coefficient_field, dimension, and defining coefficients are
+        all equal.  (Note: This is much stronger than being rationally
+        equivalent!)
+
+        INPUT:
+            other -- a quadratic space
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: Q1 = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+            sage: Q2 = Q1(Matrix(ZZ, 3, 3, [1,2,3,0,2,4,0,0,3]))
+            sage: QS1 = QuadraticSpace(QQ, Q1)
+            sage: QS2 = QuadraticSpace(QQ, Q2)
+            sage: QS1 == QS1
+            True
+            sage: QS1 == QS2
+            False
+
+        """
+        ## Check that it's another quadratic space
+        if not isinstance(other, QuadraticSpace):
+            return False
+            
+        ## Check that the two defining quadratic forms are equal (which includes their base fields being equal!)
+        if (self.__quadratic_form != other.__quadratic_form):
+            return False
+
+        ## All Tests Passed -- they're equal!
+        return True
+
+
+
+    def __ne__(self, other):
+        """
+        Checks if the two quadratic spaces are not equal (see self.__eq__ for more details).
+
+        INPUT:
+            other -- a quadratic space
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: Q1 = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+            sage: Q2 = Q1(Matrix(ZZ, 3, 3, [1,2,3,0,2,4,0,0,3]))
+            sage: QS1 = QuadraticSpace(QQ, Q1)
+            sage: QS2 = QuadraticSpace(QQ, Q2)
+            sage: QS1 != QS1
+            False
+            sage: QS1 != QS2
+            True
+        """
+        return not self.__eq__(other)
+
+
+
+    def __cmp__(self, other):
+        """
+        This is the default comparison routine for <, <=, ==, >, >= if
+        no special comparison operator is defined.  These operations
+        are not defined at present, and it is not clear what anything
+        but equality would mean in this context, so we raise a
+        NotImplementedError.
+
+        INPUT:
+            other -- a quadratic space
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: Q1 = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+            sage: Q2 = Q1(Matrix(ZZ, 3, 3, [1,2,3,0,2,4,0,0,3]))
+            sage: QS1 = QuadraticSpace(QQ, Q1)
+            sage: QS2 = QuadraticSpace(QQ, Q2)
+            sage: QS1.__cmp__(QS2)
+            Traceback (most recent call last):
+            ...
+            NotImplementedError: Warning: The comparison operation just used is not presently defined.
+            sage: QS1 > QS2
+            Traceback (most recent call last):
+            ...
+            NotImplementedError: Warning: The comparison operation just used is not presently defined.
+            
+
+        """
+        raise NotImplementedError, "Warning: The comparison operation just used is not presently defined."
+
+
+
+
+    def hessian_bilinear_space(self):
+        """
+        Return the underlying Hessian bilinear space for this quadratic latice.
+        """
+        return deepcopy(self.__hessian_bilinear_space)
+
+
+
+## ------------------------------------  Field-specific Routines  -------------------------------------------
+        
+
+
+    def orthogonal_basis(self):
+        """
+        Return an orthogonal basis for the quadratic space.
+
+        TO DO:  MAKE THIS FIELD-INDEPENDENT!!!
+
+        INPUT:
+            None
+
+        OUTPUT:
+            A list of vectors
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, QuadraticForm(QQ, 3, [2, 11/3, 5,  45/11, 1,  1/12]))
+            sage: B = QS.orthogonal_basis()
+            sage: M =Matrix(QQ, 3, 3, [QS.inner_product__hessian(B[i], B[j])  for i in range(3)  for j in range(3)])
+            sage: M.is_diagonal()
+            True
+        """
+        return self.__hessian_bilinear_space.orthogonal_basis()
+
+
+
+
+    def integral_lattice(self):
+        """
+        Return a Z-valued quadratic lattice on this quadratic space (by scaling all of
+        the lattice generators to be Z-valued).
+
+        TO DO: Modify this to allow it to return I-valued forms for any ideal I over a number field.
+        
+        INPUT:
+            None
+
+        OUTPUT:
+            a quadratic lattice over ZZ
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [2,45/11,1/12]))
+            sage: QS.integral_lattice()
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 2 0 0 ]
+            [ * 45/11 0 ]
+            [ * * 1/12 ]
+            spanned by ((1, 0, 0), (0, 11, 0), (0, 0, 6)).
+            
+            sage: QS = QuadraticSpace(QQ, QuadraticForm(QQ, 3, [2, 11/3, 5,  45/11, 1,  1/12]))
+            sage: L = QS.integral_lattice(); L
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 2 11/3 5 ]
+            [ * 45/11 1 ]
+            [ * * 1/12 ]
+            spanned by ((1, 0, 0), (0, 66, 11454), (0, 0, 22908)).
+            sage: Matrix(QQ, 3, 3, [L.inner_product__hessian(L.basis()[i], L.basis()[j])  for i in range(3)  for j in range(3)]) in MatrixSpace(ZZ, 3, 3)
+            True
+        """
+        new_gen_list = []
+
+        ## Scale all vectors in an orthogonal basis to make them integer-valued
+        for v in self.orthogonal_basis():
+            d = self(v).denominator()
+            scale_factor = sqrt(d * squarefree_part(d))
+            new_gen_list.append(v * scale_factor)
+
+        return QuadraticLattice(self, new_gen_list)    ## Warning: This operation does *not* preserve the given basis!
+
+
+
+    def find_isotropic_vector(self):
+        """
+        Returns a non-zero vector v in the quadratic space with Q(v) = 0,
+        and returns False if there is no such vector.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a vector over self.base_field()
+
+        EXAMPLES:
+            sage: A = matrix(ZZ, 2, 2, [3,1,1,3])
+            sage: QS= QuadraticSpace(GF(3), A)
+            sage: v = QS.find_isotropic_vector()
+            sage: QS(v) == 0
+            True
+            sage: v.parent()
+            Vector space of dimension 2 over Finite Field of size 3
+
+        """
+        ## Use the symmetric bilinear space when the characteristic is not 2
+        if self.base_field().characteristic() != 2:
+            return self.__hessian_bilinear_space.find_isotropic_vector()
+
+
+
+        ## When the characteristic is 2, do this......  FIX THIS!!!
+        ## --------------------------------------------------------
+        d = self.dim()
+        F = self.base_field()
+        char_p = F.characteristic()
+
+
+        ## Deal with dimension <=1 forms -- (very easy)
+        if (d == 0) or (d == 1):
+            return False
+
+        ## Deal with anistropic forms -- (uses invariants, if they exist!)
+        if self.is_anisotropic():
+            return False
+
+
+        ## NOT IMPLEMENTED: Check that the space is non-degenerate
+        if self.is_degenerate():
+            raise NotImplementedError, "For now we need a non-degenerate quadratic space."
+
+
+
+        ## Deal with isotropic forms (so we have isotropic vectors)!
+        PR = PolynomialRing(F, 'y')
+        y = PR.gen()
+
+        while True:                                                  ## This must terminate since n >= 3
+            ## Choose a random (non-degenerate) linear polynomial vector, giving a general line in our space
+            v1 = vector([PR(F.random_element())  for i in range(d)])
+            while v1 == v1.parent().zero_vector():
+                v1 = vector([PR(F.random_element())  for i in range(d)])
+            v2 = vector([PR(F.random_element())  for i in range(d)])
+            while v2 == v1.parent().zero_vector():
+                v2 = vector([PR(F.random_element())  for i in range(d)])
+            v = v1 + y * v2
+            #print "v = ", v
+
+            ## Find its value (as a quadratic polynomial in y)  --  this could be sped up by not re-copying the matrix G every time, and evaluatng instead!
+            G = self.hessian_matrix()
+            G1 = matrix(PR, G)
+            m1 = (v * G1 * v.transpose())[0]         
+            #print "G = ", G
+            #print "G1 = ", G1
+            #print "m1 = ", m1
+
+            ## Deal with every vector being isotropic
+            if F == 0:
+                return vector(F, v1)
+
+            ## Otherwise find roots, and return an isotropic vector
+            m1_roots = m1.roots()
+            if len(m1_roots) != 0:
+                a = m1_roots[0][0]  ## Take the first root over F_p
+                new_v = v1 + a*v2   
+                #print "m1_roots = ", m1_roots
+                #print "new_v = ", new_v
+                if new_v != new_v.parent().zero_vector():
+                    return vector(F, new_v)
+
+
+
+    def orthogonal_subspace_to_vector(self, subspace):
+        """
+        Find the subspace of the quadratic space orthogonal to the given vector.
+        """
+        ## Check if we have a vector
+        if is_Vector(v):
+            return self.__hessian_bilinear_space.orthogonal_subspace_to_vector(v)
+
+
+
+
+
+    def find_basis_of_maximal_isotropic_subspace(self):
+        """
+        Find a basis of a maximal isotropic subspace of the quadratic space, as a matrix of row vectors.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a matrix of row vectors
+
+        EXAMPLES:
+            sage: from sage.quadratic_forms.maximal_extras import find_basis_of_maximal_isotropic_subspace
+
+            sage: MM = matrix(ZZ, 6, 6, [0, 0, 1, 2, 2, 2, 0, 0, 0, 1, 0, 1, 1, 0, 2, 2, 3, 0, 2, 1, 2, 3, 1, 2, 2, 0, 3, 1, 1, 0, 2, 1, 0, 2, 0, 1])
+            sage: QS = QuadraticSpace(GF(5), MM)
+            sage: QS.find_basis_of_maximal_isotropic_subspace()  ## random
+            [2 0 0 3 0 2]
+            [0 3 0 1 3 1]
+            [0 0 2 2 2 3]
+
+        """
+        ## Use the symmetric bilinear space when the characteristic is not 2
+        if self.base_field().characteristic() != 2:
+            return self.__hessian_bilinear_space.find_basis_of_maximal_isotropic_subspace()
+
+
+
+        ## When the characteristic is 2, do this......  FIX THIS!!!
+        ## --------------------------------------------------------
+        G = self.hessian_matrix()
+        F = self.base_field()
+        n = G.nrows()
+        p = G.parent().base_ring().characteristic()
+
+        ## Make the transformation matrix (of rows!!!)
+        T = matrix(F, 0, n, [])
+
+        ## Find one isotropic vector
+        v = self.find_isotropic_vector_at_prime()
+
+        ## Check if we're done.
+        if v == False:
+            return T
+
+        ## Find a basis for v^\perp
+        K = self.orthogonal_subspace_to_vector(v).basis_matrix()    ## Note: Row vectors here, in reduced row echelon form!
+
+        ## DIAGNOSTIC
+        verbose("v = " + str(v))
+        verbose("K = " + str(K))
+
+        ## Find the first non-zero entry of v, to use to decide which kernel basis vector to replace with v.
+        for i in range(n):
+            if v[i] != 0:
+                v_nz_index = i
+                break
+        ## Find the associated basis vector (using heavily the row echelon form of the output)
+        for i in range(K.nrows()):
+            if K[i, v_nz_index] != 0:
+                K_nz_index = i
+                break
+
+        ## DIAGNOSIC
+        verbose("v_nz_index = " + str(v_nz_index))
+        verbose("K_nz_index = " + str(K_nz_index))
+
+        ## Extract the kernel basis excluding v
+        K1 = K.matrix_from_rows([j for j in range(K.nrows())  if j != K_nz_index])
+        G1 = K1 * G * K1.transpose()
+
+        ## Perform the recursion
+        Q1 = QuadraticSpace(self.base_field(), G1)
+        T1 = Q1.find_basis_of_maximal_isotropic_subspace
+        T_last = T1 * K1
+        T_new = (T_last.transpose().augment(v.transpose())).transpose()   ## Augment T_last by adding the row v
+
+        ## DIAGNOSTIC
+        verbose("Found T_new of dimension " + str(T_new.nrows()))
+
+        return T_new
+
+
+
+
+    def maximal_quadratic_lattice(self):
+        """
+        Find a quadratic lattice equivalent to a maximal lattice in the given quadratic space.  
+
+        TO DO: Add support for (a)-maximal lattices too.
+
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a quadratic lattice over ZZ
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, QuadraticForm(QQ, 3, [2, 11/3, 5,  45/11, 1,  1/12]))
+            
+
+        """
+        n = self.dim()
+        
+        ## Check that we're working over QQ
+        if self.base_field() != QQ:
+            raise NotImplementedError, "Presently only the base field of QQ is supported."
+
+
+        #print " self.__hessian_bilinear_space() = " + str( self.__hessian_bilinear_space)
+
+
+        ## Find a maximal lattice for the associated Hessian bilinear space
+        Hessian_maximal_lattice = self.__hessian_bilinear_space.maximal_bilinear_lattice()
+
+
+        ## Find the even sublattice, and look for a maximal even superlattice of it
+        Even_sublattice = Hessian_maximal_lattice.even_sublattice()
+        Pn_Z2 = mrange(4*[2])[1:]   ## This runs over all vertors of P^n(GF(2))
+        ## Loop through all index 2 superlattices, looking for an even one
+        for v in Pn_Z2:              
+            v1_list = (Matrix(self.base_field(), ZZ(1)/ZZ(2) * v) * Even_sublattice.basis_matrix_of_rows()).rows()
+            L = Even_sublattice.sum_with(v1_list)
+            if L.is_even():
+                return QuadraticLattice(self, L.basis())
+
+        ## If there are no even maximal superlattices, then return the even lattice!
+        return QuadraticLattice(self, Even_sublattice.basis())
+
+
+
+
+
+        ## =============================================================================
+        ## =============================================================================
+        ## =============================================================================
+        ##
+        ## Nothing to see here but old code... to be deleted!
+        ##
+        ## =============================================================================
+        ## =============================================================================
+        ## =============================================================================
+
+        
+
+        ## Find a maximal Z-valued quadratic lattice:
+        ## ------------------------------------------
+        Gram_new, T_new = even_neighbor_of_bilinear_gram_matrix(Gram_of_max_lat)
+
+        ## Return a maximal form
+        #return L
+
+        return False
+
+        ## =============================================================================
+        ## =============================================================================
+        ## =============================================================================
+
+
+        ## Find an integral lattice in our quadratic space
+        L = self.integral_lattice()
+
+        ## DIAGNOTSIC
+        verbose("\n L = " + str(L))
+        verbose("\n ====================== ")
+
+        ## Enlarge the integral quadratic lattice so its discriminant module L^#/L is a product of quadratic spaces
+        H = L.Hessian_matrix()
+        max_ed = H.elementary_divisors()[-1]
+        while not is_squarefree(max_ed):    ## Check if the largest elementary divisor is not squarefree
+
+            ## Enlarge the lattice with the scaled dual lattice
+            big_sq_factor = sqrt(max_ed * squarefree_part(max_ed))  ## This is the amount we scale the dual lattice by, doing all primes at once!
+            L = L.sum_with(L.dual_lattice().apply_linear_transformation_on_right(big_sq_factor))
+
+            ## DIAGNOSTIC
+            verbose("\n big_sq_factor = " + str(big_sq_factor))
+            verbose("\n L = " + str(L))
+            verbose("\n ====================== ")
+
+            ## Prepare to check if we're done
+            H = L.Hessian_matrix()
+            max_ed = H.elementary_divisors()[-1]
+
+
+
+        ## Find a maximal Z-valued Hessian bilinear lattice:
+        ## -------------------------------------------------
+        L_dual = L.dual_lattice()
+        A = Matrix(ZZ, L_dual.Hessian_matrix(rational_matrix=True).inverse())     ## This matrix describes L in the given basis of L^#
+        D, U, V = A.smith_form()
+        iso_eligible_primes = prime_divisors(D[-2,-2])        ## The list of primes which have at most a 2-dim'l subspace in L^#/L
+        L1_dual = L_dual.apply_linear_transformation_on_right(U)        ## This is the 
+
+        ## DIAGNOSTIC
+        verbose("\n \n\nStart looking for a maximal Z-valued Hessian bilinear lattice.")
+        verbose("\n A = " + str(A))
+        verbose("\n D = " + str(D))
+        verbose("\n U = " + str(U))
+        verbose("\n V = " + str(V))
+        verbose("\n iso_eligible_primes = " + str(iso_eligible_primes))
+        verbose("\n L_dual = " + str(L_dual))
+        verbose("\n L1_dual = " + str(L1_dual))
+        verbose("\n ====================================== ")
+        
+        ## Loop through all primes to find a maximal isotropic space for each.
+        T_huge = matrix(ZZ,n,n,1)    ## This will hold the final list of generators for the isotropic submodule (of L^#)
+        for p in iso_eligible_primes:
+
+            ## Compute the dimension d_p of L^#/L at p
+            d_p = n
+            for i in range(n):
+                if D[i,i] % p == 0:
+                    d_p = i         ## Dim of L#/L
+                    break
+
+            ## Create the Gram matrix for the smaller subspace 
+            small_Hessian_gram = L1_dual.Hessian_matrix(rational_matrix=True)[:d_p, :d_p]
+
+            ## Create the quadratic lattice in the basis
+            small_QS = QuadraticSpace(GF(p), p * small_Hessian_gram)  ## This mult-by-p makes the gram matrix p-integral
+            Tp = small_QS.find_basis_of_maximal_isotropic_subspace()
+
+            ## DIAGNOSTIC
+            verbose("\n p = " + str(p)) 
+            verbose("\n d_p = " + str(d_p))
+            verbose("\n small_Hessian_gram = " + str(small_Hessian_gram))
+            verbose("\n small_QS = " + str(small_QS))
+            verbose("\n T_p = " + str(Tp))
+            verbose("\n Finished finding maximal isotropic subspace at prime " + str(p))
+
+            ## Add lifts of this subspace to our matrix of generators
+            dp_cols_small = U.matrix_from_columns(d_p)    ## These columns are the basis of L^# we used to find the maximal iso subspace.
+            TZ = dp_cols_small * matrix(ZZ,Tp).transpose()  ## Add (a lift to ZZ of) these vectors to a (column) matrix of generators.
+            T_huge = T_huge.augment(TZ)
+
+
+        ## Return a basis for the maximal form.
+        verbose("\n Status -- Pre-LLL")
+        verbose("\n T_huge has " + str(T_huge.nrows()) + " rows and " + str(T_huge.ncols()) + " columns.")
+        verbose("\n " + str(type(T_huge)) + "  " + str(T_huge.parent()))
+        verbose("\n " + str(T_huge.rows()))
+
+        nr = T_huge.ncols()  ## after LLL the last rows form a basis, the first ones are 0
+        T_lll = T_huge.transpose().LLL().matrix_from_rows(range(nr-n,nr)).transpose()  
+
+        verbose("\n Status -- Post-LLL")
+        #Gram_of_max_lat = matrix(ZZ, T_lll.transpose() * B * T_lll / (max_ed* max_ed))
+
+
+
+
+        ## Find a maximal Z-valued quadratic lattice:
+        ## ------------------------------------------
+        #Gram_new, T_new = even_neighbor_of_bilinear_gram_matrix(Gram_of_max_lat)
+
+        ## Return a maximal form
+        #return L
+
+
+
+        
+
+
+    def normalized_space(self):
+        """
+        Returns a normalized (diagonal) version of this quadratic space using
+        normalized representatives for each squareclass (assuming that the base
+        field has squareclass normalization support).
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a (diagonal) quadratic space over the same basefield, equivalent to self.
+
+        EXAMPLES:
+            sage: QF = DiagonalQuadraticForm(QQ, [1, 3, 9, 1/27])
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.normalized_space()
+            Quadratic space defined by the Quadratic form in 4 variables over Rational Field with coefficients:
+            [ 1 0 0 0 ]
+            [ * 3 0 0 ]
+            [ * * 1 0 ]
+            [ * * * 3 ]
+
+        """
+        normalized_diag_list = [s.normalized_representative()  for s in self.diagonal_squareclass_list()]
+        return QuadraticSpace(self.base_field(), DiagonalQuadraticForm(self.base_field(), normalized_diag_list))
+
+
+
+
+    def is_isotropic(self):
+        """
+        Determines if the quadratic space is isotropic over its base field.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QF = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.is_isotropic()
+            False
+
+            sage: QS = QuadraticSpace(RR, QF)
+            sage: QS.is_isotropic()
+            False
+
+            sage: QS = QuadraticSpace(Qp(2), QF)
+            sage: QS.is_isotropic()
+            False
+
+            sage: QS = QuadraticSpace(Qp(3), QF)
+            sage: QS.is_isotropic()
+            True
+
+            sage: QS = QuadraticSpace(FiniteField(11), QF)
+            sage: QS.is_isotropic()
+            True
+            
+        """
+        return self.anisotropic_dim() != self.dim()
+
+
+
+    def is_anisotropic(self):
+        """
+        Determines if the quadratic space is anisotropic over its base field.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QF = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.is_anisotropic()
+            True
+
+            sage: QS = QuadraticSpace(RR, QF)
+            sage: QS.is_anisotropic()
+            True
+
+            sage: QS = QuadraticSpace(Qp(2), QF)
+            sage: QS.is_anisotropic()
+            True
+
+            sage: QS = QuadraticSpace(Qp(3), QF)
+            sage: QS.is_anisotropic()
+            False
+
+            sage: QS = QuadraticSpace(FiniteField(11), QF)
+            sage: QS.is_anisotropic()
+            False
+
+        """
+        return not self.is_isotropic()
+
+
+    def is_hyperbolic_space(self):
+        """
+        Returns if this space is a direct sum of hyperbolic planes.
+
+        TO DO: Deal with Characteristic 2 fields also!
+        """
+        char_p = self.base_field().characteristic()
+
+        ## Check that the base field does not have characteristic 2
+        if char_p == 2:
+            raise NotImplementedError, "We need to deal with fields of characteristic 2 also!"
+
+        ## Check hyperbolicness with the anisotropic dimension
+        return self.anisotropic_dim() == 0
+        
+
+    def is_degenerate(self):
+        """
+        Determines if the quadratic space is degenerate (i.e. it has
+        some non-zero vector orthogonal to the entire space).
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1,1,1]))
+            sage: QS.is_degenerate()
+            False
+
+            sage: QS = QuadraticSpace(FiniteField(9,x), DiagonalQuadraticForm(ZZ, [1,3,5,7]))
+            sage: QS.is_degenerate()
+            True
+
+            sage: QS = QuadraticSpace(RR, DiagonalQuadraticForm(ZZ, []))   ## The zero-dim'l for is non-degenerate by def'n!
+            sage: QS.is_degenerate()
+            False
+
+        """
+        return self.__hessian_bilinear_space.is_degenerate()
+
+
+    def is_nondegenerate(self):
+        """
+        Determines if the quadratic space is non-degenerate (i.e. it
+        has no non-zero vectors orthogonal to the entire space).
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1,1,1]))
+            sage: QS.is_nondegenerate()
+            True
+
+            sage: QS = QuadraticSpace(FiniteField(9,x), DiagonalQuadraticForm(ZZ, [1,3,5,7]))
+            sage: QS.is_nondegenerate()
+            False
+
+            sage: QS = QuadraticSpace(RR, DiagonalQuadraticForm(ZZ, []))   ## The zero-dim'l for is non-degenerate by def'n!
+            sage: QS.is_nondegenerate()
+            True
+        """
+        return not self.is_degenerate()
+
+
+
+
+    def represents_the_space(self, V):
+        """
+        Determine if the number or quadratic space V is represented by
+        the current quadratic space (i.e. whether self represents V).
+        Note: The representation here is allowed to be degenerate.
+
+        INPUT:
+            V -- a quadratic space
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+           sage: QS4 = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1,1,1]))
+           sage: QS1 = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1]))  
+           sage: QS4.represents_the_space(QS1)
+           Traceback (most recent call last):
+           ....
+           NotImplementedError: This function is not implemented yet!
+        
+        """
+        raise NotImplementedError, "This function is not implemented yet!"
+
+
+
+
+    def is_represented_by_the_space(self, V):
+        """
+        Determine if the number or quadratic space V is represented by
+        the current quadratic space (i.e. whether self represents V).
+        Note: The representation here is allowed to be degenerate.
+
+        INPUT:
+            V -- a quadratic space
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+           sage: QS4 = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1,1,1]))
+           sage: QS1 = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1]))  
+           sage: QS1.is_represented_by_the_space(QS4)
+           Traceback (most recent call last):
+           ....
+           NotImplementedError: This function is not implemented yet!
+
+        
+        """
+        if isinstance(V, QuadraticSpace):
+            return V.represents_the_space(self)
+        else:
+            raise TypeError, "The argument must also be a quadratic space!" 
+
+
+
+
+    def is_isomorphic_to(self, other, comparison_field=None):
+        """
+        Determine if the two quadratic spaces are rationally
+        isomorphic over comparison_field.  If no comparison field is
+        specified, then we test over the base field of the two
+        quadratic spaces (which we assume to be the same, and raise an
+        error otherwise).
+
+        TO DO: Implement anisotropic_dim() and many field-specific isomorphism tests!!
+
+        INPUT:
+            other -- a quadratic space
+            comparison_field -- an optional field to which both
+                quadratic spaces can be extended to test isomorphism.
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: Q1 = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+            sage: Q2 = Q1(Matrix(ZZ, 3, 3, [1,2,3,0,2,4,0,0,3]))
+            sage: QS1 = QuadraticSpace(QQ, Q1)
+            sage: QS2 = QuadraticSpace(QQ, Q2)
+            sage: QS1 == QS1
+            True
+            sage: QS1 == QS2
+            False
+            sage: QS1.is_isomorphic_to(QS2)
+            True
+
+        """
+        ## Sanity Check: Check that it's another quadratic space
+        if not isinstance(other, QuadraticSpace):
+            raise TypeError, "Oops!  Both spaces must be of the same type to test equality!"
+ 
+       
+        ## Check their base fields agree
+        if (self.base_field() != other.base_field()):                ## SERIOUS WARNING:  HERE WE ARE TESTING FIELD EQUALITY -- NOT FIELD ISOMORPHISM!  Be *especially* careful about precisions for inexact/real fields!
+            return False
+
+        ## Check their dimensions  agree
+        if (self.dim() != other.dim())  or (self.anisotropic_dim() != other.anisotropic_dim()):
+            return False
+
+        ## Check if their determinants lie in the same squareclass
+        if (self.determinant() != other.determinant()):
+            return False
+
+
+        ## Field-Specific Isomorphism Testing:
+        ## -----------------------------------
+        
+        ## Test for QQ:
+        if self.base_field() == RationalField():
+
+            ## Check that the Hasse invariants agree at all places where c_p = -1
+            if self.hasse_primes_of_QQ() != other.hasse_primes_of_QQ():
+                return False
+
+            ## Check that the real signatures agree also
+            return self.__quadratic_form.signature() == other.__quadratic_form.signature()
+
+
+        ## Test for Finite Fields:
+        elif isinstance(self.base_field(), FiniteField):
+            return True
+
+        ## Test for CC:
+        elif isinstance(self.base_field(), ComplexField):
+            return True
+
+        ## Test for RR:
+        elif isinstance(self.base_field(), RealField):
+            self.__quadratic_form.signature() == other.quadratic_form.signature()
+
+        ## Test for p-adic Fields:
+        elif isinstance(self.base_field(), pAdicField):
+
+            ## Test that we're over Q_p
+            p = self.base_field().prime()
+            if not is_prime(p):
+                raise RuntimeError, "Only p-adic fields Q_p with p prime are supported currently."
+
+            ## Finish the isomorphism test
+            return (self.hasse_invariant() == other.hasse_invariant())
+
+
+        ## Tests for Number Fields:
+        elif isinstance(self.base_field(), NumberField):
+            ### Over a NumberFieldLocalization, compare local invariants
+            #if isinstance(self.base_field(), NumberFieldLocalization):
+            #    return (self.hasse_invariant == other.hasse_invariant) and (self.determinant() == other.determinant())
+            #
+            ### Check their determinants are not zero
+            #if self.determinant() == 0 or other.determinant() == 0:
+            #    raise NotImplementedError, "Sorry, we don't know how to deal with singular forms yet! =("
+            raise NotImplementedError, "Isomorphism testing for has not been implemented yet for number fields."
+
+        
+        ## If we're here, then the base_field has no isomorphism test yet!
+        else:
+            raise NotImplementedError, "Isomorphism testing for has not been implemented yet for the base field " + str(self.base_field()) + "."
+
+
+
+
+########################################################################################################################################
+###################################################  Routines for Local Quadratic Spaces  ##############################################
+########################################################################################################################################
+
+
+
+
+def local_quadratic_space_anisotropic_dimension_by_invariants(p, n, d, c):
+    """
+    Computes the anisotropic dimension of the quadratic space over Q_p
+    of dimension n, Gram determinant d, and Hasse invariant c (with
+    the i<j definition).
+
+    Here we are using the direct sum formula for invariants, the fact
+    that the hyperbolic plane has d=-1, c=1, and the classification of
+    invariants of anisotropic spaces by local invariants.
+
+    INPUT:
+        p -- a prime number > 0
+        n -- an integer >=0 
+        d -- an integer (or perhaps a rational number?)
+        c -- 1 or -1
+
+    OUTPUT:
+        0, 1, 2, 3, or 4.
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.quadratic_space import local_quadratic_space_anisotropic_dimension_by_invariants
+    
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, -2, 5])  ## Anisotoropic at p=2 and p=5
+        sage: Q.anisotropic_primes()
+        [2, 5]
+        sage: Q.Gram_det()
+        -10
+        sage: Q.hasse_invariant(2)
+        -1
+        sage: Q.hasse_invariant(5)
+        -1
+        sage: Q.hasse_conductor()
+        10
+        sage: local_quadratic_space_anisotropic_dimension_by_invariants(2, 3, -10, -1)
+        3
+        sage: local_quadratic_space_anisotropic_dimension_by_invariants(3, 3, -10, 1)
+        1
+        sage: local_quadratic_space_anisotropic_dimension_by_invariants(5, 3, -10, -1)
+        3
+        sage: [local_quadratic_space_anisotropic_dimension_by_invariants(p, Q.dim(), Q.Gram_det(), Q.hasse_invariant(p))  for p in primes_first_n(20)] == [3,1,3] + 17*[1]
+        True
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, -2, 5, -10])  ## Anisotoropic at p=2 and p=5
+        sage: [local_quadratic_space_anisotropic_dimension_by_invariants(p, Q.dim(), Q.Gram_det(), Q.hasse_invariant(p))  for p in primes_first_n(20)] == [4, 0, 4] + 17*[0]
+        True
+
+        sage: local_quadratic_space_anisotropic_dimension_by_invariants(2, 9, -2, -1)
+        3
+
+        sage: local_quadratic_space_anisotropic_dimension_by_invariants(2, 4, 1, 1)
+        4
+
+    """
+    ## Handle even dim'l forms
+    if n % 2 == 0:
+        m = n/2
+        if SquareClass(Qp(p), d) != SquareClass(Qp(p), (-1)**m):   ## This characterizes the non-extremal even dim'l cases
+            return 2
+        else:
+            ## Compute the hasse invariant c_m of the hyperbolic plane of dimension 2m
+            if (p != 2) or (m % 4 <= 1):    ## m == 0 or 1 mod 4 here
+                c_m = 1
+            else:
+                c_m = -1
+
+            ## Compute the even anisotropic dimension
+            if c == c_m:    ## This characterizes the Hyperbolic plane 
+                return 0
+            else:
+                return 4
+         
+    ## Handle odd dim'l forms
+    else:
+        m = (n-3)/2
+        d_m = (-1)**m
+        ## Compute the hasse invariant c_m of the hyperbolic plane of dimension 2m
+        if (p != 2) or (m % 4 <= 1):    ## m == 0 or 1 mod 4 here
+            c_m = 1
+        else:
+            c_m = -1
+
+        ## Compute the invariants associated with the (possibly anisotropic) ternary space
+        d1 = d * d_m
+        c1 = c * c_m * hilbert_symbol(d1, d_m, p)
+
+        ## Compute the odd anisotropic dimension
+        if c1 == hilbert_symbol(-1, -d1, p):   # Check if the 3-dim'l space is isotropic
+            return 1
+        else:
+            return 3
+        
+
+
+
+
+def local_quadratic_space_core_invariants_from_invariants(p, n, d, c):
+    """
+    Returns a triple of local invariants (n', d', c') describing the
+    core (maximal anisotropic) subspace of the quadratic space over
+    Q_p with invariants (n, d, c) of dimension n, Gram determinant d,
+    and Hasse invariant c (with the i<j definition).
+
+    INPUT:
+        p -- a prime number > 0
+        n -- an integer >=0 
+        d -- an integer (or perhaps a rational number?)
+        c -- 1 or -1
+
+    OUTPUT:
+        a triple (n, d, c) as above.
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.quadratic_space import local_quadratic_space_core_invariants_from_invariants
+
+        sage: local_quadratic_space_core_invariants_from_invariants(2, 4, 1, 1)    ## This sa a 2-dim'l core subspace
+        (4, 1, 1)
+        sage: local_quadratic_space_core_invariants_from_invariants(2, 4, 1, -1)    ## This is anisotropic at p=2
+        (0, 1, 1)
+        sage: local_quadratic_space_core_invariants_from_invariants(3, 4, 1, 1)
+        (0, 1, 1)
+        sage: local_quadratic_space_core_invariants_from_invariants(5, 4, 1, -1)     ## This is anisptropic at p=5
+        (4, 1, -1)
+        
+    """
+    ## Find the dimension of a maximal anisotropic subspace
+    a = local_quadratic_space_anisotropic_dimension_by_invariants(p, n, d, c)
+    m = (n - a) / 2
+
+    ## Compute the Hilbert symbol for the hyperbolic plane of dimension 2m
+    d_m = (-1)**m
+    if (p != 2) or (m % 4 <= 1):    ## m == 0 or 1 mod 4 here                                                                                                
+        c_m = 1
+    else:
+        c_m = -1
+
+    ## Compute and return the invariants
+    d1 = d * d_m
+    c1 = c_m * c * hilbert_symbol(d_m, d1, p)
+    return (a, d1, c1)         ## TO DO:  We could add a sanity check here to be sure our invariants correspond to an anisotropic space!
+
+
+
+
+
+
+
+def local_quadratic_space_by_invariants(n, d, c):
+    """
+    Returns a (diagonal) quadratic space over Q_p of dimension n, Gram
+    determinant d, and Hasse invariant c (with the i<j definition).
+
+    INPUT:
+        n -- an integer >=0 
+        d -- a non-zero squareclass over Qp
+        c -- 1 or -1
+
+    OUTPUT:
+        a diagonal quadratic space over Q_p
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.quadratic_space import local_quadratic_space_by_invariants
+
+        sage: QS1 = local_quadratic_space_by_invariants(4, SquareClass(Qp(2), 1), 1)
+        sage: QS1.base_field().prime() == 2
+        True
+        sage: QS1.dim() == 4
+        True
+        sage: QS1.determinant() == SquareClass(Qp(2), 1)
+        True
+        sage: QS1.hasse_invariant() == 1
+        True
+
+    """
+    p = d.base_field().prime()
+
+    #print "Entering local_quadratic_space_by_invariants with variables:" 
+    #print "p = ", p
+    #print "n = ", n
+    #print "d = ", d
+    #print "c = ", c
+    #print
+
+
+
+    ## Find the invariants of the core subspace
+    n1, d1, c1 = local_quadratic_space_core_invariants_from_invariants(p, n, d.normalized_representative(), c)
+    #print "The core subspace invariants at p = " + str(p) + " are:"
+    #print "n1 = ", n1
+    #print "d1 = ", d1
+    #print "c1 = ", c1
+    #print
+
+
+    ## Construct the anisotropic subspace
+    if n1 == 1:
+        Q1 = QuadraticForm(Qp(p), 1, [d1])
+
+    elif n1 == 2:
+        if c1 == 1:
+            Q1 = QuadraticForm(Qp(p), 2, [1, 0, d1])
+        else:
+            for a in local_squareclass_representatives_list(p):
+                if hilbert_symbol(a, a*d1, p) == -1:
+                    Q1 = QuadraticForm(Qp(p), 2, [a, 0, a*d1])
+
+
+    elif n1 == 3:
+        ## Find the appropriate unit squareclass to normalize the determinant
+        u1 = d1 / p**valuation(d1, p)
+
+        ## Find a non-square unit in Z_p (with special conditions when p = 2)
+        if p != 2:
+            v = least_quadratic_nonresidue(p)
+        else:
+            for v in [3,5,7]:
+                if hilbert_symbol(-p*v*u1, -v, p) == c1:
+                    break
+
+        ## Return the anisotropic ternary space
+        if valuation(d1, p) % 2 == 1:
+            Q1 = DiagonalQuadraticForm(Qp(p), [1, -v, -p*v*u1])
+        else:
+            Q1 = DiagonalQuadraticForm(Qp(p), [-v*u1, p, -p*v])    ## This works because c is scale invariant for odd dimensions.
+
+        
+    elif n1 == 4:        
+        ## Find a non-square unit in Z_p
+        if p != 2:
+            u = least_quadratic_nonresidue(p)
+            Q1 = DiagonalQuadraticForm(Qp(p), [1, -u, p, -p*u])
+        else:
+            for u in [3, 5, 7]:
+                Q1 = DiagonalQuadraticForm(Qp(p), [1, -u, p, -p*u])
+                if Q1.hasse_invariant(2) == 1:        ## The Hasse invariant must be 1 for the 4-dim'l anisotropic form at p=2
+                    break
+    else:
+        raise RuntimeError, "There is a problem, since the anisotropic dimension must be <= 4 for Q_p."
+
+        
+    ## Append hyperbolic planes to get the correct dimension
+    m = (n - n1)/2
+    #return Q1 + HyperbolicPlane_quadratic_form(Qp(p), m)
+    Q_final = Q1 + DiagonalQuadraticForm(Qp(p), m*[1, -1])    ## This returns a diagonal form. =)
+
+
+    #print "p = ", p
+    #print "Q_final =", Q_final
+
+
+    ## Sanity Check: Test the invariants are what we asked for!
+    if Q_final.dim() != n:
+        raise RuntimeError, "The dimension " + str(Q_final.dim()) + \
+            " of the local space we constructed doesn't match the desired dimension " + str(n) + " over Q_" + str(p) + "."
+    if SquareClass(Qp(p), Q_final.Gram_det()) != SquareClass(Qp(p), d):
+        raise RuntimeError, "The determinant squareclass of " + str(Q_final.Gram_det()) + \
+            " of the local space we constructed doesn't match the desired squareclass of " + str(d) + " over Q_" + str(p) + "." \
+            + "\n" + str(Q_final)
+    if Q_final.hasse_invariant(p) != c:
+        raise RuntimeError, "The Hasse invariant " + str(Q_final.hasse_invariant(p)) + \
+            " of the local space we constructed doesn't match the desired invariant " + str(c) + " over Q_" + str(p) + "." \
+            + "\n" + str(Q_final)
+
+
+    ## Return the local quadratic space
+    return QuadraticSpace(Q_final)
+
+
+
+
+
+
+
+def local_quadratic_space_GHY_to_Standard_invariants(n, delta, w):
+    """
+    Translates a triple (n, delta, w) of GHY local invariants (see
+    pp116-7 of [GHY]) for a local quadratic space over Q_p to the
+    usual local invariants (n,d,c) (given in [Ca] on p13, p55, and
+    p403, and in [OM] on pp86-7).
+
+    INPUTS:
+        n -- integer >= 0
+        delta -- a non-zero squareclass over Qp
+        w -- 1 or -1
+
+    OUTPUTS:
+        n -- integer >= 0
+        d -- a non-zero (Gram determinant) squareclass over Qp
+        w -- 1 or -1  (the Hasse invariant)
+    
+    REFERENCES:
+        [Ca]  Cassels, "Rational Quadratic forns", Book
+        [GHY] Gan, Hanke, Yu, "On an exact mass formula of Shimura", paper
+        [OM] O'Meara "Introduction to Quadratic Forms", Book
+        (See my 2/1/2006  and 9/16/2006 notes for details)
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.quadratic_space import local_quadratic_space_GHY_to_Standard_invariants
+
+        ## Odd, w=1, p=2 -- checked
+        sage: local_quadratic_space_GHY_to_Standard_invariants(3, SquareClass(Qp(2), 1), 1)
+         (3, The squareclass represented by 1 + 2 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + 2^8 + 2^9 + 2^10 + 2^11 + 2^12 + 2^13 + 2^14 + 2^15 + 2^16 + 2^17 + 2^18 + 2^19 + O(2^20) over 2-adic Field with capped relative precision 20, 1)
+        sage: local_quadratic_space_GHY_to_Standard_invariants(3, SquareClass(Qp(2), -1), 1)
+         (3, The squareclass represented by 1 + O(2^20) over 2-adic Field with capped relative precision 20, -1)
+        sage: local_quadratic_space_GHY_to_Standard_invariants(3, SquareClass(Qp(2), 5) ,1)
+         (3, The squareclass represented by 1 + 2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + 2^8 + 2^9 + 2^10 + 2^11 + 2^12 + 2^13 + 2^14 + 2^15 + 2^16 + 2^17 + 2^18 + 2^19 + O(2^20) over 2-adic Field with capped relative precision 20, 1)
+        sage: local_quadratic_space_GHY_to_Standard_invariants(3,SquareClass(Qp(2), -5) ,1)
+         (3, The squareclass represented by 1 + 2^2 + O(2^20) over 2-adic Field with capped relative precision 20, -1)
+
+        ## Odd, w=-1, p=2 -- checked
+        sage: local_quadratic_space_GHY_to_Standard_invariants(3, SquareClass(Qp(2), 1), -1)
+         (3, The squareclass represented by 1 + 2 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + 2^8 + 2^9 + 2^10 + 2^11 + 2^12 + 2^13 + 2^14 + 2^15 + 2^16 + 2^17 + 2^18 + 2^19 + O(2^20) over 2-adic Field with capped relative precision 20, -1)
+        sage: local_quadratic_space_GHY_to_Standard_invariants(3, SquareClass(Qp(2), -1), -1)
+         (3, The squareclass represented by 1 + O(2^20) over 2-adic Field with capped relative precision 20, 1)
+        sage: local_quadratic_space_GHY_to_Standard_invariants(3, SquareClass(Qp(2), 5), -1)
+         (3, The squareclass represented by 1 + 2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 + 2^8 + 2^9 + 2^10 + 2^11 + 2^12 + 2^13 + 2^14 + 2^15 + 2^16 + 2^17 + 2^18 + 2^19 + O(2^20) over 2-adic Field with capped relative precision 20, -1)
+        sage: local_quadratic_space_GHY_to_Standard_invariants(3, SquareClass(Qp(2), -5), -1)
+         (3, The squareclass represented by 1 + 2^2 + O(2^20) over 2-adic Field with capped relative precision 20, 1)
+
+
+
+    """
+    p = delta.base_field().prime()
+
+
+    ## Sanity checks
+    if not( n in ZZ  and n>=1  and  w in ZZ and abs(w) == 1  and  isinstance(delta, SquareClass)  and delta.is_nonzero()  and is_prime(p)):
+        raise TypeError, "Oops!  There is a problem with your input data (n, delta, w, p) = (" \
+            + str(n) + ", " + str(delta) + ", " + str(w) + ", " + str(p) + ")!"
+
+
+    ## Compute the new invariants:
+    ## ---------------------------
+    if is_even(n):
+
+        ## Case 1: V_(d,1) = H^r  OR  Case 2: V_(d,-1) = H^(r-2) + D  --  delta = square
+        if delta.is_unit_squares():
+            r = int(n/2)
+            d = SquareClass(Qp(p), (-1)**r)
+            c = w * (hilbert_symbol(-1, -1, p)**(floor(r/2)))
+
+            ## Return the results
+            return int(n), d, c
+
+        ## Case 2: V = H^(r-1) + 2-dim'l space
+        else:
+            r = int(n/2)
+            d = delta * (-1)**r
+            c = w * hilbert_symbol(-1, -1, p)**floor((r-1)/2) * (delta * (-1)).hilbert_symbol(SquareClass(Qp(p), (-1)**(r-1)))
+
+            ## Return the results
+            return int(n), d, c
+
+    else:
+        ## Case 3: V = H^r + delta * x^2
+        if (w == 1):
+            r = int((n-1)/2)
+            d = delta * (-1)**r
+            c = delta.hilbert_symbol(SquareClass(Qp(p), (-1)**r))  * hilbert_symbol(-1, -1, p)**floor(r/2)
+
+            ## Return the results
+            return int(n), d, c
+
+        ## Case 4: V = H^(r-1) + 3-dim'l space
+        else:
+            r = int((n-1)/2)
+            d = delta * (-1)**r
+            c1 = hilbert_symbol(-1, -1, p)**floor((r-1)/2)
+            c2 = (delta * (-1)).hilbert_symbol(SquareClass(Qp(p), (-1)**(r-1)))
+            c = -delta.hilbert_symbol(SquareClass(Qp(p), -1)) * c1 * c2 
+
+            ## Return the results
+            return int(n), d, c
+
+
+
+
+def local_quadratic_space_Standard_to_GHY_invariants(n, d, c):
+    """
+    ************************ UNTESTED ************************
+
+    Translates a triple (n,delta,w) of GHY local invariants (see
+    pp116-7 of [GHY]) for a local quadratic space over Q_p to the
+    usual local invariants (n,d,c) (given in [Ca] on p13, p55, and
+    p403, and in [OM] on pp86-7).
+
+    INPUTS:
+        p -- prime number
+        n -- integer
+        delta -- non-zero integer representing a squareclass
+        w -- 1 or -1
+
+    OUTPUTS:
+        p -- prime number
+        n -- integer
+        d -- non-zero integer representing the determinant/discriminant squareclass
+        w -- 1 or -1  (the Hasse invariant)
+    
+    REFERENCES:
+        [Ca]  Cassels, "Rational Quadratic forns", Book
+        [GHY] Gan, Hanke, Yu, "On an exact mass formula of Shimura", paper
+        [OM] O'Meara "Introduction to Quadratic Forms", Book
+        (See my 2/1/2006  and 9/16/2006 notes for details)
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.quadratic_space import local_quadratic_space_GHY_to_Standard_invariants
+        sage: from sage.quadratic_forms.quadratic_space import local_quadratic_space_Standard_to_GHY_invariants
+
+        #sage: for x in range(3): \
+        #     print x
+             
+
+        ## Check it is compatible with its inverse routine 
+        sage: for p in prime_range(22):
+        ...     for n in range(1, 9):
+        ...         for d in local_squareclass_representatives_list(p):
+        ...             for c in [1, -1]:
+        ...                 if (n, SquareClass(Qp(p), d), c) != local_quadratic_space_GHY_to_Standard_invariants(*local_quadratic_space_Standard_to_GHY_invariants(n, SquareClass(Qp(p), d), c)):
+        ...                     raise RuntimeError, "There was a problem with Std -> GHY -> Std conversion for (p, n, d, c) = (" + str(p) + ", " + str(n) + ", " + str(d) + ", " + str(c) + ")." 
+
+
+    """
+    p = d.base_field().prime()
+
+
+    ## Sanity checks
+    if not( n in ZZ  and n>=1  and  c in ZZ and abs(c) == 1  and  isinstance(d, SquareClass)  and d.is_nonzero()  and is_prime(p)):
+        raise TypeError, "Oops!  There is a problem with your input data (p, n, d, c) = (" \
+            + str(p) + ", " + str(n) + ", " + str(d) + ", " + str(c) + ")!"
+
+
+
+    ## Compute the anisotropic/core invariants
+    aniso_dim, aniso_det, aniso_hasse = local_quadratic_space_core_invariants_from_invariants(p, n, d.normalized_representative(), c)
+
+
+    ## Compute the new invariants:
+    ## ---------------------------
+    if is_even(n):
+
+        ## Case 1: V_(d,1) = H^r  OR  Case 2: V_(d,-1) = H^(r-2) + D  --  delta = square
+        if aniso_dim == 0:
+            return n, SquareClass(Qp(p), 1), 1     ## delta = 1, w = 1
+        elif aniso_dim == 4:
+            return n, SquareClass(Qp(p), 1), -1    ## delta = 1, w = -1
+        ## Case 2: V = H^(r-1) + 2-dim'l space
+        elif aniso_dim == 2:
+            return n, SquareClass(Qp(p), -aniso_det), aniso_hasse    ## See 9/28/09 Notes, page 2
+        else:
+            raise RuntimeError, "There is a problem with the anisotropic dimension " + str(aniso_dim) + " here... it must be 0, 2, or 4."
+
+    else:
+
+        ## Case 3: V = H^r + delta * x^2
+        if aniso_dim == 1:
+            return n, SquareClass(Qp(p), aniso_det), 1
+        ## Case 4: V = H^(r-1) + 3-dim'l space
+        elif aniso_dim == 3:
+            return n, SquareClass(Qp(p), -aniso_det), -1
+        else:
+            raise RuntimeError, "There is a problem with the anisotropic dimension " + str(aniso_dim) + " here... it must be 1 or 3."
+
+
+
+
+
+
+def find_locally_represented_number(n, d, c, p):
+    """
+    Finds a number represented by the quadratic form with local
+    invariants (n,d,c) at the prime p.
+
+    TO DO: FIX THE ORDER OF THIS QUADRUPLE TO MAKE IT AGREE WITH THE
+        OTHER ROUTINES ABOVE (i.e. put p first!).
+
+    INPUT:
+        n -- integer > 0
+        d -- integer (or squareclass over Q_p??)
+        c -- 1 or -1
+        p -- prime integer (or prime ideal)
+
+    OUTPUT:
+        integer (or number field element)
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.quadratic_space import find_locally_represented_number
+        sage: find_locally_represented_number(1, 1, 1, 5)
+        1
+
+        sage: find_locally_represented_number(3, 41, -1, 41)
+        3
+
+    """
+    ## Deal with d if it's a squareclass
+    if isinstance(d, SquareClass):
+        d = d.representative()
+
+
+    ## Sanity Checks
+    if not (n in ZZ  and n > 0):
+        raise TypeError, "Oops!  The dimension " + str(n) + " must be a positive integer!"
+
+    if not ((d in ZZ and d != 0) or isinstance(d, SquareClass)):
+        raise TypeError, "Oops!  The determinant is not a non-zero number/squareclass!"
+
+    if not (c in ZZ and abs(c) == 1):
+        raise TypeError, "Oops!  The Hasse invariant " + str(c) +" must be 1 or -1."
+
+    if not (p in ZZ and is_prime(p)):
+        raise TypeError, "Oops! " + str(p) + " must be a positive prime integer!"
+
+    ## Check that the local invariants are compatible for 1 and 2-dim'l forms
+    if (n == 1 and c != 1)  or  (n == 2  and c != 1 and SquareClass(Qp(p), -d).is_unit_squares()):
+        raise ValueError, "Oops! The local invariants (n,d,c,p) = " + str((n,d,c,p)) + " are incompatible! =("
+
+
+    ## Compute a represented number
+    if n == 1:
+        return d
+
+    elif n == 2:
+        for b in local_squareclass_representatives_list(p):
+            if hilbert_symbol(b, -d, p) == c:
+                return b
+
+    elif n == 3:
+        ## TO DO: Could speed this up since we only need to check at
+        ## most 2 squareclasses, and we already know 1 and p. =)
+        d1 = SquareClass(Qp(p), d)
+        for b in local_squareclass_representatives_list(p):
+            if SquareClass(Qp(p), -b) != d1:
+                return b
+
+    elif n >= 4:  ## It's either isotropic => universal or its anisotropic and known to be universal.
+        return 1
+
+
+
+
+
+
+
+def rational_quadratic_space_from_local_space_list(local_quadratic_list):
+    """
+    Find a rational quadratic space over QQ which realizes the given
+    local spaces, and has unit discriminant and Hasse invariant 1 at
+    all other places.
+
+    Note: Over a number field F we will need to specify which
+    places/primes of F are associated to which p-adic spaces.
+
+    TO DO:  ADD POSITIVE DEFINITE ABILITY!!!
+
+    INPUT:
+        local_quadratic_list -- a list of quadratic spaces defined
+            over localizations of a global field (currently only QQ is
+            supported)
+
+    OUTPUT:
+        a quadratic space over a global field (currently only QQ is supported)
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.quadratic_space import rational_quadratic_space_from_local_space_list
+        sage: Q1 = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+        sage: QS1 = QuadraticSpace(QQ, Q1)
+        sage: QS1_2 = QS1.localize_at_place(2)
+        sage: QS1_41 = QS1.localize_at_place(41)
+        sage: QS1_Infty = QS1.localize_at_place(Infinity)
+        sage: N = rational_quadratic_space_from_local_space_list([QS1_Infty, QS1_2, QS1_41])
+        sage: QS1.is_isomorphic_to(N)
+        True
+        sage: N
+        Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+        [ 249 0 0 ]
+        [ * 95203 0 ]
+        [ * * 41/23705547 ]
+        
+    """
+    ## Set some local variables
+    F = RationalField()
+    n = local_quadratic_list[0].dim()
+
+    ## Check that all spaces are of the same dimension and are localization of the given number field F
+    pass
+
+    ## Check that the determinant (square class) is realized by some global field element.
+    pass
+    
+    ## Check that no localization appears twice.
+    pass
+    
+    ## Check that the product of the Hasse invariants is 1.
+    for entry in local_quadratic_list:
+        hasse_prod = 1
+        for entry in local_quadratic_list:
+            hasse_prod *= entry.hasse_invariant()
+        if hasse_prod != 1:
+            raise ValueError, " The product of the Hasse invariants is not 1. =("
+
+    ## WARNING: Only do over Q to avoid units and the class group...
+    if F.degree() > 1:
+        raise NotImplementedError, " Sorry, we only do local-global over the rational numbers for now... =("
+
+    
+    #################################################################################
+    ## Step 1: Find a common rational determinant, and deal with 1-dimensional forms
+    #################################################################################
+
+    ## Find a common rational determinant squareclass compatible with the local ones
+    try:
+        d = weak_approx_for_squareclasses_over_QQ([entry.determinant()  for entry in local_quadratic_list])
+    except:
+        raise ValueError, " There was a problem finding a rational squareclass to represent the determinant. =("
+
+
+    #print "local_quadratic_list = \n", local_quadratic_list
+    #print "weak input = \n", [entry.determinant()  for entry in local_quadratic_list]
+    #print "d = ", d, type(d)
+
+
+    ## Deal with the case n=1
+    if n == 1:
+        return QuadraticSpace(F, [d])
+
+
+    ####################################################
+    ## Step 2: Setup lists to keep the local invariants
+    ####################################################
+
+    ## Make two lists describing the desired local behavior (for the rationals only!!!)
+    tmp_n = n
+    tmp_d = d
+
+    tmp_P_list = []
+    tmp_C_list = []
+    tmp_num_list = []
+    for entry in local_quadratic_list:    
+        ## p-adic Fields
+        if is_pAdicField(entry.base_field()):
+            tmp_P_list.append(entry.base_field().prime())
+            tmp_C_list.append(entry.hasse_invariant())
+            tmp_num_list.append(find_locally_represented_number(n, d, \
+                                         entry.hasse_invariant(), entry.base_field().prime()))
+        ## archimedean (i.e. real) fields
+        else:
+            tmp_signature = entry.defining_quadratic_form().signature()
+            tmp_P_list.append(Infinity)
+            tmp_C_list.append(tmp_signature)
+            
+            ## Determine some value represented by a real quadratic form
+            if tmp_signature == -tmp_n:
+                tmp_num_list.append(-1)
+            else:
+                tmp_num_list.append(1)
+
+
+    ## Be sure that p=2 is in there as well! =)
+    if not 2 in tmp_P_list:
+        tmp_P_list.append(2)
+        tmp_C_list.append(1)
+        tmp_num_list.append(find_locally_represented_number(n, d, 1, 2))  ## TODO: This never changes, so over Q we can replace it with a number! =)
+
+
+    #print
+    #print "tmp_n = ", tmp_n
+    #print "tmp_d = ", tmp_d
+    #print "tmp_P_list = ", tmp_P_list
+    #print "tmp_C_list = ", tmp_C_list
+    #print "tmp_num_list = ", tmp_num_list
+    #print
+
+
+    ############################################################
+    ## Step 3: Reduce to the binary case by splitting off lines
+    ############################################################
+    splitting_diagonal = []
+    #prime_flag = False
+
+    while tmp_n > 2:
+    #for i in range(n-1):
+
+        #print "n-1 = ", n-1
+        #print "i = ", i
+        #print
+
+        ## Set an additional prime_flag when i = n-1, to pass into the weak approx routine! =)
+        #if i == (n - 2):
+        #    prime_flag = True            
+
+        ## Setup for the weak approximation to find the splitting number t
+        approx_list = [] 
+        for j in range(len(tmp_P_list)):
+            p = tmp_P_list[j]
+            approx_list.append([p, local_squareclass_radius_val(p), tmp_num_list[j]])        ## This deals with Infinity as well (i.e. radius is 1)! =)
+
+        #print "approx_list = ", approx_list
+
+
+        ## Compute a rational splitting number t, and save it
+        t = weak_approx_for_numbers_over_QQ(approx_list)
+        splitting_diagonal.append(QQ(t))
+
+        ## Recompute the 2 lists, and lower the dimension:
+        ## -----------------------------------------------
+
+        ## Extend the current lists by adding new (possibly bad) primes
+        t_primes = prime_divisors(t)
+        big_P_list = tmp_P_list + [p  for p in t_primes  if not p in tmp_P_list]
+        big_C_list = tmp_C_list + [1  for p in t_primes  if not p in tmp_P_list]
+        tmp_P_list = []
+        tmp_C_list = []
+        tmp_num_list = []
+        n_new = tmp_n - 1
+        d_new = tmp_d * t     ## Note: This is a SquareClass over QQ
+
+        #print "-->  using t = ", t
+
+        ################################################################################
+
+        ## Compute the new invariant lists (for the summand)        
+        for j in range(len(big_P_list)):
+            p = big_P_list[j]
+
+            ## p-adic Fields
+            if p != Infinity:
+                c_new = big_C_list[j] * d_new.hilbert_symbol(SquareClass(QQ, t), p)  ## Find the Hasse invariant of the reduced form 
+                if is_odd(d_new.valuation(p)) or (c_new == -1) or (p == 2):
+                    tmp_P_list.append(p)
+                    tmp_C_list.append(c_new)
+
+                    #print "p = ", p
+                    #print "c_new = ", c_new
+                    
+                    tmp_num_list.append(find_locally_represented_number(n_new, d_new, c_new, p))
+
+            ## archimedean (i.e. real) fields
+            else:
+                tmp_P_list.append(Infinity)
+                tmp_signature = big_C_list[j] - sgn(t)
+                tmp_C_list.append(tmp_signature)
+                
+                ## Determine some value represented by a real quadratic form
+                if tmp_signature == -n_new:
+                    tmp_num_list.append(-1)
+                else:
+                    tmp_num_list.append(1)
+
+
+        ## Update the dimension and determinant
+        tmp_n = n_new 
+        tmp_d = d_new   ## Adjust this to be squarefree?
+
+
+        ##############################################################################
+
+
+        #print
+        #print "splitting_diagonal = ", splitting_diagonal
+        #print "tmp_n = ", tmp_n
+        #print "tmp_d = ", tmp_d
+        #print "tmp_P_list = ", tmp_P_list
+        #print "tmp_C_list = ", tmp_C_list
+        #print "tmp_num_list = ", tmp_num_list
+        #print
+
+        
+        #print "tmp_C_list = ", tmp_C_list
+        #print "big_C_list = ", big_C_list
+        #print
+
+                        
+    ######################################################################
+    ## Step 4: Construct the rational binary form, by Dirichlet's theorem
+    ######################################################################
+#    print "d-type = ", type(d)
+#    print "t-type = ", type(splitting_diagonal[0])
+
+
+    ## Make a list of local squareclasses to use
+    tmp_sq_list = [SquareClass(Qv(tmp_P_list[i]), tmp_num_list[i])  for i in range(len(tmp_P_list)) \
+                   if (tmp_C_list[i] == -1) or (tmp_d.valuation(tmp_P_list[i]) == 1) \
+                   or (tmp_P_list[i] == 2) or (tmp_P_list[i] == Infinity)]
+
+
+    #print " tmp_sq_list = ", tmp_sq_list
+
+
+    ## Find the number locally represented by the binary space, divisible by primes from only one good place.
+    a = strong_approx_for_squareclasses_by_QQ_except_at_one_prime(tmp_sq_list, return_integral_representative=True)
+
+    #print "a = ", a
+    
+    ## Add the binary form to the splitting diagonal, and return the (diagonal) rational quadratic space
+    splitting_diagonal.append(a)
+    splitting_diagonal.append( d.representative() / prod(splitting_diagonal) )
+    return QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, splitting_diagonal))
+
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/square_classes.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/square_classes.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,1128 @@
+
+
+
+
+from sage.rings.arith import is_square, is_prime, valuation, legendre_symbol, hilbert_symbol
+from sage.rings.infinity import Infinity
+from sage.rings.padics.factory import Qp
+
+
+from sage.rings.rational_field import is_RationalField, QQ
+from sage.rings.real_mpfr import RealField
+
+from sage.rings.all import is_ComplexField, is_pAdicField, is_FiniteField
+
+
+from sage.misc.functional import squarefree_part
+from sage.quadratic_forms.extras import sgn, least_quadratic_nonresidue
+
+
+
+
+
+def local_squareclass_representatives_list(v):
+    """
+    Returns a list of representatives (in ZZ) for the non-zero
+    squareclasses in the local field Q_v, where v is either a prime
+    number or Infinity.
+
+    INPUT:
+        v -- a prime number or Infinity
+
+    OUTPUT:
+        a list of integers
+
+    EXAMPLES:
+        sage: local_squareclass_representatives_list(Infinity)
+        [1, -1]
+        sage: local_squareclass_representatives_list(2)
+        [1, 3, 5, 7, 2, 6, 10, 14]
+        sage: local_squareclass_representatives_list(5)
+        [1, 2, 5, 10]
+        
+    """
+    ## Sanity Check: v is a prime or Infinity
+    if not ((v == Infinity) or is_prime(v)):
+        raise TypeError, "You must pass in either a prime number or Infinity."
+
+    ## Return the list of squareclass representatives
+    if v == Infinity:
+        return [1, -1]
+    elif v == 2:
+        return [1, 3, 5, 7, 2, 6, 10, 14]
+    else:
+        nr = least_quadratic_nonresidue(v)
+        return [1, nr, v, v*nr]
+
+
+
+def local_squareclass_radius_val(v):
+    """
+
+    Returns the valuation for the p-adic/real radius of a (non-zero)
+    squareclass in the local field Qv.  When v = Infinity, by
+    convention we return 1 (for the sign determining the squareclass).
+    When p=2 this returns 3 (since we need to look mod 8 to determine
+    the squareclass), and for other primes it is 1 (since the
+    squareclass is determined mod p).
+
+    INPUT:
+        v -- a prime number or Infinity
+
+    OUTPUT:
+        1 or 3
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.square_classes import local_squareclass_radius_val
+        sage: local_squareclass_radius_val(Infinity)
+        1
+        sage: local_squareclass_radius_val(2)
+        3
+        sage: local_squareclass_radius_val(3)
+        1
+        sage: local_squareclass_radius_val(5)
+        1
+
+    """
+    ## TO DO: Validate the input
+
+    ## Return the valuation of the modulus needed to define a squareclass over Qv
+    if v == 2:
+        return 3
+    else:
+        return 1
+
+
+
+
+def is_SquareClass(x):
+    """
+    Decides if x is a squareclass (i.e. is an instance of the SquareClass class).
+
+    INPUT:
+        None
+
+    OUTPUT:
+        boolean
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.square_classes import is_SquareClass, SquareClass
+
+        sage: S = SquareClass(QQ, 17)
+        sage: is_SquareClass(S)
+        True
+
+        sage: is_SquareClass(3)
+        False
+
+    """
+    return isinstance(x, SquareClass)
+
+
+
+
+#########################################################################
+## Defines squareclasses for QQ, Q_p, RR, or F_q.
+#########################################################################
+class SquareClass:
+    """
+    Defines a squareclass over QQ, Q_p, RR, or finite fields F_q.  Later
+    this will also include number fields or one of its localizations
+    or residue fields.
+
+    """
+
+
+    def __init__(self, F, x, normalize_element=False):
+        """
+        Creates the squareclass over the field F represented by all
+        non-zero square multiples of x of F of nonzero_elt (which could
+        be a number coercible to F or a squareclass defined by such a
+        number).
+
+
+        INTERNAL VARIABLES:
+            self._base_field -- the field defining the squareclass
+            self._representative_elt -- the element that is passed to create
+                the non-zero squareclass
+            self._normalized_flag -- the flag which determines
+                whether the current representative is normalized.
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1); S1
+            The squareclass represented by 1 over Rational Field
+            sage: S3 = SquareClass(QQ, 3); S3
+            The squareclass represented by 3 over Rational Field
+
+            sage: S3*S3
+            The squareclass represented by 9 over Rational Field
+            sage: S1 == S3*S3
+            True
+
+            sage: SquareClass(QQ, S3)
+            The squareclass represented by 3 over Rational Field
+            sage: SquareClass(Qp(5), S3)
+            The squareclass represented by 3 + O(5^20) over 5-adic Field with capped relative precision 20
+        """
+        
+
+
+        ## Allow a square_class to be passed in 
+        if is_SquareClass(x):
+            self.__init__(F, x.representative(), normalize_element)
+
+
+        ## Deal with a representative being passed in
+        else:
+
+            ## Check that F is of the allowed type (QQ, Q_p, RR, or F_q)
+            if not (is_RationalField(F) or isinstance(F, RealField) or is_pAdicField(F) or is_FiniteField(F) or is_ComplexField(F)):
+                raise TypeError, "The field F must be QQ, Q_p, RR, F_q or CC."
+
+            ## Check that the element can be coerced into the field F.
+            try:
+                F_elt = F(x)
+            except:
+                raise TypeError, "The element cannot be coerced into the defining field F."
+
+            ## Check that our local p-adic field has enough precision to determine a squareclass
+            if (is_pAdicField(F) and (F.prime() == 2) and (F_elt.precision_relative() < 3)):
+                raise RuntimeError, "The 2-adic relative precision (" + str(F_elt.precision_relative()) + ") of the number " + str(F_elt) + " is not sufficient (i.e. < 3) to determine the squareclass!"
+
+
+
+            ## Store the non-zero element defining the squareclass (which may or may not be in F, but is coercible to F).
+            self._base_field = F
+            self._representative_elt = F_elt  
+            self._normalized_flag = False
+
+            ## Normalize the squareclass, if desired.
+            if normalize_element:
+                self._representative_elt = self.normalized_representative()
+                self._normalized_flag = True
+
+                
+
+
+
+
+    def __cmp__(self, other):
+        """
+        This catches unimplemented comparison methods and raise an
+         error message.  (For us the unimplemented comparison mentods
+         should be <, <=, >, >=, which don't make sense in general for
+         squareclasses).  The methods for == and != are handled in
+         __eq__() and __ne__() separately.
+
+        INPUT:
+            other -- a squareclass.
+
+        OUTPUT:
+            error message -- since we should never be comparing squareclasses using this method.
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1)
+            sage: S1.__cmp__(S1)  
+            Traceback (most recent call last):
+            ...
+            NotImplementedError: The comparison operation you tried isn't implemented for squareclasses.  Try using == or != instead.
+
+        """
+        raise NotImplementedError, "The comparison operation you tried isn't implemented for squareclasses.  Try using == or != instead."
+
+
+    def __ne__(self, other):
+        """
+        Tests if the two square classes are not equivalent.  See
+        __eq__() for more details.
+
+        INPUT:
+            other -- a squareclass
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1) 
+            sage: S2 = SquareClass(QQ, 2)
+            sage: S4 = SquareClass(QQ, 4)  
+
+            sage: S1 != S2
+            True
+
+            sage: S1 != S2
+            True
+
+            sage: S1 != S4
+            False
+
+        """
+        return not self.__eq__(other)
+
+
+    def __eq__(self, other):
+        """
+        Tests if the two square classes are equivalent (meaning they
+        are equal as sets, so we don't care about the choice of
+        representative, only that the underlying sets are equal!).
+
+        This tests equality of square-classes by first testing that
+        the base fields are equal (meaning that they are exactly the
+        same model of the field, including precision), and then
+        checking that they give the same squareclass by the following
+        priority scheme:
+
+            1) Check if their normalized representatives are the same
+                (if this makes sense)
+
+            2) Check if the ratio of their representatives (which are
+                always given in the base field) is a square.
+
+
+        INPUT:
+            other -- a squareclass
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1) 
+            sage: S2 = SquareClass(QQ, 2)
+            sage: S4 = SquareClass(QQ, 4)  
+
+            sage: S1 == S2
+            False
+
+            sage: S1 == S2
+            False
+
+            sage: S1 == S4
+            True
+
+
+            sage: S1 = SquareClass(Qp(3), 1)
+            sage: S1 = SquareClass(Qp(3), 2)
+
+            sage: S1 == S1
+            True
+            
+            sage: S2 == S2
+            True
+
+            sage: S1 == S2
+            False
+
+            sage: S2 == S1
+            False
+            
+        """
+        ## Compare base fields
+        if self.base_field() != other.base_field():  ## TO CHECK: What about real fields of different precision, or different p-dic models?
+            return False
+
+        ## Try to compare the normalized representatives
+        if self.is_normalized() and other.is_normalized():
+            return self.representative() == other.representative()
+            
+        ## Otherwise check the ratios of their representatives (in a field-specific way).
+        else:
+            ## Deal with the zero squareclasses (on either side)
+            if other.is_zero():
+                if self.is_zero():
+                    return True
+                else:
+                    return False
+
+            ## Deal with unit squareclasses (here "other" is known to be a unit)
+            return self.is_square_element(self.representative() / other.representative())
+
+
+
+    
+
+    def __mul__(self, other, normalize_elt=False):
+        """
+        Returns the product of two squareclasses, or the product of a
+        squareclass and a number coercible to the basefield of the
+        squareclass.
+
+        INPUT:
+            other -- a squareclass
+
+        OUTPUT:
+            a squareclass over the same basefield
+
+        EXAMPLES:
+            sage: A = SquareClass(QQ, 3)
+            sage: B = SquareClass(QQ, 4)
+            sage: A*B
+            The squareclass represented by 12 over Rational Field
+                         
+        """
+        ## Check if other is a squareclass (or a number)
+        if not is_SquareClass(other):
+
+            ## Try to coerce the element other into the basefield, and multiply them.
+            try:
+                F = self.base_field()
+                b = self.base_field()(other)
+                return SquareClass(self.base_field(), self.representative() * b, normalize_elt)
+            except:
+                raise TypeError, "Oops!  The second object is neither a squareclass nor is it coercible into the basefield of the first squareclass!  It's a " + str(type(other)) + "."
+        
+        ## Check that both squareclasses have the same base fields
+        if self.base_field() != other.base_field():
+            raise TypeError, "Oops!  These two squareclasses don't have the same base field!"
+
+        ## Return their product squareclass
+        return SquareClass(self.base_field(), self.representative() * other.representative(), normalize_elt)
+        
+
+
+    def __div__(self, other, normalize_elt=False):
+        """
+        Returns the quotient of two squareclasses, or the quotient of
+        a squareclass by a number coercible into the basefield of the
+        squareclass.
+
+        INPUT:
+            other -- a non-zero squareclass or non-zero number.
+
+        OUTPUT:
+            a squareclass over the same basefield
+
+        EXAMPLES:
+            sage: A = SquareClass(QQ, 3)
+            sage: B = SquareClass(QQ, 4)
+            sage: A / B
+            The squareclass represented by 3/4 over Rational Field
+             
+        """
+        ## Check if other is a squareclass (or a number)
+        if not is_SquareClass(other):
+
+            ## Try to coerce the element other into the basefield, and divide the representatives.
+            try:
+                F = self.base_field()
+                b = self.base_field()(other)
+
+                ## Check that the second squareclass isn't zero
+                if b == 0:
+                    raise RuntimeError, "Oops!  The squareclass we're dividing by must be non-zero!"
+                
+                ## Return the new quotient squareclass
+                return SquareClass(self.base_field(), self.representative() / b, normalize_elt)
+            except:
+                raise TypeError, "Oops!  The second object is neither a squareclass nor is it coercible into the basefield of the first squareclass!  It's a " + str(type(other)) + "."
+        
+        ## Check that both squareclasses have the same base fields
+        if self.base_field() != other.base_field():
+            raise TypeError, "Oops!  These two squareclasses don't have the same base field!"
+
+        ## Check that the second squareclass isn't zero
+        if self.is_zero():
+            raise RuntimeError, "Oops!  The squareclass we're dividing by must be non-zero!"
+
+        ## Return their quotient squareclass
+        return SquareClass(self.base_field(), self.representative() / other.representative(), normalize_elt)
+        
+
+
+
+
+    def __repr__(self):
+        """
+        Returns a string describing the squareclass.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            string
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1) 
+            sage: S1.__repr__()
+            'The squareclass represented by 1 over Rational Field'
+
+        """
+        return "The squareclass represented by " + str(self.representative()) + " over " + str(self.base_field())
+    
+
+    def base_field(self):
+        """
+        Returns the basefield of the squareclass.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a field
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1) 
+            sage: S1.base_field()
+            Rational Field
+
+        """
+        return self._base_field
+
+
+
+    def representative(self):
+        """
+        Returns a representative for the given squareclass.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            an element of the basefield.
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1)
+            sage: S1.representative()  
+            1
+
+        """
+        return self._representative_elt
+
+
+
+    def is_normalized(self):
+        """
+        Determines if the current squareclass representative has been
+        certified to be a normalized representative.
+
+        INPUT:
+            None
+        
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1)
+            sage: S1.representative()
+            1
+            sage: S1.is_normalized()
+            False
+
+            sage: S1 = SquareClass(QQ, 1, True)
+            sage: S1.representative()
+            1
+            sage: S1.is_normalized()
+            True
+        """
+        return self._normalized_flag
+
+
+    def normalized_squareclass(self):
+        """
+        Returns a normalized squareclass equivalent to the current
+        one, assuming we have an explicit normalization algorithm
+        defined in self.normalized_representative().
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a squareclass over the same base field which has a representative (certified as a normalized representative).
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1)
+            sage: S1.representative()
+            1
+            sage: S1.is_normalized()
+            False
+            sage: S1_norm = S1.normalized_squareclass()
+            sage: S1_norm.representative()
+            1
+            sage: S1_norm.is_normalized()
+            True
+
+            sage: S4 = SquareClass(QQ, 4)
+            sage: S4.representative()
+            4
+            sage: S4.is_normalized()
+            False
+            sage: S4_norm = S1.normalized_squareclass()
+            sage: S4_norm.representative()
+            1
+            sage: S4_norm.is_normalized()
+            True
+            
+        """
+        return SquareClass(self.base_field(), self.representative(), normalize_element=True)
+
+
+
+    def normalized_representative(self):
+        """
+        Returns a normalized representative for the (non-zero)
+        squareclass over the special fields CC, RR, QQ, Q_p and F_p
+        when p is prime.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a number in the basefield.
+
+        EXAMPLES:
+            sage: S4 = SquareClass(QQ, 4)
+            sage: S4.representative()
+            4
+            sage: S4.is_normalized()
+            False            
+            sage: S4.normalized_representative()
+            1
+
+            sage: S = SquareClass(RR, -22/3)
+            sage: S.normalized_representative()
+            -1
+
+            sage: S = SquareClass(CC, -22/3)
+            sage: S.normalized_representative()
+            1
+
+            sage: S = SquareClass(FiniteField(5), -1)
+            sage: S.normalized_representative()
+            1
+
+            sage: S = SquareClass(FiniteField(7), -1)
+            sage: S.normalized_representative()
+            3
+
+            #sage: F49 = FiniteField(49, x)
+            #sage: S = SquareClass(F49, -1)
+            #sage: S.normalized_representative()
+            #3
+
+            sage: S = SquareClass(Qp(5), 5/3)
+            sage: S.normalized_representative()
+            10
+
+        """
+        ## Set some convenient local variables
+        F = self.base_field()
+        elt = self.representative()
+
+        ## Return a normalized element if it exists
+        if self.is_normalized():
+            return elt
+
+        ## Deal with the zero squareclass
+        if self.is_zero():
+            return elt
+
+
+        ## Compute normalized representatives for each of the supported fields
+        if is_ComplexField(F):
+            return 1
+        elif isinstance(F, RealField):
+            return sgn(elt)    ## Use the sign 1 or -1 for RR
+        elif is_RationalField(F):
+            return squarefree_part(elt)    ## Use a squarefree integer for QQ
+        elif is_pAdicField(F):
+            p = F.prime()
+            if not is_prime(p):
+                raise TypeError, "Only normaliztions af element for Q_p where p is prime is currently supported."
+
+            ## Separate out the p-part and unit parts
+            v , unit_part = elt.val_unit()
+            new_p_part = p**(v % 2)
+
+            
+            ## Normalize the unit part
+            if p != 2:                    
+                if legendre_symbol(unit_part.lift() % p, p) == 1:                  ## TO FIX: This is .lift() because of the bug in Ticket #7016
+                    new_unit_part = 1
+                else:
+                    new_unit_part = least_quadratic_nonresidue(p)
+            else:
+                new_unit_part = unit_part.lift() % 8                               ## TO FIX: This is .lift() because of the bug in Ticket #7016
+
+            ## Set the normalized representative
+            return new_p_part * new_unit_part
+
+
+        elif is_FiniteField(F):
+            p = F.order()
+            if not is_prime(p):
+                raise TypeError, "Normalized elements are only supported for finite fields with prime numbers of elements." 
+
+            ## Set the normalized elements over finite fields.  (This uses the assumption that the squareclass is non-zero)
+            if F(elt).is_square():
+                return 1
+            else:
+                return least_quadratic_nonresidue(p)
+
+
+        else:
+            raise TypeError, "Normalized squareclass representatives for the base field " + str(F) + " isn't currently supported."
+
+
+
+    def localize_at_place(self, v):
+        """
+        Return the localization of the current squareclass (which must
+        be defined over QQ) at the place v.
+
+        INPUT:
+            v -- either a prime number or Infinity
+
+        OUTPUT:
+            a squareclass over the (p-adic or real local field) QQ_v
+
+        EXAMPLES:
+            sage: S = SquareClass(QQ, -22)
+            sage: S.base_field()  
+            Rational Field 
+
+            sage: S0 = S.localize_at_place(Infinity)
+            sage: S0.base_field()
+            Real Field with 53 bits of precision
+            sage: S0
+            The squareclass represented by -22.0000000000000 over Real Field with 53 bits of precision
+
+            sage: S11 = S.localize_at_place(11)
+            sage: S11.base_field()
+            11-adic Field with capped relative precision 20            
+            sage: S11
+            The squareclass represented by 9*11 + 10*11^2 + 10*11^3 + 10*11^4 + 10*11^5 + 10*11^6 + 10*11^7 + 10*11^8 + 10*11^9 + 10*11^10 + 10*11^11 + 10*11^12 + 10*11^13 + 10*11^14 + 10*11^15 + 10*11^16 + 10*11^17 + 10*11^18 + 10*11^19 + 10*11^20 + O(11^21) over 11-adic Field with capped relative precision 20
+
+        """
+        ## Check that we're over QQ
+        if self.base_field() != QQ:
+            raise TypeError, "This method only applies to square classes over global fields, and only QQ for now."
+
+        ## Construct the local field from the place
+        if v == Infinity:
+            F = RealField()
+        elif is_prime(v):
+            F = Qp(v)
+        else:
+            raise RuntimeError, "The place " + str(v) + " you passed is not recognized."
+
+        ## Return the localized quadratic space
+        return SquareClass(F, self)
+
+
+
+
+    def valuation(self, v=None):
+        """
+        Returns the (parity of the) valuation of the squareclass
+        relative to the valuation structure on the base field (which
+        is either the integer 0 or 1).  Over the real/complex numbers
+        or over a finite field we return 0 always.  
+
+        If the squareclass is defined over QQ, then we determine the
+        valuation at the localization of the squareclass at the given
+        place v.  
+
+        INPUT:
+            None
+
+        OUTPUT:
+            an integer
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, -125/3)
+            sage: S1.localize_at_place(Infinity).valuation()
+            0
+            sage: S1.localize_at_place(2).valuation()
+            0
+            sage: S1.localize_at_place(3).valuation()
+            1
+            sage: S1.localize_at_place(5).valuation()
+            1
+            sage: S1.localize_at_place(7).valuation()
+            0
+
+
+            sage: S1 = SquareClass(QQ, -125/3)
+            sage: S1.valuation(Infinity)
+            0
+            sage: S1.valuation(2)
+            0
+            sage: S1.valuation(3)
+            1
+            sage: S1.valuation(5)
+            1
+            sage: S1.valuation(7)
+            0
+
+        """
+        ## Set some convenient local variables
+        F = self.base_field()
+
+        ## Return the valuation for a local or finite field
+        if is_pAdicField(F):
+            return self.representative().valuation() % 2
+        elif is_ComplexField(F) or isinstance(F, RealField) or is_FiniteField(F):
+            return 0
+
+        ## Return the valuation at a place of QQ
+        elif is_RationalField(F):
+            if (v == None) or ((v != Infinity) and not is_prime(v)):
+                raise TypeError, "The squareclasses over the rational numbers do not have a unique natural valuation structure!"
+            else:
+                if v == Infinity:
+                    return 0
+                else:
+                    return self.representative().valuation(v) % 2
+
+        ## Raise an error otherwise
+        else:
+            raise NotImplementedError, "There is no supported valuation structure for squareclasses over the field " + str(F) + "."
+
+
+
+
+    def valuation_free_part(self):
+        """
+        Return the squareclass given by removing the prime
+        contributing to the valuation.  This only makes sense
+        for a squareclass defined over a p-adic field.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a squareclass
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, -125/3) 
+            sage: S1_3 = S1.localize_at_place(3)
+            sage: S1_3.valuation()
+            1
+            sage: S1_3.valuation_free_part().valuation()
+            0
+            
+        """
+        if self.valuation() == 0:
+            return self
+        else:
+            return self * self.base_field().prime()
+
+
+
+
+
+    def is_zero(self):
+        """
+        Determines if this squareclass is the zero squareclass.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: S = SquareClass(QQ, -125/3)
+            sage: S.is_zero()
+            False
+
+            sage: S0 = SquareClass(QQ, 0)
+            sage: S0.is_zero()
+            True
+
+            sage: (S * S0).is_zero()
+            True
+
+        """
+        return self.representative() == self.base_field()(0)
+            
+
+    def is_nonzero(self):
+        """
+        Determines if this squareclass is not the zero squareclass.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: S = SquareClass(QQ, -125/3)
+            sage: S.is_nonzero()
+            True
+
+            sage: S0 = SquareClass(QQ, 0)
+            sage: S0.is_nonzero()
+            False
+
+            sage: (S * S0).is_nonzero()
+            False
+
+        """
+        return not self.is_zero()
+
+
+    def is_unit_squares(self):
+        """
+        Determines if this squareclass is the unit squareclass, which
+        is the squareclass of all unit squares.  This uses the method
+        self.is_square_element() to decide if the representative is a
+        square.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: S = SquareClass(QQ, -125/3)
+            sage: S.is_unit_squares()
+            False
+
+            sage: S1 = SquareClass(QQ, 1)
+            sage: S1.is_unit_squares()
+            True
+
+            sage: (S * S1).is_unit_squares()
+            False
+
+            sage: (S * S).is_unit_squares()
+            True
+
+        """
+        return self.is_nonzero() and self.is_square_element(self.representative())
+
+
+    
+    def is_square_element(self, x):
+        """
+        Decide if the element x is a square in the base field of this
+        squareclass.  Currently only the fields CC, RR, QQ, F_q, Q_p
+        are supported.
+
+        INPUT:
+            x -- a number in the basefield.
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: S = SquareClass(QQ, -125/3)
+            sage: S.is_square_element(-125/3) 
+            False
+            sage: S.is_square_element(1) 
+            True
+            sage: S.is_square_element(4) 
+            True
+            sage: S.is_square_element(0) 
+            True
+            sage: S.is_square_element(-1) 
+            False
+
+            sage: S = SquareClass(Qp(5), 2)
+            sage: S.is_square_element(1) 
+            True
+            sage: S.is_square_element(4) 
+            True
+            sage: S.is_square_element(0) 
+            True
+            sage: S.is_square_element(2) 
+            False
+            sage: S.is_square_element(6) 
+            True
+            
+
+        """
+        F = self.base_field()
+
+        ## Deal with zero
+        if F(x) == 0:
+            return True
+
+        ## Try to use the base field is_square method (if it exists)
+        try:
+            return F.is_square(x)
+        except:
+            pass
+
+        ## Deal with elements in a field-specific way:
+        ## -------------------------------------------
+        if is_ComplexField(F):
+            return True           ## All elements are squares in CC
+
+        elif isinstance(F, RealField):
+            return x>0            ## All positive elements are squares in RR
+
+        elif is_RationalField(F):
+            return is_square(x)   ## Use the is_square() method in sage/rings/arith.py
+
+        elif is_FiniteField(F):
+            if F.characteristic() == 2:
+                return True                  ## All elements are squares in characteristic 2
+            else:
+                return x**((F.order() - 1) / 2) == 1     ## Use the Legendre symbol test otherwise
+
+        elif is_pAdicField(F):
+            p = F.prime()
+            if not is_prime(p):
+                raise TypeError, "Only square-testing element for Q_p where p is prime is currently supported."
+
+            ## Separate out the p-part and unit parts
+            v, unit_part = F(x).val_unit() 
+            #v = F(x).valuation()
+            #new_p_part = QQ(p**(v % 2))
+            #unit_part = x / (p**v)
+
+            ## Check if the unit part is a square
+            if p == 2:
+                return (unit_part.lift() % 8) == 1                      ## BUG -- Ticket 7016: We should be able to just say "unit_part % 8" here!
+            else:
+                return legendre_symbol(unit_part, p) == 1
+
+        else:
+            raise NotImplementedError, "We haven't implemented square-testing for the field " + str(F) + "."
+
+
+
+    def hilbert_symbol(self, other, QQ_place=None):
+        """
+        Computes the Hilbert symbol for the squareclasses self and
+        other, which is defined by whether the number 1 is in the sum
+        of the two squareclasses.
+
+        If one base_field is QQ and the other is a local field, then
+        the Hilbert symbol is evaluated over the local field.  If both
+        fields are local, then they mest be the same.  If both are QQ,
+        then the local field is specified by QQ_place, which is either
+        a prime number or Infinity.
+
+        INPUT:            
+            other -- a squareclass
+            QQ_place -- a prime number or Infinity (required only if the base_field of both squareclasses is global)
+
+        OUTPUT:
+            1 or -1
+
+        EXAMPLES:
+            sage: S1 = SquareClass(QQ, 1)
+            sage: N1 = SquareClass(QQ, -1)
+            sage: S2 = SquareClass(QQ, 2)
+            sage: S3 = SquareClass(QQ, 3)
+            sage: S5 = SquareClass(QQ, 5)
+
+            sage: S3.hilbert_symbol(S3, 3)
+            -1
+            sage: S3.hilbert_symbol(S3.localize_at_place(3))
+            -1
+            sage: S3.localize_at_place(3).hilbert_symbol(S3)
+            -1
+            sage: S3.localize_at_place(3).hilbert_symbol(S3.localize_at_place(3))
+            -1
+
+            sage: N1.hilbert_symbol(N1, Infinity)
+            -1
+            sage: N1.hilbert_symbol(N1, 2)
+            -1
+            sage: N1.hilbert_symbol(N1, 3)
+            1
+            sage: N1.hilbert_symbol(N1, 5)
+            1
+
+
+            sage: N1.hilbert_symbol(N1, 2)
+            -1
+
+            sage: S3.hilbert_symbol(S5, Infinity)
+            1
+
+            sage: S3.hilbert_symbol(S5, 3)
+            -1
+
+            sage: R1 = SquareClass(RR, 1)
+            sage: R2 = SquareClass(RR, -1)
+            sage: R1.hilbert_symbol(R1)
+            1
+            sage: R1.hilbert_symbol(R2)
+            1
+            sage: R2.hilbert_symbol(R1)
+            1
+            sage: R2.hilbert_symbol(R2)
+            -1
+
+        """
+        ## Check that other is a squareclass
+
+        ## Check that neither squareclass is zero
+
+        ## Check that only allowed basefields have been passed
+
+
+        ## Case 1: Both basefields are QQ
+        if (self.base_field() == QQ) and (other.base_field() == QQ):
+
+            ## Case 1a: Compute the Hilbert symbol over QQ by the Strong Hasse Principle
+            if QQ_place == None:
+                raise NotImplementedError, "The computation of Hilbert symbols over QQ is not currently implemented!"
+
+            ## Case 1b: Compute the Hilbert symbol over some localization
+            elif QQ_place == Infinity:
+                if (self.representative() < 0) and (other.representative() < 0):
+                    return -1
+                else:
+                    return 1
+            elif is_prime(QQ_place):
+                return hilbert_symbol(self.representative(), other.representative(), QQ_place)
+
+        ## Case 2: Exactly one of the basefields is QQ
+        if (self.base_field() == QQ) or (other.base_field() == QQ):
+ 
+            ## Label the squareclasses so the first one S1 is over QQ
+            if (self.base_field() == QQ):
+                S1 = self    ## over QQ
+                S2 = other
+            else:
+                S1 = other   ## over QQ
+                S2 = self
+
+            ## Compute the appropriate Hilbert symbol
+            if isinstance(S2.base_field(), RealField):
+                return (S1.representative() < 0) and (S2.representative() < 0)
+            else:
+                try:
+                    p = S2.base_field().prime()
+                    S2rep = S2.representative()
+
+                    ## Check that p is prime
+                    if not is_prime(p):
+                        raise RuntimeError, "The p-adic field must be Q_p for some prime p."
+                    
+                    ## Compute the symbol
+                    return hilbert_symbol(S1.representative(), S2.representative().lift(), p)
+                except:
+                    raise RuntimeError, "There was a problem computing the Hilbert symbol..."
+
+        ## Case 3: Both fields are (the same) localfields
+        if (self.base_field() != other.base_field()):
+            raise TypeError, "The local fields must be the same to compute the Hilbert symbol."
+
+        if is_ComplexField(self.base_field()):
+            return 1
+        elif isinstance(self.base_field(), RealField):
+                if (self.representative() < 0) and (other.representative() < 0):
+                    return -1
+                else:
+                    return 1
+        else: 
+            p = self.base_field().prime()
+
+            ## Check that p is prime
+            if not is_prime(p):
+                raise RuntimeError, "The p-adic field must be Q_p for some prime p."
+
+            return hilbert_symbol(self.representative().lift(), other.representative().lift(), p)
+
+
+
+        ## Raise an error if we're here
+        raise RuntimeError, "Something is wrong..."
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/symmetric_bilinear.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/symmetric_bilinear.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,1828 @@
+
+
+
+## Required structures:
+## --------------------
+
+#from sage.quadratic_forms.symmetric_bilinear_lattice import SymmetricBilinearLattice
+
+
+from sage.quadratic_forms.square_classes import SquareClass, local_squareclass_representatives_list, local_squareclass_radius_val
+from sage.quadratic_forms.weak_approx import weak_approx_for_numbers_over_QQ, \
+                                             weak_approx_for_squareclasses_over_QQ, \
+                                             strong_approx_for_squareclasses_by_QQ_except_at_one_prime
+
+from sage.quadratic_forms.localization import Qv
+
+
+#from sage.quadratic_forms.quadratic_space import QuadraticSpace
+
+
+
+from sage.rings.arith import hilbert_symbol, legendre_symbol, valuation, is_square, is_prime, prime_divisors, is_squarefree
+from sage.rings.integer_ring import ZZ
+from sage.rings.finite_field import GF
+
+
+from sage.functions.other import floor, sqrt
+
+from sage.misc.functional import squarefree_part, is_even, is_odd
+from sage.misc.misc import prod, verbose
+
+from sage.structure.element import is_Vector
+
+
+from sage.quadratic_forms.quadratic_form import QuadraticForm, DiagonalQuadraticForm
+from sage.quadratic_forms.extras import sgn, least_quadratic_nonresidue
+from sage.matrix.all import is_Matrix, MatrixSpace
+from sage.matrix.constructor import matrix, Matrix
+#from sage.matrix.matrix import Matrix, is_Matrix
+
+from sage.rings.field import Field
+
+
+from sage.rings.rational_field import is_RationalField, QQ, RationalField
+from sage.rings.real_mpfr import RealField
+from sage.rings.all import is_ComplexField, is_pAdicField, is_FiniteField
+
+
+
+from sage.rings.infinity import Infinity
+from sage.rings.padics.factory import Qp
+
+from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
+from sage.modules.free_module_element import vector
+from sage.modules.free_module import VectorSpace
+from sage.modules.all import is_VectorSpace
+
+from copy import deepcopy
+
+
+#from sage.rings.arith import is_square, is_prime, valuation, legendre_symbol
+
+
+
+def DiagonalMatrix(base_ring, diag_list):
+    """
+    Create a diagonal matrix from a list of entries.
+
+    INPUT:
+        a list of elements coercible to base_ring
+
+    OUTPUT:
+        a matrix defined over base_ring
+
+    EXAMPLES:
+        sage: DiagonalMatrix(QQ, [1,2,3])
+        [1 0 0]
+        [0 2 0]
+        [0 0 3]
+        sage: DiagonalMatrix(QQ, [])
+        []
+    """
+    n = len(diag_list)
+    B = Matrix(base_ring, n, n)
+    for i in range(n):
+        B[i,i] = diag_list[i]
+    return B
+
+
+
+
+
+
+
+############################################################
+## Create a SymmetricBilinearSpace class which defines a  ##
+## symmetric bilinear space over a local or global field. ##
+############################################################
+
+#class SymmetricBilinearSpace(FreeQuadraticModule):
+class SymmetricBilinearSpace():
+    """
+    Defines a symmetric bilinear space, by which we mean a diagonal quadratic form over a field.
+    """
+
+
+    def __init__(self, K, coeffs=None):
+        """
+        Initializes a symmetric bilinear space over a given field from:
+            1) a symmetric matrix
+            2) a list of diagonal entries
+            3) a vectorspace
+            4) a symmetric bilinear form
+
+        If the coefficients are not elements of the base field, then
+        they must automatically coerce into it or a RuntimeError will
+        be raised.  
+
+        Valid syntax possibilities:
+            SymmetricBilinearSpace(B) -- where B is a symmetric matrix defined over a field
+            SymmetricBilinearSpace(K, B) -- where B is a symmetric matrix with coefficients coercible to the field K
+            SymmetricBilinearSpace(K, [a_1, a_2, ..., a_n]) -- where K is a field and the elements a_1, ..., a_n are coercible to elements of K
+            SymmetricBilinearSpace(V) -- where V is a vectorspace (that has its own internal inner product)
+            SymmetricBilinearSpace(K, V) -- where V is a vectorspace and its inner product matrix is coercible to the field K.
+            SymmetricBilinearSpace(SBS) -- where SBS is a symmetric bilinear space
+            SymmetricBilinearSpace(K, SBS) -- where SBS is a symmetric bilinear space and its inner product matrix is coercible to the field K.
+
+
+        INPUT:
+            K -- a local or global field, or possibly a symmetric matrix or a symmetric bilinear form defined over a field.
+            coeffs -- either a list of diagonal coefficients, a symmetric bilinear form or a symmetric matrix
+
+        OUTPUT:
+            none
+
+        INTERNAL VARIABLES:
+            self.__vector_space -- the underlying vector space, equipped with its own inner product.
+
+        EXAMPLES:
+            sage: SymmetricBilinearSpace(DiagonalMatrix(QQ, [1,2,3]))
+            Symmetric bilinear space over Rational Field of dimension 3 defined by the Gram matrix
+            [1 0 0]
+            [0 2 0]
+            [0 0 3]
+
+            sage: SymmetricBilinearSpace(Qp(5), DiagonalMatrix(QQ, [1,2,3]))
+            Symmetric bilinear space over 5-adic Field with capped relative precision 20 of dimension 3 defined by the Gram matrix
+            [1 + O(5^20)           0           0]
+            [          0 2 + O(5^20)           0]
+            [          0           0 3 + O(5^20)]
+
+            sage: SymmetricBilinearSpace(QQ, DiagonalMatrix(QQ, [1,2,3]))
+            Symmetric bilinear space over Rational Field of dimension 3 defined by the Gram matrix
+            [1 0 0]
+            [0 2 0]
+            [0 0 3]
+
+            sage: SymmetricBilinearSpace(QQ, [1,3,5])
+            Symmetric bilinear space over Rational Field of dimension 3 defined by the Gram matrix
+            [1 0 0]
+            [0 3 0]
+            [0 0 5]
+
+            sage: SymmetricBilinearSpace(VectorSpace(GF(3), 2))
+            Symmetric bilinear space over Finite Field of size 3 of dimension 2 defined by the Gram matrix
+            [1 0]
+            [0 1]
+
+            sage: SymmetricBilinearSpace(GF(9,'x'), VectorSpace(GF(3), 2))
+            Symmetric bilinear space over Finite Field in x of size 3^2 of dimension 2 defined by the Gram matrix
+            [1 0]
+            [0 1]
+
+            sage: SBS = SymmetricBilinearSpace(VectorSpace(QQ, 3))
+            sage: SymmetricBilinearSpace(SBS)
+            Symmetric bilinear space over Rational Field of dimension 3 defined by the Gram matrix
+            [1 0 0]
+            [0 1 0]
+            [0 0 1]
+            sage: SymmetricBilinearSpace(RR, SBS)
+            Symmetric bilinear space over Real Field with 53 bits of precision of dimension 3 defined by the Gram matrix
+            [ 1.00000000000000 0.000000000000000 0.000000000000000]
+            [0.000000000000000  1.00000000000000 0.000000000000000]
+            [0.000000000000000 0.000000000000000  1.00000000000000]
+            
+        """
+        ## Validate the input:
+        ## -------------------
+        if not (isinstance(K, (Field, SymmetricBilinearSpace)) or is_Matrix(K) or is_VectorSpace(K)):
+            raise TypeError, "The first argument must be either a field, a vectorspace, a symmetric matrix, or a symmetric bilinear space!"
+
+        if (coeffs != None) and not (isinstance(coeffs, (list, SymmetricBilinearSpace)) or is_Matrix(coeffs) or is_VectorSpace(coeffs)):
+            raise TypeError, "The second argument entry must be either a list of coefficients, a vectorspace, a symmetric matrix, or a symmetric bilinear space!"
+
+
+        ## INPUT #1:  Check for the syntax SymmetricBilinearSpace(K, .) where K is a field.
+        if isinstance(K, Field):
+
+            ## Sanity Check: Verify the second argument has been set.
+            if (coeffs == None):
+                raise TypeError, "Invalid Syntax -- two arguments are needed when the first argument is a field."
+
+            base_field = K
+            init_object = coeffs
+
+        ## INPUT #2  Check for the syntax SymmetricBilinearSpace(.).
+        else:
+            init_object = K
+            try:
+                base_field = init_object.base_field()
+            except:
+                base_field = init_object.base_ring()
+
+                ## Sanity Check: Verify that the abjectpassed is defined over a field
+                if not isinstance(base_field, Field):
+                    raise TypeError, "The object given is not defined over a field!"
+
+
+
+        ## Initialize the symmetric bilinear space:
+        ## ----------------------------------------
+#        FreeQuadraticModule.__init__(base_field, len(init_object), )
+
+
+
+        ## Initialize from a VectorSpace
+        if is_VectorSpace(init_object):
+            self.__vector_space = init_object.base_extend(base_field)
+
+        ## Initialize from a list of coefficients
+        elif isinstance(init_object, list):
+            self.__vector_space = VectorSpace(base_field, len(init_object), inner_product_matrix=DiagonalMatrix(base_field, init_object))
+            
+        ## Initialize from a Symmetric Matrix 
+        elif is_Matrix(init_object):
+            if not init_object.is_symmetric():
+                raise TypeError, "The given input matrix \n" + str(init_object) + "\nmust be symmetric."
+
+            self.__vector_space = VectorSpace(base_field, init_object.nrows(), inner_product_matrix=init_object)
+
+        ## Initialize from a Symmetric Bilinear Space
+        elif isinstance(init_object, SymmetricBilinearSpace):
+            self.__vector_space = VectorSpace(base_field, init_object.dim(), inner_product_matrix=init_object.gram_matrix())
+
+
+
+
+    def __repr__(self):
+        """
+        Print a string describing the symmetric bilinear space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a string
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(QQ, [1,2,-1])
+            sage: SBS.__repr__()
+            'Symmetric bilinear space over Rational Field of dimension 3 defined by the Gram matrix\n[ 1  0  0]\n[ 0  2  0]\n[ 0  0 -1]'
+            
+        """
+        return "Symmetric bilinear space over " + str(self.base_field()) + " of dimension " + str(self.dim()) \
+            + " defined by the Gram matrix\n" + str(self.__vector_space.inner_product_matrix())
+
+
+
+
+
+
+    def base_field(self):
+        """
+        Returns the base field of scalars for the quadratic space as a vectorspace.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a field
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(QQ, [1,2,-1]) 
+            sage: SBS.base_field()
+            Rational Field
+
+            sage: SBS = SymmetricBilinearSpace(Qp(3), [1,3,5])
+            sage: SBS.base_field()
+            3-adic Field with capped relative precision 20
+
+            sage: SBS = SymmetricBilinearSpace(RR, [])
+            sage: SBS.base_field()
+            Real Field with 53 bits of precision
+
+            sage: SBS = SymmetricBilinearSpace(GF(5), [5])
+            sage: SBS.base_field()
+            Finite Field of size 5
+            """
+        return self.__vector_space.base_field()
+
+
+
+    def vector_space(self):
+        """
+        Returns the defining vector space (with inner product).
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a vector space
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(GF(5), [5])
+            sage: SBS.vector_space()
+            Ambient quadratic space of dimension 1 over Finite Field of size 5
+            Inner product matrix:
+            [0]
+
+
+            #sage: SBS = SymmetricBilinearSpace(RR, [])
+            #sage: SBS.vector_space()                   ## THIS CRASHES!?!  WHY???     DEBUG THIS!!!
+
+            sage: SBS = SymmetricBilinearSpace(QQ, [])
+            sage: SBS.vector_space()                   ## BUT THIS IS FINE. =)
+            Ambient quadratic space of dimension 0 over Rational Field
+            Inner product matrix:
+            []
+                            
+        """
+        V = deepcopy(self.__vector_space)
+        return V
+
+
+    def dim(self):
+        """
+        Returns the dimension (as a vectorspace over the base field)
+        of the quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            an integer >= 0
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(QQ, [])
+            sage: SBS.dim()
+            0
+
+            sage: SBS = SymmetricBilinearSpace(RR, [])
+            sage: SBS.dim()
+            0
+
+            sage: SBS = SymmetricBilinearSpace(RR, range(6))
+            sage: SBS.dim()
+            6
+        """
+        return self.__vector_space.dimension()
+
+
+
+
+    def det(self):
+        """
+        Returns the determinant of the Gram matrix of the defining
+        quadratic form for the quadratic space (in the standard basis).
+
+        INPUT:
+            None
+            
+        OUTPUT:
+            an element of the base field
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(RR, range(6))
+            sage: SBS.det()                                  ## This Crashes -- immutable matrix error! =(  WIERD!
+
+        """
+        return self.__vector_space.inner_product_matrix().determinant()
+
+
+
+       
+    def determinant_squareclass(self):
+        """
+        Returns the squareclass of the Gram determinant of the given
+        quadratic form.  This determinant is the product of the
+        diagonal entries when the form is diagonal (which it can
+        always be arranged to be).
+
+        TO DO:  CHANGE THIS TO 'det_squareclass()', SO THE USER DOESN'T EXPECT A NUMBER!
+
+        INPUT:
+            None
+            
+        OUTPUT:
+            an element of the base field
+
+        EXAMPLES:
+            sage: QF = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+            sage: QS = QuadraticSpace(QQ, QF)
+            sage: QS.determinant()
+            The squareclass represented by 1 over Rational Field            
+
+            sage: QS.det_Hessian()
+            8
+
+            sage: QS.det_Gram()
+            1
+
+        """
+        return SquareClass(self.base_field(), self.det())
+    
+    
+
+
+
+    def gram_matrix(self):
+        """
+        Returns the gram matrix (which defines all Gram inner
+        products) for this quadratic space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a symmetric matrix defined over the base_field
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(RR, range(6))
+            sage: SBS.gram_matrix()                         ## THIS GIVES ANOTHER WIERD DEEPCOPY ERROR!?! =(
+            ...
+            TypeError: __deepcopy__() takes no arguments (1 given)
+
+            sage: SBS = SymmetricBilinearSpace(QQ, range(6))
+            sage: SBS.gram_matrix()            
+            [0 0 0 0 0 0]
+            [0 1 0 0 0 0]
+            [0 0 2 0 0 0]
+            [0 0 0 3 0 0]
+            [0 0 0 0 4 0]
+            [0 0 0 0 0 5]
+
+        """
+        return deepcopy(self.__vector_space.inner_product_matrix())
+
+
+
+    def gram_matrix_for_vectors(self, vec_list):
+        """
+        Returns the gram matrix for the given list of vectors in the
+        symmetric bilinear space.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a symmetric matrix defined over the base_field
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(RR, range(6))
+            sage: SBS.gram_matrix()                         ## THIS GIVES ANOTHER WIERD DEEPCOPY ERROR!?! =(
+
+        """
+        n = len(vec_list)
+        G = Matrix(self.base_field(), n, n)
+        for i in range(n):
+            for j in range(n):
+                G[i,j] = self.inner_product(vec_list[i], vec_list[j])
+        return G
+
+
+
+
+
+    def scale_by_factor(self, c):
+        """
+        Returns the current symmetric bilinear space with its matrix scaled by the constant factor c.
+
+        Note: Think about coercing c into a global element first.
+        Also check the creation conventions to make sure we're
+        compatibile with them.
+
+        INPUT:
+            c -- a number coercible to the base field
+
+        OUTPUT:
+            a symmetric bilinear space
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(QQ, range(1,3)); SBS
+            Symmetric bilinear space over Rational Field of dimension 2 defined by the Gram matrix
+            [1 0]
+            [0 2]
+            sage: SBS.scale_by_factor(3)
+            Symmetric bilinear space over Rational Field of dimension 2 defined by the Gram matrix
+            [3 0]
+            [0 6]
+
+        """
+        ## Validate the constant c -- TO DO!
+        try:
+            c1 = self.base_field()(c)
+        except:
+            raise RuntimeError, "The scaling factor " + str(c) + " is not coercible to the base field " + str(self.base_field()) + "." 
+
+        ## Return the scaled quadratic space
+        return SymmetricBilinearSpace(c1 * self.gram_matrix())
+
+
+
+
+
+
+
+
+
+    def localize_at_place(self, v):
+        """
+        Return the localization of the current symmetric bilinear space at the
+        place v.
+
+        INPUT:
+            v -- a place of the basefield (currently only the base
+            field QQ is supported, so in this case v is either a prime
+            number or Infinity).
+
+        OUTPUT:
+            a symmetric bilinear space over the localization of the base field at v.
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(QQ, [1, 2])
+            sage: SBS.localize_at_place(Infinity)
+            Symmetric bilinear space over Real Field with 53 bits of precision of dimension 2 defined by the Gram matrix
+            [ 1.00000000000000 0.000000000000000]
+            [0.000000000000000  2.00000000000000]
+            
+            sage: SBS.localize_at_place(7)
+            Symmetric bilinear space over 7-adic Field with capped relative precision 20 of dimension 2 defined by the Gram matrix
+            [1 + O(7^20)           0]
+            [          0 2 + O(7^20)]
+        """
+        ## Check that we're over QQ
+        if self.base_field() != QQ:
+            raise TypeError, "This method only applies to quadratic forms over global fields, and only QQ for now."
+
+        ## Construct the local field from the place
+        if v == Infinity:
+            F = RealField()
+        elif is_prime(v):
+            F = Qp(v)
+        else:
+            raise RuntimeError, "The place " + str(v) + " you passed is not recognized."
+
+        ## Return the localized symmetric bilinear space
+        return SymmetricBilinearSpace(F, self)
+    
+
+
+    def inner_product(self, x, y):
+        """
+        Compute the inner product of two vectors, considered as elements of the symmetric bilinear space.
+
+        INPUT:
+            two vectors coercible to elements of this vector space
+
+        OUTPUT:
+            an element of the base_field
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(QQ, [1, 2])
+            sage: e1 = (1,0)
+            sage: e2 = (0,1)
+
+            sage: SBS.inner_product(e1, e1)
+            1
+            sage: SBS.inner_product(e1, e2)
+            0
+            sage: SBS.inner_product(e2, e2)
+            2
+
+            sage: v1 = (1,1)
+            sage: SBS.inner_product(e1, v1)
+            1
+            sage: SBS.inner_product(v1, e1)
+            1
+            sage: SBS.inner_product(v1, e2)
+            2
+            sage: SBS.inner_product(e2, v1)
+            2
+            """
+        ## Return the inner product
+        return self(x,y)
+
+
+
+
+
+
+
+
+
+    def __call__(self, x, y):
+        """
+        Evaluate the underlying quadratic form on the given vector x.
+        See also QuadraticForm.__call__() for more details.
+
+        INPUT:
+            x -- a vector, list, ot tuple of numbers coercible to the base field
+
+        OUTPUT:
+            a number in the base field
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(GF(5), Matrix(QQ, 2, 2, [1, 2, 2, 3])); SBS
+            Symmetric bilinear space over Finite Field of size 5 of dimension 2 defined by the Gram matrix
+            [1 2]
+            [2 3]
+            sage: e1 = (1,0)
+            sage: e2 = (0,1)
+            sage: SBS(e1, e1)
+            1
+            sage: SBS(e1, e2)
+            2
+            sage: SBS(e2, e1)
+            2
+            sage: SBS(e2, e2)
+            3
+            
+        """
+        ## Check that x and y are vectors of the appropriate length, and defined over the base_field.
+        pass
+
+        ## Coerce the vectors to live in the ambient inner product space
+        V = self.__vector_space
+        x1 = V(x)
+        y1 = V(y)
+
+        ##  Evaluate the inner product by the vector space inner product method
+        return x1.inner_product(y1)
+        
+
+
+    def __eq__(self, other):
+        """
+        Perform equality testing, which means that the base_field,
+        dimension, and symmetric inner product matrix coefficients are
+        all equal.  (Note: This is much stronger than being rationally
+        equivalent!)
+
+        INPUT:
+            other -- a symmetric bilinear space
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: SBS1 = SymmetricBilinearSpace(QQ, Matrix(QQ, 2, 2, [1,3,3,-2]))
+            sage: SBS2 = SymmetricBilinearSpace(QQ, Matrix(QQ, 2, 2, [-1,3,3, -2]))
+            sage: SBS1 == SBS1
+            True
+            sage: SBS1 == SBS2
+            False
+            sage: SBS2 == SBS2
+            True
+            sage: SBS3 = SymmetricBilinearSpace(Qp(3), Matrix(QQ, 2, 2, [1,3,3,-2]))
+            sage: SBS1 == SBS3
+            False
+            sage: SBS2 == SBS3
+            False
+            sage: SBS3 == SBS3         ## THIS GIVES A WIERD DEEPCOPY ERROR ALSO! =(  FIX THIS!!!
+            True
+
+        """
+        ## Check that it's another symmetric bilinear space
+        if not isinstance(other, SymmetricBilinearSpace):
+            return False
+            
+        ## Check that the two dimensions are equal 
+        if (self.dim() != other.dim()):
+            return False
+
+        ## Check that the two base fields are equal 
+        if (self.base_field() != other.base_field()):
+            return False
+
+        ## Check that the two inner product matrices are equal
+        if (self.gram_matrix() != other.gram_matrix()):
+            return False
+
+        ## All Tests Passed -- they're equal!
+        return True
+
+
+
+    def __ne__(self, other):
+        """
+        Checks if the two symmetric bilinear spaces are not equal (see self.__eq__ for more details).
+
+        INPUT:
+            other -- a symmetric bilinear space
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+        """
+        return not self.__eq__(other)
+
+
+
+    def __cmp__(self, other):
+        """
+        This is the default comparison routine for <, <=, ==, >, >= if
+        no special comparison operator is defined.  These operations
+        are not defined at present, and it is not clear what anything
+        but equality would mean in this context, so we raise a
+        NotImplementedError.
+
+        INPUT:
+            other -- a symmetric bilinear space
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: SBS1 = SymmetricBilinearSpace(QQ, Matrix(QQ, 2, 2, [1,3,3,-2]))
+            sage: SBS2 = SymmetricBilinearSpace(QQ, Matrix(QQ, 2, 2, [5,4,4,1]))
+            sage: SBS1.__cmp__(SBS2)
+            Traceback (most recent call last):
+            ...
+            NotImplementedError: Warning: The comparison operation just used is not presently defined.
+            sage: SBS1 > SBS2
+            Traceback (most recent call last):
+            ...
+            NotImplementedError: Warning: The comparison operation just used is not presently defined.
+            
+
+        """
+        raise NotImplementedError, "Warning: The comparison operation just used is not presently defined."
+
+
+
+
+
+## ------------------------------------  Field-specific Routines  -------------------------------------------
+        
+
+
+    def orthogonal_basis(self):
+        """
+        Return an orthogonal basis for the symmetric bilinear space, or false if no such basis exists!
+
+        TO DO:  MAKE THIS FIELD-INDEPENDENT!!!
+
+        INPUT:
+            None
+
+        OUTPUT:
+            A list of vectors
+
+        EXAMPLES:
+            sage: M1 = Matrix(QQ, 3, 3, [2, 3, 4,  3, -1/2, -1,  4, -1, 17])
+            sage: M1.det()
+            -188
+            sage: SBS = SymmetricBilinearSpace(QQ, M1)
+            sage: B = SBS.orthogonal_basis()
+            sage: M2 = Matrix(QQ, 3, 3, [SBS.inner_product(B[i], B[j])  for i in range(3)  for j in range(3)])
+            sage: M2.is_diagonal()
+            True
+            sage: M2
+            [   2    0    0]
+            [   0   -5    0]
+            [   0    0 94/5]
+            sage: M2.det()
+            -188
+        """
+        n = self.dim()
+        B = self.gram_matrix()
+        MS = MatrixSpace(self.base_field(), n, n)
+        T = MS(1)
+        char = self.base_field().characteristic()
+
+        ## Clear the entries one row at a time.
+        for i in range(n):
+
+            ## Deal with rows where the diagonal entry is zero.
+            if B[i,i] == 0:
+
+                ## Look for a non-zero entry and use it to make the diagonal non-zero (if it exists)
+                for j in range(i+1, n):
+                    if B[i,j] != 0:
+
+                        ## Return False for fields of characteristic 2
+                        if char == 2:
+                            return False
+
+                        ## Otherwise make a shearing elementary row/column operation to create a non-zero diagonal entry
+                        temp = MS(1)
+                        temp[j, i] = 1
+
+                        ## Apply the transformation
+                        B = temp.transpose() * B * temp
+                        T = T * temp
+                        break
+
+            ## Create a matrix which deals with off-diagonal entries (all at once for each row)
+            temp = MS(1)
+            for j in range(i+1, n):
+                if B[i,j] != 0:
+                    temp[i,j] = -B[i,j] / B[i,i]    ## This should only occur when B[i,i] != 0, which the above step guarantees.
+
+            B = temp.transpose() * B * temp
+            T = T * temp
+
+
+        ## Return the appropriate output
+        return T.columns()
+
+
+
+
+    def integral_lattice(self):
+        """
+        Return a Z-valued lattice on this symmetric bilinear space (by scaling all of
+        the lattice generators to be Z-valued).
+
+        TO DO:
+            - Deal with bilinear spaces that *do not* have an orthogonal basis! 
+            - Modify this to allow it to return I-valued forms for any ideal I over a number field.
+
+        
+        INPUT:
+            None
+
+        OUTPUT:
+            a symmetric bilinear lattice over ZZ
+
+        EXAMPLES:
+            sage: SBS = SymmetricBilinearSpace(QQ, DiagonalMatrix(QQ, [2,45/11,1/12]))
+            sage: SBS.integral_lattice()
+            ...
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 2 0 0 ]
+            [ * 45/11 0 ]
+            [ * * 1/12 ]
+            spanned by ((1, 0, 0), (0, 11, 0), (0, 0, 6)).
+            
+            sage: SBS = QuadraticSpace(QQ, QuadraticForm(QQ, 3, [2, 11/3, 5,  45/11, 1,  1/12]))
+            sage: L = SBS.integral_lattice(); L
+            ...
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 2 11/3 5 ]
+            [ * 45/11 1 ]
+            [ * * 1/12 ]
+            spanned by ((1, 0, 0), (0, 66, 11454), (0, 0, 22908)).
+            sage: Matrix(QQ, 3, 3, [L.inner_product(L.basis()[i], L.basis()[j])  for i in range(3)  for j in range(3)]) in MatrixSpace(ZZ, 3, 3)
+            True
+        """
+        new_gen_list = []
+
+        ## Scale all vectors in an orthogonal basis to make them integer-valued
+
+        for v in self.orthogonal_basis():
+            #print "v =", v
+            d = self(v,v).denominator()
+            #print "d =", d
+            scale_factor = sqrt(d * squarefree_part(d))
+            #print "scale_factor =", scale_factor
+            new_gen_list.append(v * scale_factor)
+            #print "Done with v! =) \n"
+
+        #raise NotImplementedError, "Need to decide about and write the symmetric bilinear lattice class..."
+        return SymmetricBilinearLattice(self, new_gen_list)    ## Note: This operation does *not* preserve the given basis!
+
+        #try:
+        #except:
+        #    raise NotImplementedError, "We need to write how to deal with integrality for non-diagonalizable quadratic spaces!"
+
+
+
+    def find_basis_of_radical_subspace(self):
+        """
+        Return a basis for the radical of a this symmetric bilinear
+        space.  As a second return argument, return a basis for a
+        complementary subspace.
+        """
+        B = self.orthogonal_basis()
+        radical_basis = []
+        complementary_basis = []
+        for v in B:
+            if self.inner_product(v,v) == 0:
+                radical_basis.append(v)
+            else:
+                complementary_basis.append(v)
+
+        return radical_basis, complementary_basis
+
+
+
+
+    def find_isotropic_vector(self, known_to_exist=False):
+        """
+        Returns a non-zero vector v in the symmetric blinear space with B(v,v) = 0,
+        and returns False if there is no such vector.
+
+        If the known_to_exist flag is set, then it will continue looking until it finds an isotropic vector.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a vector over self.base_field()
+
+        EXAMPLES:
+            sage: A = matrix(ZZ, 2, 2, [3,1,1,3])
+            sage: QS = SymmetricBilinearSpace(GF(3), A)
+            sage: v = QS.find_isotropic_vector()
+            sage: QS(v) == 0
+            True
+            sage: v.parent()
+            Vector space of dimension 2 over Finite Field of size 3
+
+        """
+        ## SANITY CHECK: Check that the space is non-degenerate
+        if self.is_degenerate():
+            raise NotImplementedError, "For now we require a non-degenerate quadratic space."
+
+        d = self.dim()
+        F = self.base_field()
+        char_p = F.characteristic()
+
+
+        ## Deal with dimension <=1 forms -- (very easy)
+        if (d == 0) or (d == 1):
+            return False
+
+
+        ## DIAGNOSTIC
+        verbose("\n self.base_field() = " + str(self.base_field()))
+        verbose("\n self.gram_matrix() = " + str(self.gram_matrix()))
+
+
+        ## Import QuadraticSpace here to avoid circular dependencies!
+        from sage.quadratic_forms.quadratic_space import QuadraticSpace
+
+        ## Deal with anistropic forms -- (uses invariants of the assocatied quadratic space, if they exist!)
+        if not known_to_exist and QuadraticSpace(self.base_field(), self.gram_matrix(), matrix_type="Gram").is_anisotropic():
+            return False   
+
+
+        ## Deal with isotropic forms (so we have isotropic vectors)!
+        PR = PolynomialRing(F, 'y')
+        y = PR.gen()
+
+        while True:                                                  ## This must terminate since n >= 3
+            ## Choose a random (non-degenerate) linear polynomial vector, giving a general line in our space
+            v1 = vector([PR(F.random_element())  for i in range(d)])
+            while v1 == v1.parent().zero_vector():
+                v1 = vector([PR(F.random_element())  for i in range(d)])
+            v2 = vector([PR(F.random_element())  for i in range(d)])
+            while v2 == v1.parent().zero_vector():
+                v2 = vector([PR(F.random_element())  for i in range(d)])
+            v = v1 + y * v2
+
+            ## DIAGNOSTIC
+            verbose("\n Looking for an isotropic vector on the line defined by:")
+            verbose("\n v1 = " + str(v1))
+            verbose("\n v2 = " + str(v2))
+            verbose("\n giving v = " + str(v))
+            verbose("\n ---------------------------------- \n")
+
+            ## Find its value (as a quadratic polynomial in y)  --  this could be sped up by not re-copying the matrix G every time, and evaluating instead!
+            G = self.gram_matrix()
+            G1 = matrix(PR, G)
+            m1 = (v * G1 * v.transpose())[0]         
+
+
+            ## DIAGNOSTIC
+            verbose("G = " + str(G))
+            verbose("G1 = " + str(G1))
+            verbose("m1 = " + str(m1))
+
+
+
+            ## Deal with every vector being isotropic
+            if m1 == 0:
+                return vector(F, v1)
+
+            ## Otherwise find roots, and return an isotropic vector
+            m1_roots = m1.roots()
+            if len(m1_roots) != 0:
+                a = m1_roots[0][0]  ## Take the first root over F_p
+                new_v = v1 + a*v2   
+
+                ## DIAGNOSTIC
+                verbose("m1_roots = " + str(m1_roots))
+                verbose("new_v = " + str(new_v))
+
+                if new_v != new_v.parent().zero_vector():
+                    return vector(F, new_v)
+
+
+
+
+
+
+    def orthogonal_subspace_to_vector(self, v):
+        """
+        Find the subspace of the symmetric bilinear space orthogonal to the given vector.
+
+        INPUT:
+            v -- a vector coercible to the given vectorspace 
+
+        OUTPUT:
+            a subspace of the underlying vectorspace
+
+        EXAMPLES:
+
+        """
+        ## Check if we have a vector
+        if not is_Vector(v):
+            raise TypeError, "You need to pass in a vector coercible to this symmetric bilinear space!"
+
+        v1 = self.vector_space()(v)
+        return (self.gram_matrix() * v1.transpose()).kernel()
+
+
+
+
+    def find_basis_of_maximal_isotropic_subspace(self, return_type="list"):
+        """
+        Find a basis of a maximal isotropic subspace of the symmetric bilinear space, as a matrix of row vectors.
+
+        The return_type can be 'list', 'row_matrix', or 'column_matrix'.
+
+
+        Note:  Presently this does not require the space to be non-degenerate -- though we may want to add this in the future!
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a matrix of row vectors
+
+        EXAMPLES:
+            sage: from sage.quadratic_forms.maximal_extras import find_basis_of_maximal_isotropic_subspace
+
+            sage: MM = matrix(ZZ, 6, 6, [0, 0, 1, 2, 2, 2, 0, 0, 0, 1, 0, 1, 1, 0, 2, 2, 3, 0, 2, 1, 2, 3, 1, 2, 2, 0, 3, 1, 1, 0, 2, 1, 0, 2, 0, 1])
+            sage: QS = QuadraticSpace(GF(5), MM)
+            sage: QS.find_basis_of_maximal_isotropic_subspace()  ## random
+            [2 0 0 3 0 2]
+            [0 3 0 1 3 1]
+            [0 0 2 2 2 3]
+
+        """
+        ## Deal with degenerate bilinear spaces!
+        if self.is_degenerate():
+            radical_basis, nondeg_basis = self.find_basis_of_radical_subspace()
+            V1 = SymmetricBilinearSpace(self.base_field(), self.gram_matrix_for_vectors(nondeg_basis))
+            V1_iso_basis = V1.find_basis_of_maximal_isotropic_subspace()
+            M1_iso_columns = Matrix(self.base_field(), V1_iso_basis).transpose()    ## Make a matrix of columns (w.r.t. the standard basis for V1)
+            M_nondeg_columns = Matrix(self.base_field(), nondeg_basis).transpose()    ## Make a matrix of columns (w.r.t. the standard basis for V)
+
+            ## Find the radical and non-degenerate vectors that give a maximal isotropic subspace
+            T_new = Matrix(self.base_field(), radical_basis + (M_nondeg_columns * M1_iso_columns).columns())
+
+
+        ## Here we suppose that the space is non-degenerate...
+        ## ---------------------------------------------------
+        else:
+            G = self.gram_matrix()
+            F = self.base_field()
+            n = G.nrows()
+
+            p = G.parent().base_ring().characteristic()
+
+
+
+            ## Make the transformation matrix (of rows!!!)
+            T = matrix(F, 0, n, [])
+
+            ## Find one isotropic vector
+            v = self.find_isotropic_vector()
+
+            ## Check if we're done.
+            if v == False:
+                return T
+
+            ## Find a basis for v^\perp
+            K = self.orthogonal_subspace_to_vector(v).basis_matrix()    ## Note: Row vectors here, in reduced row echelon form!
+
+            ## DIAGNOSTIC
+            verbose("v = " + str(v))
+            verbose("K = " + str(K))
+
+            ## Find the first non-zero entry of v, to use to decide which kernel basis vector to replace with v.
+            for i in range(n):
+                if v[i] != 0:
+                    v_nz_index = i
+                    break
+            ## Find the associated basis vector (using heavily the row echelon form of the output)
+            for i in range(K.nrows()):
+                if K[i, v_nz_index] != 0:
+                    K_nz_index = i
+                    break
+
+            ## DIAGNOSIC
+            verbose("\n v_nz_index = " + str(v_nz_index))
+            verbose("\n K_nz_index = " + str(K_nz_index))
+
+            ## Extract the kernel basis excluding v
+            K1 = K.matrix_from_rows([j for j in range(K.nrows())  if j != K_nz_index])
+            G1 = K1 * G * K1.transpose()
+
+            ## Perform the recursion
+            SBS1 = SymmetricBilinearSpace(self.base_field(), G1)
+            T1 = SBS1.find_basis_of_maximal_isotropic_subspace()
+            T_last = T1 * K1
+            T_new = (T_last.transpose().augment(v.transpose())).transpose()   ## Augment T_last by adding the row v
+
+            ## DIAGNOSTIC
+            verbose("\n T_new = " + str(T_new))
+            verbose("\n Found T_new of dimension " + str(T_new.nrows()))
+            verbose("\n return_type = " + str(return_type))
+                        
+
+
+        ## Return the isotropic basis, in the desired format
+        if return_type == "row_matrix":
+            return T_new
+        elif return_type == "column_matrix":
+            return T_new.transpose()
+        elif return_type == "list":
+            return T_new.rows()
+        else:
+            raise TypeError, "The return_type must be either 'list', 'row_matrix', or 'column_matrix'."
+
+
+
+
+
+    def maximal_bilinear_lattice(self):
+        """
+        Find a symmetric bilinear lattice equivalent to a maximal lattice
+        in the given symmetric bilinear space.  
+
+        TO DO: Add support for (a)-maximal lattices too.
+
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a symmetric bilinear lattice over ZZ
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, QuadraticForm(QQ, 3, [2, 11/3, 5,  45/11, 1,  1/12]))
+
+
+            sage: SBS = SymmetricBilinearSpace(QQ, DiagonalMatrix(QQ, [1,3,9,27]))
+            sage: L = SBS.maximal_bilinear_lattice(); L
+            Symmetric Bilinear Lattice in Symmetric bilinear space over Rational Field of dimension 4 defined by the Gram matrix
+            [ 1  0  0  0]
+            [ 0  3  0  0]
+            [ 0  0  9  0]
+            [ 0  0  0 27]
+            generated over the ring Integer Ring by
+            [
+            (0, 0, 1/3, 0),
+            (1, 0, 0, 0),
+            (0, 0, 0, 1/3),
+            (0, 1, 0, 0)
+            ]
+            sage: L.gram_matrix()
+            [1 0 0 0]
+            [0 1 0 0]
+            [0 0 3 0]
+            [0 0 0 3]
+
+
+            sage: SBS = SymmetricBilinearSpace(QQ, DiagonalMatrix(QQ, [1,5,25,125]))
+            sage: L = SBS.maximal_bilinear_lattice(); L
+            Symmetric Bilinear Lattice in Symmetric bilinear space over Rational Field of dimension 4 defined by the Gram matrix
+            [  1   0   0   0]
+            [  0   5   0   0]
+            [  0   0  25   0]
+            [  0   0   0 125]
+            generated over the ring Integer Ring by
+            [
+            (0, 0, 1/5, 0),
+            (1, 0, 0, 0),
+            (0, -1/5, 0, -2/25),
+            (0, -2/5, 0, 1/25)
+            ]
+            sage: L.gram_matrix()
+            [1 0 0 0]
+            [0 1 0 0]
+            [0 0 1 0]
+            [0 0 0 1]
+
+
+            ## CHECK THESE!!! -- THESE ARE NOT CHECKED BY HAND! =(
+
+            sage: SBS = SymmetricBilinearSpace(QQ, DiagonalMatrix(QQ, [1,3,9,27]))
+            sage: L = SBS.maximal_bilinear_lattice()
+            sage: L.gram_matrix()
+
+            [1 0 0 0]
+            [0 1 0 0]
+            [0 0 3 0]
+            [0 0 0 3]
+            sage:
+            sage:
+            sage:
+            sage: SBS = SymmetricBilinearSpace(QQ, 2 * DiagonalMatrix(QQ, [1,5,25,125]))
+            sage: L = SBS.maximal_bilinear_lattice()
+            sage: L.gram_matrix()
+
+            [2 0 0 0]
+            [0 2 0 0]
+            [0 0 1 0]
+            [0 0 0 1]
+            sage:
+            sage:
+            sage: SBS = SymmetricBilinearSpace(QQ, DiagonalMatrix(QQ, [1,5,25,125]))
+            sage:
+            sage: L = SBS.maximal_bilinear_lattice()
+            sage: L.gram_matrix()
+
+            [1 0 0 0]
+            [0 1 0 0]
+            [0 0 1 0]
+            [0 0 0 1]
+
+        """
+        n = self.dim()
+        
+        ## Check that we're working over QQ
+        if self.base_field() != QQ:
+            raise NotImplementedError, "Presently only the base field of QQ is supported."
+        
+        ## Find an integral lattice in our symmetric bilinear space
+        L = self.integral_lattice()
+
+        ## DIAGNOTSIC
+        verbose("\n L = " + str(L))
+        verbose("\n ====================== ")
+
+        ## Enlarge the integral symmetric bilinear lattice so its discriminant module L^#/L is a product of quadratic spaces
+        H = L.gram_matrix()
+        max_ed = H.elementary_divisors()[-1]
+        while not is_squarefree(max_ed):    ## Check if the largest elementary divisor is not squarefree
+
+            ## Enlarge the lattice with the scaled dual lattice
+            big_sq_factor = sqrt(max_ed * squarefree_part(max_ed))  ## This is the amount we scale the dual lattice by, doing all primes at once!
+            L = L.sum_with(L.dual_lattice().apply_linear_transformation_on_right(big_sq_factor))
+
+            ## DIAGNOSTIC
+            verbose("\n big_sq_factor = " + str(big_sq_factor))
+            verbose("\n L = " + str(L))
+            verbose("\n ====================== ")
+
+            ## Prepare to check if we're done
+            H = L.gram_matrix()
+            max_ed = H.elementary_divisors()[-1]
+
+
+
+        ## Find a maximal Z-valued Hessian bilinear lattice:
+        ## -------------------------------------------------
+        L_dual = L.dual_lattice()
+        A = Matrix(ZZ, L_dual.gram_matrix(rational_matrix=True).inverse())     ## This matrix describes L in the given basis of L^#
+        D, U, V = A.smith_form()
+        iso_eligible_primes = prime_divisors(D[-2,-2])        ## The list of primes which have at most a 2-dim'l subspace in L^#/L
+        #L1_dual = L_dual.apply_linear_transformation_on_right(U)        ## This is the dual lattice in the 'nice' basis, so a basis of L is multiples
+        L1_dual = L_dual.apply_linear_transformation_on_right(U.inverse())        ## This is the dual lattice in the 'nice' basis, so a basis of L is multiples
+        
+
+        ## DIAGNOSTIC
+        verbose("\n \n\n Start looking for a maximal Z-valued Hessian bilinear lattice:")
+        verbose("\n --------------------------------------------------------------")
+        verbose("\n A = " + str(A))
+        verbose("\n D = " + str(D))
+        verbose("\n U = " + str(U))
+        verbose("\n V = " + str(V))
+        verbose("\n iso_eligible_primes = " + str(iso_eligible_primes))
+        verbose("\n L_dual = " + str(L_dual))
+        verbose("\n L1_dual = " + str(L1_dual))
+        verbose("\n ====================================== ")
+        
+        ## Loop through all primes to find a maximal isotropic space for each.
+        T_huge = deepcopy(D)    ## This will hold the final list of generators for the isotropic submodule (of L^#), together with a basis of L
+        for p in iso_eligible_primes:
+
+            ## Compute the dimension d_p of L^#/L at p -- (Since (1/p) * D gives the L1_dual basis relative to some basis of L)
+            d_p = 0
+            for i in range(n):
+                if D[i,i] % p == 0:
+                    d_p = n-i         ## Dim of L#/L
+                    break
+
+            ## Create the Gram matrix for the smaller subspace 
+            small_gram = L1_dual.gram_matrix(rational_matrix=True)[(n-d_p):, (n-d_p):]
+
+            ## Create the bilinear lattice in the basis
+            small_SBS = SymmetricBilinearSpace(GF(p), p * small_gram)  ## This mult-by-p makes the gram matrix p-integral
+            Tp = small_SBS.find_basis_of_maximal_isotropic_subspace(return_type="row_matrix")
+
+            ## DIAGNOSTIC
+            verbose("\n \n\n After one eligible prime:")
+            verbose("\n -------------------------")
+            verbose("\n p = " + str(p)) 
+            verbose("\n d_p = " + str(d_p))
+            verbose("\n small_gram = " + str(small_gram))
+            verbose("\n small_SBS = " + str(small_SBS))
+            verbose("\n Tp = " + str(Tp))
+            verbose("\n Finished finding maximal isotropic subspace at prime " + str(p))
+
+
+            if Tp.nrows() != 0:
+
+
+                ## Add lifts of this subspace to our matrix of generators
+                TZ_top_as_rows = Matrix(ZZ, Tp.nrows(), (n - d_p))
+                TZ_bottom_as_rows = Tp
+                TZ = TZ_top_as_rows.augment(TZ_bottom_as_rows).transpose()   ## extend the isotropic basis correctly in the basis of L^#
+                #dp_cols_small = U.matrix_from_columns(range(d_p))    ## These columns are the basis of L^# we used to find the maximal iso subspace.
+                #TZ = dp_cols_small * matrix(ZZ,Tp).transpose()  ## Add (a lift to ZZ of) these vectors to a (column) matrix of generators.
+
+
+                ## DIAGNOSTIC
+                verbose("\n \n\n This prime gives the lifts:")
+                verbose("\n ----------------------------")
+                verbose("\n TZ_top_as_rows = " + str(TZ_top_as_rows))
+                verbose("\n TZ_bottom_as_rows = " + str(TZ_bottom_as_rows))
+                verbose("\n TZ = " + str(TZ))
+                verbose("\n T_huge = " + str(T_huge))
+                verbose("\n ")
+
+
+                T_huge = T_huge.augment(TZ)          ## Add (a lift to ZZ of) the isotropic basis vectors to a (column) matrix of generators
+
+                ## DIAGNOSTIC
+                verbose("\n T_huge = " + str(T_huge))
+                verbose("\n ")
+
+
+        ## Find a basis for the maximal form, in the ??? basis
+        verbose("\n\n Status -- Pre-LLL")
+        verbose("\n T_huge has " + str(T_huge.nrows()) + " rows and " + str(T_huge.ncols()) + " columns.")
+        verbose("\n " + str(type(T_huge)) + "  " + str(T_huge.parent()))
+        verbose("\n " + str(T_huge.rows()))
+
+        nr = T_huge.ncols()  ## after LLL the last rows form a basis, the first ones are 0
+        T_lll = T_huge.transpose().LLL().matrix_from_rows(range(nr-n,nr)).transpose()  
+
+        verbose("\n Status -- Post-LLL")
+        #Gram_of_max_lat = matrix(ZZ, T_lll.transpose() * B * T_lll / (max_ed* max_ed))
+
+
+
+        ## DIAGNOSTIC
+        verbose("\n \n\n Generating the final maximal lattice from:")
+        verbose("\n ------------------------------------------")
+        verbose("\n T_lll = " + str(T_lll))
+        verbose("\n L1_dual.basis_matrix_of_columns() = " + str(L1_dual.basis_matrix_of_columns()))
+        verbose("\n ")
+
+
+
+        ## Return a maximal symmetric bilinear lattice
+        return SymmetricBilinearLattice(self, (L1_dual.basis_matrix_of_columns() * T_lll).columns())
+
+        
+
+        
+
+    def is_degenerate(self):
+        """
+        Determines if the quadratic space is degenerate (i.e. it has
+        some non-zero vector orthogonal to the entire space).
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1,1,1]))
+            sage: QS.is_degenerate()
+            False
+
+            sage: QS = QuadraticSpace(FiniteField(9,x), DiagonalQuadraticForm(ZZ, [1,3,5,7]))
+            sage: QS.is_degenerate()
+            True
+
+            sage: QS = QuadraticSpace(RR, DiagonalQuadraticForm(ZZ, []))   ## The zero-dim'l for is non-degenerate by def'n!
+            sage: QS.is_degenerate()
+            False
+
+        """
+        return self.determinant_squareclass().is_zero()
+
+
+    def is_nondegenerate(self):
+        """
+        Determines if the quadratic space is non-degenerate (i.e. it
+        has no non-zero vectors orthogonal to the entire space).
+
+        INPUT:
+            None
+
+        OUTPUT:
+            boolean
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(ZZ, [1,1,1,1]))
+            sage: QS.is_nondegenerate()
+            True
+
+            sage: QS = QuadraticSpace(FiniteField(9,x), DiagonalQuadraticForm(ZZ, [1,3,5,7]))
+            sage: QS.is_nondegenerate()
+            False
+
+            sage: QS = QuadraticSpace(RR, DiagonalQuadraticForm(ZZ, []))   ## The zero-dim'l for is non-degenerate by def'n!
+            sage: QS.is_nondegenerate()
+            True
+        """
+        return not self.is_degenerate()
+
+
+
+
+
+
+
+
+
+
+
+##########################################################################################################################
+##########################################################################################################################
+##########################################################################################################################
+
+
+
+
+
+
+
+
+
+
+
+
+
+from sage.modules.free_module import FreeModule_ambient_field
+
+
+
+#from sage.quadratic_forms.lattice import Lattice
+#from sage.quadratic_forms.symmetric_bilinear_space import SymmetricBilinearSpace
+
+from sage.modules.free_module import FreeModule_submodule_with_basis_pid
+
+#from copy import deepcopy
+
+from sage.rings.arith import LCM
+from sage.misc.functional import denominator
+
+
+
+
+
+###################################################
+## Code for the Symmetric Bilinear Lattice class ##
+###################################################
+
+#class SymmetricBilinearLattice(Lattice):
+class SymmetricBilinearLattice():
+    """
+    This is a class that gives a finitely generated submodule of a
+    K-vectorspace over its ring of integers O_K, where K is a number
+    field.
+
+    TO DO: Eventually add support for S-integers as well, where S is a
+    set of places of K.
+    """
+
+
+    def __init__(self, V, basis):
+        """
+        Initializes with the syntax:
+
+            Lattice(V, list_of_generators)
+            Lattice(V, row_matrix_of_generators)
+
+        where V is a symmetric bilinear space
+
+
+        Note:  When subclassing this class overload the __init__() and ambient_space() methods, and change the internal variable.
+        """
+        ## Check that V is a symmetric bilinear space 
+        if not isinstance(V, SymmetricBilinearSpace):
+            raise TypeError, "The first argumont must be a symmetric bilinear space!"
+
+
+        ## Check that V is a defined over a number field or its completion at a place
+
+
+        ## Check that basis is a matrix or list of vectors
+        if not (is_Matrix(basis) or isinstance(basis, list)):
+            raise TypeError, "The second argument must be a matrix or a list of vectors."
+
+        ## Check that the ring of integers is a PID
+        #raise NotImplementedError, "Presently we only have support for modules over principal ideal domains."
+        
+
+        ## Initilize the lattice
+#        Lattice.__init__(self, V, basis)
+        self.__ambient_bilinear_space = V
+        self.__lattice_module = FreeModule_submodule_with_basis_pid(V.vector_space(), basis)
+        self.__base_ring = V.base_field().ring_of_integers()
+
+
+    def __repr__(self):
+        """
+        Returns a string representing the symmetric bilinear lattice.
+
+        EXAMPLES:
+            sage: L = SymmetricBilinearLattice(QQ^3, [[1,0,0], [1,2,3]])
+            sage: L.__repr__()
+            Symmetric Bilinear Lattice in Vector space of dimension 3 over Rational Field generated by over the ring Integer Ring by
+            [
+            (1, 0, 0),
+            (1, 2, 3)
+            ]
+        """
+        return "Symmetric Bilinear Lattice in " + str(self.ambient_space()) + \
+               " generated by over the ring " + str(self.base_ring()) + \
+               " by \n" + str(self.generators())
+
+
+    def dual_lattice(self):
+        """
+        Compute the dual lattice of this lattice.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            a symmetric bilinear lattice in the same ambient symmetric bilinear space.
+
+        EXAMPLES:
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [1,1])) 
+            sage: L = QuadraticLattice(QS)
+            sage: L_dual = L.dual_lattice(); L_dual
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 2 variables over Rational Field with coefficients:
+            [ 1 0 ]
+            [ * 1 ]
+            spanned by ((1/2, 0), (0, 1/2)).
+
+            sage: QS = QuadraticSpace(QQ, DiagonalQuadraticForm(QQ, [2,45/11,1/12]))
+            sage: L = QS.integral_lattice()
+            sage: L.dual_lattice()
+            Quadratic Lattice in Quadratic space defined by the Quadratic form in 3 variables over Rational Field with coefficients:
+            [ 2 0 0 ]
+            [ * 45/11 0 ]
+            [ * * 1/12 ]
+            spanned by ((1/4, 0, 0), (0, 1/90, 0), (0, 0, 1)).
+
+        """
+        ## Check that the lattice is free -- useful for now, but can be easily circumvented by dealing with generators instead!
+        if not self.is_free():
+            raise NotImplementedError, "We currently don't have an implementation for non-free lattices..." 
+
+        ## Compute the dual basis w.r.t. the ambient bilinear form.
+        B = self.ambient_space().gram_matrix()      ## Gram matrix in std basis
+        A = self.basis_matrix_of_rows()          ## Matrix of basis for L, as row vectors.
+
+        ## Solve A * H * B = Id to get a basis of the dual lattice 
+        X = (A * B).inverse()
+
+        return SymmetricBilinearLattice(self.ambient_space(), X.columns())
+
+
+
+    def is_even(self):
+        """
+        Determines if the given (Z-valued symmetric bilinear) lattice is even.
+        """
+        L, X, even_flag = self.even_sublattice()
+        return even_flag
+
+
+
+    def even_sublattice(self):
+        """
+        Returns the even symmetric bilinear lattice of the given
+        lattice, its associated transformation (on rows), and whether
+        the original lattice was even to begin with.
+
+        INPUT:
+            None
+
+        OUTPUT:
+            (an even symmetric bilinear lattice over ZZ, an integral matrix, boolean)
+
+        EXAMPLES:
+            sage: from sage.quadratic_forms.maximal_extras import even_sublattice_of_bilinear_gram_matrix
+
+            sage: even_sublattice_of_bilinear_gram_matrix(matrix(ZZ, 2, 2, [1,3,3,1]))
+            ([4 8]
+            [8 8], [2 1]
+            [0 1], False)
+
+        """
+        A = self.gram_matrix()
+        n = self.rank()
+        
+        ## Check that the matrix is ZZ-valued
+        if not A in MatrixSpace(ZZ, n, n):
+            raise TypeError, "The symmetric bilinear lattice is not integer-valued!"
+
+
+        X = matrix(ZZ, n, n, 1)
+
+
+        ## Find the first odd diagonal entry
+        odd_ind = -1
+        for i in range(n):
+            if A[i,i] % 2 != 0:
+                odd_ind = i
+                break
+
+        ## Here the lattice is already even
+        if odd_ind == -1:
+            return self, X, True
+
+        ## Make the transformation matrix
+        X[odd_ind, odd_ind] = 2
+        for i in range(odd_ind + 1, n):
+            if A[i,i] % 2 != 0:
+                X[odd_ind, i] = 1
+
+
+        ## Return the even sublattice
+        return SymmetricBilinearLattice(self.ambient_space(), (X * self.basis_matrix_of_rows()).rows()), X, False
+
+        ## Return the even matrix
+        #return X.transpose() * A * X, X, False
+
+
+
+
+    def ambient_space(self):
+        """
+        Returns the ambient symmetric bilinear space that this lattice sits in.
+        """
+        return deepcopy(self.__ambient_bilinear_space)
+
+
+
+    def gram_matrix(self, rational_matrix=False):
+        """
+        Returns the gram matrix with respect to the generators of the
+        symmetric bilinear lattice.
+
+        If rational_matrix is False then this matrix is defined over
+        the base ring of the lattice, otherwise it is defined over the
+        base field of the ambient symmetric bilinear space.
+        
+        """
+        ## Generate the gram matrix
+        B = self.generators()
+        n = len(B)
+        G = Matrix(self.__ambient_bilinear_space.base_field(), n, n)
+        for i in range(n):
+            for j in range(n):
+                G[i,j] = self.__ambient_bilinear_space(B[i], B[j])
+                
+        ## Return the appropriate matrix type!
+        if rational_matrix:
+            return G
+        else:
+            return Matrix(self.base_ring(), G)
+
+
+############################################################################################
+##  the methods below are copied directly from the Lattice class
+############################################################################################
+
+
+
+
+    def ambient_dimension(self):
+        """
+        Returns the ambient vector space that this lattice sits in.
+        """
+        return self.ambient_space().dim()
+
+
+    def base_ring(self):
+        """
+        Returns the ring for which this is a module.
+        """
+        return deepcopy(self.__base_ring)
+
+
+
+    def rank(self):
+        """
+        Determines if the lattice spans the ambient vector space.
+        """
+        return self.__lattice_module.rank()
+        
+
+    def is_full_rank(self):
+        """
+        Determines if the lattice spans the ambient vector space.
+        """
+        return self.rank() == self.ambient_dimension()
+
+
+    def is_free(self):
+        """
+        Determines if the lattice has a (free) basis.
+        """
+        return True
+
+
+    def sum_with(self, other):
+        """
+        Find the sum of this lattice with the lattice L (in the same vector space).
+        """
+        ## Check that both lattices live on the same ambient space
+        if not self.ambient_space() == other.ambient_space():
+            raise TypeError, "The two lattices live on different ambient spaces!"
+
+
+        ## Find a basis for the sum of the two lattices
+        M = Matrix(self.__ambient_bilinear_space.base_field(), self.generators() + other.generators())
+        M_denom = LCM([denominator(M[i,j])  for i in range(M.nrows())  for j in range(M.ncols())])
+        M_int = Matrix(self.base_ring(), M * M_denom)
+        B = [v / M_denom  for v in M_int.row_module().basis()]
+
+
+        ## Return the lattice generated by generators of both lattices
+        return SymmetricBilinearLattice(self.__ambient_bilinear_space, B)
+
+
+    def intersect_with(self, other):
+        """
+        Find the intersection of this lattice with the lattice L (in the same vector space).
+        """
+        ## Check that both lattices live on the same ambient space
+        if not self.ambient_space() == other.ambient_space():
+            raise TypeError, "The two lattices live on different ambient spaces!"
+
+        ## Return the intersection of the two quadratic latties
+        intersection_basis = self.__lattice_free_module.intersection(other.__lattice_free_module).basis()
+        return SymmetricBilinearLattice(self.__ambient_bilinear_space, intersection_basis)
+    
+
+
+    def basis(self):
+        """
+        Returns the list of the basis vectors for the lattice, if the generators form a basis.
+        """
+        return self.__lattice_module.basis()
+
+
+    def basis_matrix_of_columns(self):
+        """
+        Returns a matrix whose columns are the ordered basis for the lattice (if a basis exists).
+        """
+        return self.__lattice_module.basis_matrix().transpose()
+
+
+    def basis_matrix_of_rows(self):
+        """
+        Returns a matrix whose rows are the ordered basis for the lattice (if a basis exists).
+        """
+        return self.__lattice_module.basis_matrix()
+
+
+
+    def generators(self):
+        """
+        Returns the list of generating vectors for the lattice.
+        """
+        return self.__lattice_module.basis()
+
+
+    def generator_matrix_as_columns(self):
+        """
+        Returns a matrix whose columns are the (ordered) generators for the lattice.
+        """
+        return self.__lattice_module.basis_matrix().transpose()
+
+    
+    def generator_matrix_as_rows(self):
+        """
+        Returns a matrix whose rows are the (ordered) generators for the lattice.
+        """
+        return self.__lattice_module.basis_matrix()
+
+
+
+    def apply_linear_transformation_on_left(self, U):
+        """
+        Returns the lattice generated by the generators of this
+        lattice (as a matrix of row vectors), after left-multiplying
+        by the matrix U.
+        """
+        return SymmetricBilinearLattice(self.__ambient_bilinear_space, (U * self.generator_matrix_as_rows()).rows())
+
+
+    def apply_linear_transformation_on_right(self, U):
+        """
+        Returns the lattice generated by the generators of this
+        lattice (as a matrix of column vectors), after right-multiplying
+        by the matrix U.
+        """
+        return SymmetricBilinearLattice(self.__ambient_bilinear_space, (self.generator_matrix_as_columns() * U).columns())
diff -r 120c07be6358 -r 1d85595d94a4 sage/quadratic_forms/weak_approx.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/weak_approx.py	Tue Jan 04 02:08:49 2011 -0500
@@ -0,0 +1,321 @@
+
+
+
+from sage.quadratic_forms.square_classes import SquareClass, local_squareclass_radius_val
+
+from sage.quadratic_forms.extras import sgn
+
+from sage.rings.arith import valuation, is_prime
+from sage.rings.integer_ring import ZZ, crt_basis
+from sage.rings.rational_field import QQ
+from sage.rings.all import is_pAdicField
+
+
+from sage.rings.infinity import Infinity
+
+from sage.misc.misc import prod
+
+
+
+def weak_approx_for_numbers_over_QQ(approx_list):
+    """
+    Find a rational number x (in QQ) satisfying:
+
+        x = a (mod p^v)
+
+    for all given triples (p, v, a), where
+
+        - p is a prime number or Infinity,
+
+        - v is an integer (possibly negative),
+
+        - a is a rational number.
+
+    If the valuation v at Infinity is 1, then the sign of x will be
+    the same as the sign of a.  Allowed valuations at Infinity are
+    either 0 or 1.
+        
+    
+    #Takes a list of triples [prime, val, num], but where each prime is
+    #replaced by its NumberFieldLocalization (which allows
+    #non-archimedian congruences as well).
+
+    INPUT:
+        a list of triples [p, val, num] where:
+            p -- a prime number or a (possibly archimedian) NumberFieldLocalization
+            val -- a positive integer
+            num -- a rational number (or a NumberFieldLocalization_element?)
+        if p is Infinity, then val = 0 (no condition) or 1 (same sign as num).
+
+    OUTPUT:
+        an integer (or a number field element?)
+
+    EXAMPLES:
+        sage: x = weak_approx_for_numbers_over_QQ([[2, 1, 1/2], [3, 1, 3/7]]); x
+        9/2
+        sage: (x - ZZ(1)/ZZ(2)) % 2 == 0
+        True
+        sage: (x - ZZ(3)/ZZ(7)) % 3 == 0
+        True
+
+        sage: weak_approx_for_numbers_over_QQ([[2, 1, 1/2], [Infinity, 0, 123], [3, 1, 3/7]])
+        9/2
+
+        sage: weak_approx_for_numbers_over_QQ([[Infinity, 1, 123], [2, 1, 1/2], [3, 1, 3/7]])
+        9/2
+
+        sage: weak_approx_for_numbers_over_QQ([[Infinity, 1, -123], [2, 1, 1/2], [3, 1, 3/7]])
+        -3/2
+
+    """
+    ## TO DO: Check that the approximation list is internally compatible (which is always true if the moduli are all relatively prime!)
+
+
+    ## Separate out the prime and archimedean conditions
+    prime_approx_list = [L  for L in approx_list  if L[0] != Infinity]
+    archimedean_approx_list = [L  for L in approx_list  if L[0] == Infinity]
+
+    ## Determine the archimedean conditions
+    arch_sign_flag = False
+    if len(archimedean_approx_list) > 0:
+        arch_sign_flag = (archimedean_approx_list[0][1] != 0)     ## Determine if there is a sign condition
+        if arch_sign_flag:
+            arch_sign = sgn(archimedean_approx_list[0][2])        ## If so, decide which sign we want
+        
+
+    #print "archimedean_approx_list = ", archimedean_approx_list
+    #print "arch_sign_flag = ", arch_sign_flag
+
+    ## Coerce to integers where we solve a harder CRT problem, keeping track of the denominator to divide by later
+    integer_approx_list = []
+    total_denom = 1
+    for triple in prime_approx_list:
+        p = triple[0]
+        old_val = triple[1]
+        old_num = triple[2]
+
+        ## Adjust the CRT problem to make it integral (but not necessarily over ZZ yet)
+        p_denom_val = max([0, -valuation(old_num, p)])
+        p_denom_adjustment = p ** p_denom_val 
+        total_denom *= p_denom_adjustment
+        integer_approx_list += [[p, old_val + p_denom_val, old_num * p_denom_adjustment]]
+ 
+
+    ## Separate out the congruence information by numbers and prime-powers
+    integer_list = []
+    p_pow_list = []
+    for triple in integer_approx_list:
+        p_power = triple[0]**triple[1]
+        integer_list.append(ZZ(triple[2] % p_power))        ## TO DO: Check that this works ok with p-adic integers as well.
+        p_pow_list.append(p_power)
+
+    ## Solve the CRT problem over ZZ
+    E = crt_basis(p_pow_list)
+    crt_modulus = prod(p_pow_list)
+    global_int = sum([integer_list[i] * E[i]  for i in range(len(E))]) % crt_modulus   ## This is always positive (>=0) by construction.
+
+    #print "gloabl_int = ", global_int
+
+    ## Adjust the sign to meet our condition at Infinity
+    if arch_sign_flag:
+
+        ## If the signs don't agree, then move by the crt_modulus in the direction we want the sign to be.        
+        if arch_sign < 0:
+            global_int = global_int - crt_modulus
+
+    #print "global_int = ", global_int
+
+
+    ## Divide by the denominator.
+    return QQ(global_int) / total_denom
+
+
+
+
+
+
+
+
+def weak_approx_for_squareclasses_over_QQ(local_squareclass_list, ensure_uniqueness_flag=True):
+    """
+    Returns a (non-zero) squareclass over QQ which localizes to the
+    specified squareclasses, and is only divisible by the primes of
+    the specified squareclasses with odd valuation.
+
+    If the ensure_uniqueness_flag is set, then this routine will raise
+    an error if there is more than one rational squareclass satisfying
+    the given local conditions.
+
+    INPUT:
+        local_squareclass_list -- a list of squareclasses over RR and
+            various p-adic fields Q_p
+        
+    OUTPUT:
+        a squareclass over QQ
+
+    EXAMPLES:
+        sage: S2 = SquareClass(Qp(2), 5)
+        sage: S3 = SquareClass(Qp(3), 5/9)
+        sage: S5 = SquareClass(Qp(5), 5*4)
+        sage: S7 = SquareClass(Qp(7), 3)
+        sage: weak_approx_for_squareclasses_over_QQ([S2, S3, S5, S7])
+        The squareclass represented by 5 over Rational Field
+        
+        sage: weak_approx_for_squareclasses_over_QQ([S2, S3])    ## This fails since it cannot be a unit squareclass at all other places!
+        Traceback (most recent call last):
+        ....
+        RuntimeError: We have not found any global squareclasses which localize to your list of local squareclasses, and having valuation 0 aside from these.
+
+
+    """
+    ## SANITY CHECK: Check that the list isn't empty
+    if len(local_squareclass_list) == 0:
+        raise TypeError, "Oops!  You need to pass in at least one local squareclass to approximate!"
+
+    ## WARNING: this doesn't check compatibility if there is a repeated prime, or even give necessarily the right answer in that case!
+
+    ## Determine the primes dividing the squareclass, and generate a squarefree representative t up to integer unit multiples  
+    t = prod([QS.base_field().prime()  for QS in local_squareclass_list  if is_pAdicField(QS.base_field()) and QS.valuation() == 1])     ## QUESTION: Why doesn't the valuation condition automatically eliminate the real and complex places?!?
+        
+
+    ## Run through all possible units u to check if the rational squareclass u*t satisfies all local conditions!
+    new_s_list = []
+    for u in [1, -1]:
+        localizations_work_flag = True
+        new_s = SquareClass(QQ, u * t)
+        for s in local_squareclass_list:
+
+            ## Check if a localization fails to agree with the given list of squareclasses
+            if s != SquareClass(s.base_field(), new_s.representative()):
+                localizations_work_flag = False
+                break
+
+        ## If all localizations agree, then keep (or return) the rational squareclass 
+        if localizations_work_flag:
+            
+            ## If the ensure_uniqueness flag isn't set, then return this localization
+            if ensure_uniqueness_flag == False:
+                return new_s
+            else:
+                new_s_list.append(new_s)
+           
+
+    ## Check that we have exactly one localization, in which case we return it
+    if len(new_s_list) == 1:
+        return new_s_list[0]
+    elif len(new_s_list) == 0:
+        raise RuntimeError, "We have not found any global squareclasses which localize to your list of local squareclasses, and having valuation 0 aside from these."
+    else:
+        raise RuntimeError, "We have found more than one global squareclass.  Please either unset the ensure_uniqueness_flag or add more local conditions to specify your squareclass uniquely! "
+
+
+
+
+
+
+def strong_approx_for_squareclasses_by_QQ_except_at_one_prime(local_squareclass_list, ensure_uniqueness_flag=True, return_integral_representative=False):
+    """
+    Returns a (non-zero) squareclass over QQ which localizes to the
+    specified squareclasses, and is only divisible by the primes of
+    the specified squareclasses with odd valuation and at most one
+    other prime number.
+
+    If the ensure_uniqueness_flag is set, then this routine will raise
+    an error if there is more than one rational squareclass satisfying
+    the given local conditions.
+
+    INPUT:
+        local_squareclass_list -- a list of squareclasses over RR and
+            various p-adic fields Q_p
+        
+    OUTPUT:
+        a squareclass over QQ
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.weak_approx import strong_approx_for_squareclasses_by_QQ_except_at_one_prime
+
+        sage: Sinf = SquareClass(RR, 5)
+        sage: S2 = SquareClass(Qp(2), 5)
+        sage: S3 = SquareClass(Qp(3), 5/9)
+        sage: S5 = SquareClass(Qp(5), 5*4)
+        sage: S7 = SquareClass(Qp(7), 3)
+        sage: a = strong_approx_for_squareclasses_by_QQ_except_at_one_prime([Sinf, S2, S3, S5, S7], return_integral_representative=True); a
+        12605
+        sage: strong_approx_for_squareclasses_by_QQ_except_at_one_prime([Sinf, S2, S3, S5, S7])
+        The squareclass represented by 12605 over Rational Field
+        sage: SquareClass(RR, a) == Sinf
+        True
+        sage: SquareClass(Qp(2), a) == S2
+        True
+        sage: SquareClass(Qp(3), a) == S3
+        True
+        sage: SquareClass(Qp(5), a) == S5
+        True
+        sage: SquareClass(Qp(7), a) == S7
+        True
+
+    """
+    ## SANITY CHECK: Check that the list isn't empty
+    if len(local_squareclass_list) == 0:
+        raise TypeError, "Oops!  You need to pass in at least one local squareclass to approximate!"
+
+    ## WARNING: this doesn't check compatibility if there is a repeated prime, or even give necessarily the right answer in that case!
+
+
+    #print "local_squareclass_list = ", local_squareclass_list
+
+
+
+    ## Determine the primes dividing the squareclass, and generate a squarefree representative t up to integer unit multiples  
+    t = 1
+    for QS in local_squareclass_list:
+        if QS.valuation() == 1:
+            if is_pAdicField(QS.base_field()):
+                t *= QS.base_field().prime()
+            elif isinstance(QS.base_field(), RealField):
+                t *= QS.normalized_representative()   ## This should be 1 or -1, since we're over RR here.
+            else:
+                raise TypeError, "We were given a squareclass not over the p-adics or RR."           
+
+    #print "t = ", t
+
+
+    ## Determine the modulus and representatives to consider the new prime factor in,
+    new_p_modulus_list = []
+    new_p_repn_list = []
+    for QS in local_squareclass_list:
+        if is_pAdicField(QS.base_field()):
+            p = QS.base_field().prime()
+            new_p_repn_list.append( (QS * t).normalized_representative() )
+            new_p_modulus_list.append(p**local_squareclass_radius_val(p))
+
+    #print "new_p_modulus_list = ", new_p_modulus_list
+    #print "new_p_repn_list = ", new_p_repn_list
+
+
+    ## Use CRT to find the smallest positive representative for the given local squareclasses (without p-divisibility)
+    new_p_modulus = prod(new_p_modulus_list)
+    X = crt_basis(new_p_modulus_list)
+    tmp_p  = sum([X[i] * new_p_repn_list[i]  for i in range(len(X))]) % new_p_modulus
+
+    #print "tmp_p = ", tmp_p
+    #print "new_p_modulus = ", new_p_modulus
+
+
+    ## Increment tmp_p until it is prime  (since it's already prime to all given squareclass places by construction)
+    while not (is_prime(tmp_p)):
+        tmp_p += new_p_modulus
+
+    #print "tmp_p = ", tmp_p
+    
+
+    ## Return the (integral) squareclass representative or squareclass
+    if return_integral_representative:
+        return t * tmp_p
+    else:
+        return SquareClass(QQ, t * tmp_p)
+
+
+
+
+
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1294126218 18000
# Node ID 845d81ee715844fab737ea0381943a5590081f4b
# Parent  1d85595d94a4cfc74ad446f4ed4e11caf8fa8627
Minor adjustments to imports to allow the new patch to build correctly.

diff -r 1d85595d94a4 -r 845d81ee7158 sage/quadratic_forms/quadratic_form.py
--- a/sage/quadratic_forms/quadratic_form.py	Tue Jan 04 02:08:49 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form.py	Tue Jan 04 02:30:18 2011 -0500
@@ -302,12 +302,6 @@
 
     ## Routines to compute p-neighbors
     from sage.quadratic_forms.quadratic_form__neighbors import \
-            p_neighbors_up_to_isometry, \
-            p_neighbors_up_to_isometry__with_mass_check, \
-            p_neighbor_graph, \
-            compute_p_neighbor_once, \
-            compute_p_neighbors, \
-            compute_p_neighbor_from_vector, \
             find_p_neighbor_from_vec
 
     ## Routines to reduce a given quadratic form
diff -r 1d85595d94a4 -r 845d81ee7158 sage/quadratic_forms/quadratic_space.py
--- a/sage/quadratic_forms/quadratic_space.py	Tue Jan 04 02:08:49 2011 -0500
+++ b/sage/quadratic_forms/quadratic_space.py	Tue Jan 04 02:30:18 2011 -0500
@@ -23,7 +23,7 @@
 
 from sage.rings.arith import hilbert_symbol, legendre_symbol, valuation, is_square, is_prime, prime_divisors, is_squarefree
 from sage.rings.integer_ring import ZZ
-from sage.rings.finite_field import GF
+from sage.rings.finite_rings.constructor import GF
 
 
 from sage.functions.other import floor, sqrt
@@ -34,7 +34,8 @@
 
 
 from sage.quadratic_forms.quadratic_form import QuadraticForm, DiagonalQuadraticForm
-from sage.quadratic_forms.extras import sgn, least_quadratic_nonresidue
+from sage.quadratic_forms.extras import least_quadratic_nonresidue
+from sage.functions.generalized import sgn
 from sage.matrix.all import is_Matrix
 from sage.matrix.constructor import matrix, Matrix
 
@@ -59,7 +60,7 @@
 
 #from sage.rings.arith import is_square, is_prime, valuation, legendre_symbol
 
-from sage.quadratic_forms.symmetric_bilinear_space import SymmetricBilinearSpace
+from sage.quadratic_forms.symmetric_bilinear import SymmetricBilinearSpace
 
 
 
diff -r 1d85595d94a4 -r 845d81ee7158 sage/quadratic_forms/square_classes.py
--- a/sage/quadratic_forms/square_classes.py	Tue Jan 04 02:08:49 2011 -0500
+++ b/sage/quadratic_forms/square_classes.py	Tue Jan 04 02:30:18 2011 -0500
@@ -8,14 +8,15 @@
 
 
 from sage.rings.rational_field import is_RationalField, QQ
-from sage.rings.real_mpfr import RealField
+from sage.rings.real_mpfr import is_RealField
 
 from sage.rings.all import is_ComplexField, is_pAdicField, is_FiniteField
 
 
 from sage.misc.functional import squarefree_part
-from sage.quadratic_forms.extras import sgn, least_quadratic_nonresidue
+from sage.quadratic_forms.extras import least_quadratic_nonresidue
 
+from sage.functions.generalized import sgn
 
 
 
@@ -176,7 +177,7 @@
         else:
 
             ## Check that F is of the allowed type (QQ, Q_p, RR, or F_q)
-            if not (is_RationalField(F) or isinstance(F, RealField) or is_pAdicField(F) or is_FiniteField(F) or is_ComplexField(F)):
+            if not (is_RationalField(F) or is_RealField(F) or is_pAdicField(F) or is_FiniteField(F) or is_ComplexField(F)):
                 raise TypeError, "The field F must be QQ, Q_p, RR, F_q or CC."
 
             ## Check that the element can be coerced into the field F.
diff -r 1d85595d94a4 -r 845d81ee7158 sage/quadratic_forms/symmetric_bilinear.py
--- a/sage/quadratic_forms/symmetric_bilinear.py	Tue Jan 04 02:08:49 2011 -0500
+++ b/sage/quadratic_forms/symmetric_bilinear.py	Tue Jan 04 02:30:18 2011 -0500
@@ -21,7 +21,7 @@
 
 from sage.rings.arith import hilbert_symbol, legendre_symbol, valuation, is_square, is_prime, prime_divisors, is_squarefree
 from sage.rings.integer_ring import ZZ
-from sage.rings.finite_field import GF
+from sage.rings.finite_rings.constructor import GF
 
 
 from sage.functions.other import floor, sqrt
@@ -33,7 +33,8 @@
 
 
 from sage.quadratic_forms.quadratic_form import QuadraticForm, DiagonalQuadraticForm
-from sage.quadratic_forms.extras import sgn, least_quadratic_nonresidue
+from sage.quadratic_forms.extras import least_quadratic_nonresidue
+from sage.functions.generalized import sgn
 from sage.matrix.all import is_Matrix, MatrixSpace
 from sage.matrix.constructor import matrix, Matrix
 #from sage.matrix.matrix import Matrix, is_Matrix
diff -r 1d85595d94a4 -r 845d81ee7158 sage/quadratic_forms/weak_approx.py
--- a/sage/quadratic_forms/weak_approx.py	Tue Jan 04 02:08:49 2011 -0500
+++ b/sage/quadratic_forms/weak_approx.py	Tue Jan 04 02:30:18 2011 -0500
@@ -3,7 +3,7 @@
 
 from sage.quadratic_forms.square_classes import SquareClass, local_squareclass_radius_val
 
-from sage.quadratic_forms.extras import sgn
+from sage.functions.generalized import sgn
 
 from sage.rings.arith import valuation, is_prime
 from sage.rings.integer_ring import ZZ, crt_basis
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1294293400 18000
# Node ID b3bcb5a104efbc2fddd20b290a9eac4bdc0e0a00
# Parent  845d81ee715844fab737ea0381943a5590081f4b
Minor correction to a mistaken merge change.

diff -r 845d81ee7158 -r b3bcb5a104ef sage/quadratic_forms/quadratic_form.py
--- a/sage/quadratic_forms/quadratic_form.py	Tue Jan 04 02:30:18 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form.py	Thu Jan 06 00:56:40 2011 -0500
@@ -415,7 +415,7 @@
         if isinstance(R, Ring):
             if is_Matrix(n):
                 ## Test if n is symmetric and has even diagonal
-                if not self._is_even_symmetric_matrix_(n, R):
+                if not init_from_gram_matrix and not self._is_even_symmetric_matrix_(n, R):
                     raise TypeError, "Oops!  The matrix is not a symmetric with even diagonal defined over R."
         
                 ## Rename the matrix and ring
@@ -428,7 +428,7 @@
         if is_Matrix(R) and (n == None):
 
             ## Test if R is symmetric and has even diagonal (when appropriate)
-            if not init_from_gram_matrix and not self._is_even_symmetric_matrix_(n, R):
+            if not init_from_gram_matrix and not self._is_even_symmetric_matrix_(R):
                 raise TypeError, "Oops!  The matrix is not a symmetric with even diagonal."
     
             ## Rename the matrix and ring
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1294482381 18000
# Node ID 465435dcdf311ce173534df34e1cdf472df24bb7
# Parent  b3bcb5a104efbc2fddd20b290a9eac4bdc0e0a00
Lots of changes, added characteristic 2 decomposition, and now the SBS maximal lattice code works!

diff -r b3bcb5a104ef -r 465435dcdf31 sage/quadratic_forms/quadratic_space.py
--- a/sage/quadratic_forms/quadratic_space.py	Thu Jan 06 00:56:40 2011 -0500
+++ b/sage/quadratic_forms/quadratic_space.py	Sat Jan 08 05:26:21 2011 -0500
@@ -297,6 +297,17 @@
             sage: QS.anisotropic_dim()
             6
             
+            sage: S2 = SymmetricBilinearSpace(GF(2), DiagonalMatrix(ZZ, [1,1,1,1]))
+            sage: Q2 = QuadraticSpace(S2.base_field(), S2.gram_matrix(), matrix_type="Gram"); Q2
+            sage: Q2
+            Quadratic space defined by the Quadratic form in 4 variables over Finite Field of size 2 with coefficients: 
+            [ 1 0 0 0 ]
+            [ * 1 0 0 ]
+            [ * * 1 0 ]
+            [ * * * 1 ]
+            sage: Q2.anisotropic_dim()
+            1
+
         """
         ## Deal with (Hessian) degenerate quadratic spaces!
         if self.is_degenerate():
@@ -312,15 +323,21 @@
             else:
                 nondeg_aniso_dim = 0    ## If there are no matrix entries, then there is no anisotripic vector!
 
-            ## In characteristic 2, adjust by the number of non-zero diagonal entries (See Kitaoka's book, Thrm 1.2.1 on pp4-5.)
+            ## In characteristic 2, adjust by the dimension of the span of the diagonal square-classes (See Kitaoka's book, Thrm 1.2.1 on pp4-5.)
             if F.characteristic() == 2:
                 if R != []:
                     M_deg = Matrix(F, R).transpose()          ## Matrix of columns giving a basis for the maximal (Hessian) degenerate quadratic space
                     deg_QF = self.__quadratic_form(M_deg)
-                    t = 0
-                    for i in range(deg_QF.dim()):
-                        if deg_QF[i,i] != 0:
-                            t += 1
+                    if is_FiniteField(F):
+                        t = 0 
+                        for i in range(deg_QF.dim()):
+                            if deg_QF[i,i] != 0:    
+                                t = 1
+                                break
+                    else:
+                        raise NotImplementedError, \
+                            "Still need to write the anisotropic dim over non-finite fields " + \
+                            "-- here we want t to be the dim of span of the squareclasses of diagonal elements!"
                 else:
                     t = 0      ## If there are no matrix entries, then there is no anisotripic vector!  
 
@@ -1170,7 +1187,12 @@
         """
         Return the underlying Hessian bilinear space for this quadratic latice.
         """
-        return deepcopy(self.__hessian_bilinear_space)
+        
+        ## We should be able to use this -- but we can't due a characteristic 2 vector space bug!  (TRAC #)
+        #return deepcopy(self.__hessian_bilinear_space)
+
+        ## Here is our workaround!
+        return SymmetricBilinearSpace(self.__hessian_bilinear_space.base_field(), self.__hessian_bilinear_space.gram_matrix())
 
 
 
diff -r b3bcb5a104ef -r 465435dcdf31 sage/quadratic_forms/symmetric_bilinear.py
--- a/sage/quadratic_forms/symmetric_bilinear.py	Thu Jan 06 00:56:40 2011 -0500
+++ b/sage/quadratic_forms/symmetric_bilinear.py	Sat Jan 08 05:26:21 2011 -0500
@@ -19,7 +19,7 @@
 
 
 
-from sage.rings.arith import hilbert_symbol, legendre_symbol, valuation, is_square, is_prime, prime_divisors, is_squarefree
+from sage.rings.arith import hilbert_symbol, legendre_symbol, valuation, is_square, is_prime, prime_divisors, is_squarefree, GCD
 from sage.rings.integer_ring import ZZ
 from sage.rings.finite_rings.constructor import GF
 
@@ -28,6 +28,8 @@
 
 from sage.misc.functional import squarefree_part, is_even, is_odd
 from sage.misc.misc import prod, verbose
+from sage.misc.mrange import mrange
+
 
 from sage.structure.element import is_Vector
 
@@ -329,7 +331,10 @@
             []
                             
         """
-        V = deepcopy(self.__vector_space)
+        #V = deepcopy(self.__vector_space)       -- This fails due to a GF(2) vectorspace bug!  -- See Trac #
+
+        ## Here is our temporary fix:
+        V = VectorSpace(self.__vector_space.base_field(), self.__vector_space.dimension(), inner_product_matrix=self.__vector_space.inner_product_matrix())
         return V
 
 
@@ -887,15 +892,24 @@
         space.  As a second return argument, return a basis for a
         complementary subspace.
         """
-        B = self.orthogonal_basis()
-        radical_basis = []
-        complementary_basis = []
-        for v in B:
-            if self.inner_product(v,v) == 0:
-                radical_basis.append(v)
-            else:
-                complementary_basis.append(v)
+        F = self.base_field()
+        n = self.dim()
+                
+        radical_basis = self.orthogonal_subspace_to_vector_list(self.basis()).basis()
 
+        ## TO DO: THE FOLLOWING CODE SHOULD BE IN A VECTORSPACE ROUTINE TO FIND A COMPLEMENTARY SET TO A SUBSPACE!
+
+        ## Use the standard "look for pivot columns" trick to find a complementary set of vectors!
+        Id_matrix = Matrix(F, n, n, 1)
+        radical_columns = Matrix(F, radical_basis).transpose()
+        M = radical_columns.augment(Id_matrix)
+        M1 = M.rref()
+        
+        ## Find the pivot columns of the identity matrix part, and these say which standard basis vectors to use as a complement!
+        r = len(radical_basis)
+        complementary_basis = [Id_matrix[i-r]  for i in M1.pivots()  if i >= r]
+
+        ## Return the radical basis, and a complementary basis
         return radical_basis, complementary_basis
 
 
@@ -926,7 +940,7 @@
         """
         ## SANITY CHECK: Check that the space is non-degenerate
         if self.is_degenerate():
-            raise NotImplementedError, "For now we require a non-degenerate quadratic space."
+            raise NotImplementedError, "For now we require a non-degenerate bilinear space."
 
         d = self.dim()
         F = self.base_field()
@@ -946,7 +960,7 @@
         ## Import QuadraticSpace here to avoid circular dependencies!
         from sage.quadratic_forms.quadratic_space import QuadraticSpace
 
-        ## Deal with anistropic forms -- (uses invariants of the assocatied quadratic space, if they exist!)
+        ## Deal with anisotropic forms -- (uses invariants of the associated quadratic space, if they exist!)
         if not known_to_exist and QuadraticSpace(self.base_field(), self.gram_matrix(), matrix_type="Gram").is_anisotropic():
             return False   
 
@@ -966,7 +980,7 @@
             v = v1 + y * v2
 
             ## DIAGNOSTIC
-            verbose("\n Looking for an isotropic vector on the line defined by:")
+            verbose("\n \n\n Looking for an isotropic vector on the line defined by:")
             verbose("\n v1 = " + str(v1))
             verbose("\n v2 = " + str(v2))
             verbose("\n giving v = " + str(v))
@@ -987,7 +1001,8 @@
 
             ## Deal with every vector being isotropic
             if m1 == 0:
-                return vector(F, v1)
+                #return vector(F, v1)                                  -- This fails due to a coersion bug over GF(2) -- TRAC #
+                return vector([F(v1[i]) for i in range(len(v1))])
 
             ## Otherwise find roots, and return an isotropic vector
             m1_roots = m1.roots()
@@ -1000,19 +1015,26 @@
                 verbose("new_v = " + str(new_v))
 
                 if new_v != new_v.parent().zero_vector():
-                    return vector(F, new_v)
+                    #return vector(F, new_v)                                  -- This fails due to a coersion bug over GF(2) -- TRAC #
+                    return vector([F(new_v[i]) for i in range(len(new_v))])
 
+#                    verbose("Ready to return the non-zero new_v = " + str(new_v))
+#                    new_v_as_vector = vector(F, new_v)
+#                    verbose("new_v_as_vector = " + str(new_v_as_vector))
+#                    verbose("type(new_v_as_vector) = " + str(type(new_v_as_vector)))
+#                    return vector(F, new_v)
 
 
 
 
 
-    def orthogonal_subspace_to_vector(self, v):
+
+    def orthogonal_subspace_to_vector_list(self, v_list):
         """
-        Find the subspace of the symmetric bilinear space orthogonal to the given vector.
+        Find the subspace of the symmetric bilinear space orthogonal to the given list of vectors.
 
         INPUT:
-            v -- a vector coercible to the given vectorspace 
+            v_list -- a list of vectors coercible to the given vectorspace 
 
         OUTPUT:
             a subspace of the underlying vectorspace
@@ -1020,19 +1042,316 @@
         EXAMPLES:
 
         """
-        ## Check if we have a vector
-        if not is_Vector(v):
+        ## SANITY CHECK: Check that the vectors are coercible to our vectorspace!
+        try:
+            v1_list = [self.vector_space()(v)  for v in v_list]
+        except:
             raise TypeError, "You need to pass in a vector coercible to this symmetric bilinear space!"
+        
+        
+        F = self.base_field()
+        return (self.gram_matrix() * matrix(F, v1_list).transpose()).kernel()
 
-        v1 = self.vector_space()(v)
-        return (self.gram_matrix() * v1.transpose()).kernel()
 
 
 
 
-    def find_basis_of_maximal_isotropic_subspace(self, return_type="list"):
+
+    def basis(self):
         """
-        Find a basis of a maximal isotropic subspace of the symmetric bilinear space, as a matrix of row vectors.
+        Return the (standard) basis of the underlying vector space.
+        """
+        return self.__vector_space.basis()
+
+
+
+
+
+    def hyperbolic_complement_for_isotropic_vector(self, v):
+        """
+        Returns an isotropic vector whose inner product with v is 1, if one exists.
+        
+        (Here we presently assume that the bilinear space space is non-degenerate, and has characteristic not 2!)
+        
+        """
+        ## SANITY CHECK: Check that the space is non-degenerate
+        if self.is_degenerate():
+            raise NotImplementedError, "For now we require a non-degenerate bilinear space."
+
+
+        F = self.base_field()
+
+        ## Split off a hyperbolic plane if the characteristic is not 2
+        if F.characteristic() != 2:
+            for w in self.basis():
+                a = self.inner_product(v,w)
+                if (a != 0) and (w != v):
+                    b = self.inner_product(w,w)
+                    return w - v * (F(1)/F(2*a))
+
+        ## For characteristic 2, 
+        else:
+            raise NotImplementedError, "This is not as easy to do in characteristic 2, " + \
+                "and requires we normalize (as much as) the entire space to find such a vector!"
+
+
+
+
+
+
+    def characteristic_two_decomposition(self):
+        """
+        Decompose a bilinear space of characteristic 2 into a radical, non-deg space of isotropic vectors, and non-deg anisotropic space.
+
+        Note:  The non-deg space of isotropic vectors will not be totally isotropic, except
+        
+        Returns:    radical_basis, aniso_basis, maximal_tot_iso_basis, hyperbolic_pair_list, metabolic_pair_list
+
+        
+        
+        INPUT:
+            None
+        
+        OUTPUT:
+            five lists of vectors.
+            
+            
+        EXAMPLES:
+            sage: S2 = SymmetricBilinearSpace(GF(2), DiagonalMatrix(ZZ, [1,1,1,1]))
+            sage: S2.characteristic_two_decomposition()
+            ([], [(0, 0, 0, 1)], [[(1, 0, 1, 0), (0, 1, 1, 0)]], [(1, 0, 1, 0), (1, 1, 1, 1)])
+                
+        """
+        F = self.base_field()
+        
+        ## Step 1. Arrange for the diagonal to be an anisotropic quadratic form:
+        ## ----------------------------------------------------------------------
+        #final_basis_list = self.basis()
+
+        ## Find the basis vectors giving non-zero diagonal entries.
+        nz_diag_basis = []
+        nz_diag_elements = []
+        zero_basis = []
+        nz_vec_index_list = []
+
+        B = self.basis()          ## This is the standard basis for our space
+        for i in range(len(B)):
+            v = B[i]
+            tmp_elt = self.inner_product(v,v)
+            if tmp_elt != 0:
+                nz_diag_basis.append(v)
+                nz_diag_elements.append(tmp_elt)
+                nz_vec_index_list.append(i)
+            else:
+                zero_basis.append(v)
+    
+        ## Look for isotropic diagonal relations, until there are none    
+        v_iso = True
+        while v_iso != False:
+
+            #print "LOOKING FOR ISOTROPIC VECTORS IN Gram Matrix" + str(DiagonalMatrix(F, nz_diag_elements))
+
+            ## Find an isotropic vector for the associated non-zero diagonal SBS
+            nz_diag_SBS = SymmetricBilinearSpace(F, DiagonalMatrix(F, nz_diag_elements))
+            v_iso = nz_diag_SBS.find_isotropic_vector()
+
+            #print "USING THE ISOTROPIC VECTOR v_iso = " + str(v_iso)
+
+    
+            ## If we have an isotropic vector, shrink our space
+            if v_iso != False:
+    
+                ## Find the index in our list of a standard basis vector sharing a non-zero entry with v.
+                for i in range(len(v_iso)):
+                    if v_iso[i] != 0:
+                        trim_index = i
+                        break
+        
+        
+                ## Replace the associated basis vector with v_iso in the final_basis_list
+                #v_old = nz_diag_basis[trim_index]
+                #final_basis_list[final_basis_list.index(v_old)] = v_iso
+
+                ## Add the (expanded) isotropic vector v_iso to the zero_basis list
+                v_iso_big_list = len(B) * [0]
+                for i in range(len(nz_vec_index_list)):
+                    v_iso_big_list[nz_vec_index_list[i]] = v_iso[i]
+                zero_basis.append(vector(F, v_iso_big_list))
+           
+                ## Shrink our diagonal SBS, since we have made one diagonal entry zero
+                nz_diag_basis = nz_diag_basis[:trim_index] + nz_diag_basis[trim_index+1:]
+                nz_diag_elements = nz_diag_elements[:trim_index] + nz_diag_elements[trim_index+1:]
+                nz_vec_index_list = nz_vec_index_list[:trim_index] + nz_vec_index_list[trim_index+1:]
+        
+
+        #print "\n\n Finished Step 1:"
+        #print "nz_diag_basis = " + str(nz_diag_basis)
+        #print "nz_diag_elements = " + str(nz_diag_elements)
+        #print "nz_vec_index_list = " + str(nz_vec_index_list)
+        #print "zero_basis = " + str(zero_basis)
+        #print "nz_vec_index_list = " + str(nz_vec_index_list)
+        #print self.gram_matrix_for_vectors(zero_basis + nz_diag_basis)
+
+
+        ## Step 2.  Split off hyperbolic planes:
+        ## -------------------------------------
+        hyperbolic_pair_list = [] 
+                
+        ## Find a non-zero (off-diagonal) entry, if one exists
+        z_len = len(zero_basis)
+        for (i,j) in mrange([z_len, z_len]):                     ## This is a little redundant, but at least we can use a single "break" to escape!
+            b = self.inner_product(zero_basis[i], zero_basis[j])
+            if (b != 0):
+                B = b
+                if i < j:
+                    I = i
+                    J = j
+                else:
+                    I = j
+                    J = i
+                break
+
+
+        ## If one exists, then split off a hyperbolic plane
+        while b != 0:
+
+            ## Note: We now have I, J, and b
+            #print "B = " + str(B)
+            #print "I = " + str(I)
+            #print "J = " + str(J)
+    
+            ## Normalize to get a hyperbolic plane from the (i,j) vectors, and remember the plane
+            zero_basis[J] = zero_basis[J] / b
+            v = zero_basis[I]
+            w = zero_basis[J]
+            hyperbolic_pair_list.append([v,w])        
+            
+            ## Split off the hyperbolic plane (top row and then bottom row, for the hyperbolic plane rows)
+            for k in range(len(zero_basis)):
+                M_ik = self.inner_product(v, zero_basis[k])
+                if (k != J) and (M_ik != 0):
+                    zero_basis[k]  =  zero_basis[k] - (M_ik * w)
+                
+            for k in range(len(zero_basis)):
+                M_jk = self.inner_product(w, zero_basis[k])
+                if (k != I) and (M_jk != 0):
+                    zero_basis[k]  =  zero_basis[k] - (M_jk * v)
+
+            for k in range(len(nz_diag_basis)):
+                M_ik = self.inner_product(v, nz_diag_basis[k])
+                if (k != J) and (M_ik != 0):
+                    nz_diag_basis[k]  =  nz_diag_basis[k] - (M_ik * w)
+                
+            for k in range(len(nz_diag_basis)):
+                M_jk = self.inner_product(w, nz_diag_basis[k])
+                if (k != I) and (M_jk != 0):
+                    nz_diag_basis[k]  =  nz_diag_basis[k] - (M_jk * v)
+
+    
+            ## Remove the hyperbolic plane vectors, so we get a smaller space to look in 
+            zero_basis = zero_basis[:I] + zero_basis[I+1:J] + zero_basis[J+1:]
+    
+    
+            ## Find a non-zero (off-diagonal) entry, to see if we can do another splitting
+            z_len = len(zero_basis)
+            for (i,j) in mrange([z_len, z_len]):
+                b = self.inner_product(zero_basis[i], zero_basis[j])
+                if (b != 0):
+                    B = b
+                    if i < j:
+                        I = i
+                        J = j
+                    else:
+                        I = j
+                        J = i    
+                    break
+
+        #print "\n\n Finished Step 2 -- Split off all hyperbolic planes:"
+        #print "hyperbolic_pair_list = " + str(hyperbolic_pair_list)
+        #print "zero_basis = " + str(zero_basis)
+        #print "nz_diag_basis = " + str(nz_diag_basis)
+        #print self.gram_matrix_for_vectors(zero_basis + nz_diag_basis)
+
+
+        ## Step 3:  Split off the metabolic planes
+        ## ----------------------------------------
+        z_len = len(zero_basis)
+        nz_len = len(nz_diag_basis)
+        
+        if (z_len > 0) and (nz_len > 0):
+        
+            ## Compute the upper-right Gram matrix block
+            M = Matrix(F, z_len, nz_len)
+            for v in zero_basis:
+                for w in nz_diag_basis:
+                    M[i,j] = self.inner_product(v, w)
+
+            #print "M = " + str(M)
+    
+            ## Arrange that the upper-right block is row reduced
+            M1 = M.augment(Matrix(F, z_len, z_len, 1))
+            M1.subdivide(None, z_len)
+            M1 = M1.rref()
+
+            #print "M1 = " + str(M1)
+
+    
+            ## Find the change of variables of the zero-basis vectors to give this row-reduced form
+            T = M1.subdivision(0,1)
+            z_rows_matrix = Matrix(F, zero_basis)
+            zero_basis = (T * z_rows_matrix).rows()
+    
+            ## Split off the metabolic planes
+            metabolic_pair_list = []
+            M0 = M1.subdivision(0,0)    ## This is the RREF of the upper-right gram matrix
+            pivot_columns = M0.pivots()
+            pivot_rows = M0.pivot_rows()
+            number_of_pivots = len(pivot_rows)
+            for p in range(number_of_pivots):
+                I = pivot_rows[p] - p          ## This '-p' is a convenient way of maintining the RREF indexing, since both I and J are strictly increasing!
+                J = pivot_columns[p] - p
+                v = zero_basis[I]
+                w = nz_diag_basis[J]
+                metabolic_pair_list.append([v,w])
+                
+                ## Split off one metabolic plane (top row and then bottom row, for the hyperbolic plane rows)
+                for k in range(len(nz_diag_basis)):
+                    M_ik = self.inner_product(v, nz_diag_basis[k])
+                    if (k != J) and (M_ik != 0):
+                        nz_diag_basis[k]  =  nz_diag_basis[k] - (M_ik * w)
+    
+        
+                ## Remove the metabolic plane basis, so we get a smaller space to look in
+                zero_basis = zero_basis[:I] + zero_basis[I+1:]
+                nz_diag_basis = nz_diag_basis[:J] + nz_diag_basis[J+1:]
+
+
+        ## Step 4:  Find the relevant bases, and return the results
+        ## --------------------------------------------------------
+
+        ## The remaining zero-basis vectors form the radical of the space
+        radical_basis = zero_basis
+                
+        ## The remaining nz_diag-basis vectors are an anisotropic space (but the full anisotropic space may have a metabolic contribution!)
+        diag_aniso_basis = nz_diag_basis
+
+        ## Find bases for a maximal isotropic and maximal anisotropic subspace!
+        maximal_tot_iso_basis = radical_basis + [H[0]  for H in hyperbolic_pair_list] + [M[0]  for M in metabolic_pair_list]
+        aniso_basis = diag_aniso_basis + [M[1]  for M in metabolic_pair_list]
+
+        ## Return the results
+        return  radical_basis, aniso_basis, maximal_tot_iso_basis, hyperbolic_pair_list, metabolic_pair_list
+
+
+
+
+
+
+
+
+    def find_basis_of_maximal_totally_isotropic_subspace(self, return_type="list"):
+        """
+        Find a basis of a maximal totally isotropic subspace of the symmetric bilinear space, as a matrix of row vectors.
 
         The return_type can be 'list', 'row_matrix', or 'column_matrix'.
 
@@ -1046,85 +1365,98 @@
             a matrix of row vectors
 
         EXAMPLES:
-            sage: from sage.quadratic_forms.maximal_extras import find_basis_of_maximal_isotropic_subspace
+            sage: from sage.quadratic_forms.maximal_extras import find_basis_of_maximal_totally_isotropic_subspace
 
             sage: MM = matrix(ZZ, 6, 6, [0, 0, 1, 2, 2, 2, 0, 0, 0, 1, 0, 1, 1, 0, 2, 2, 3, 0, 2, 1, 2, 3, 1, 2, 2, 0, 3, 1, 1, 0, 2, 1, 0, 2, 0, 1])
             sage: QS = QuadraticSpace(GF(5), MM)
-            sage: QS.find_basis_of_maximal_isotropic_subspace()  ## random
+            sage: QS.find_basis_of_maximal_totally_isotropic_subspace()  ## random
             [2 0 0 3 0 2]
             [0 3 0 1 3 1]
             [0 0 2 2 2 3]
 
+            sage: S2 = SymmetricBilinearSpace(GF(2), DiagonalMatrix(ZZ, [1,1,1,1]))
+            sage: S2.find_basis_of_maximal_totally_isotropic_subspace()
+            [(0, 1, 0, 1), (1, 0, 1, 0), (0, 0, 1, 1)]
+
         """
-        ## Deal with degenerate bilinear spaces!
-        if self.is_degenerate():
-            radical_basis, nondeg_basis = self.find_basis_of_radical_subspace()
-            V1 = SymmetricBilinearSpace(self.base_field(), self.gram_matrix_for_vectors(nondeg_basis))
-            V1_iso_basis = V1.find_basis_of_maximal_isotropic_subspace()
-            M1_iso_columns = Matrix(self.base_field(), V1_iso_basis).transpose()    ## Make a matrix of columns (w.r.t. the standard basis for V1)
-            M_nondeg_columns = Matrix(self.base_field(), nondeg_basis).transpose()    ## Make a matrix of columns (w.r.t. the standard basis for V)
+        F = self.base_field()
+       
+        ## Deal with characteristic 2 spaces!
+        if self.base_field().characteristic() == 2:
+            (R, A, M_iso, Hyp_list, Meta_list) = self.characteristic_two_decomposition()
+            T_new = Matrix(F, M_iso)
+        
 
-            ## Find the radical and non-degenerate vectors that give a maximal isotropic subspace
-            T_new = Matrix(self.base_field(), radical_basis + (M_nondeg_columns * M1_iso_columns).columns())
+       
+        ## Deal with odd characteristic spaces:
+        ## ------------------------------------
+        else:
 
-
-        ## Here we suppose that the space is non-degenerate...
-        ## ---------------------------------------------------
-        else:
-            G = self.gram_matrix()
-            F = self.base_field()
-            n = G.nrows()
-
-            p = G.parent().base_ring().characteristic()
-
-
-
-            ## Make the transformation matrix (of rows!!!)
-            T = matrix(F, 0, n, [])
-
-            ## Find one isotropic vector
-            v = self.find_isotropic_vector()
-
-            ## Check if we're done.
-            if v == False:
-                return T
-
-            ## Find a basis for v^\perp
-            K = self.orthogonal_subspace_to_vector(v).basis_matrix()    ## Note: Row vectors here, in reduced row echelon form!
-
-            ## DIAGNOSTIC
-            verbose("v = " + str(v))
-            verbose("K = " + str(K))
-
-            ## Find the first non-zero entry of v, to use to decide which kernel basis vector to replace with v.
-            for i in range(n):
-                if v[i] != 0:
-                    v_nz_index = i
-                    break
-            ## Find the associated basis vector (using heavily the row echelon form of the output)
-            for i in range(K.nrows()):
-                if K[i, v_nz_index] != 0:
-                    K_nz_index = i
-                    break
-
-            ## DIAGNOSIC
-            verbose("\n v_nz_index = " + str(v_nz_index))
-            verbose("\n K_nz_index = " + str(K_nz_index))
-
-            ## Extract the kernel basis excluding v
-            K1 = K.matrix_from_rows([j for j in range(K.nrows())  if j != K_nz_index])
-            G1 = K1 * G * K1.transpose()
-
-            ## Perform the recursion
-            SBS1 = SymmetricBilinearSpace(self.base_field(), G1)
-            T1 = SBS1.find_basis_of_maximal_isotropic_subspace()
-            T_last = T1 * K1
-            T_new = (T_last.transpose().augment(v.transpose())).transpose()   ## Augment T_last by adding the row v
-
-            ## DIAGNOSTIC
-            verbose("\n T_new = " + str(T_new))
-            verbose("\n Found T_new of dimension " + str(T_new.nrows()))
-            verbose("\n return_type = " + str(return_type))
+            ## Deal with degenerate bilinear spaces!
+            if self.is_degenerate():
+    
+                ## DIAGNOSTIC
+                verbose("\n\n\n\nStarting the degenerate case...")
+    
+                radical_basis, nondeg_basis = self.find_basis_of_radical_subspace()
+                V1 = SymmetricBilinearSpace(self.base_field(), self.gram_matrix_for_vectors(nondeg_basis))
+                V1_iso_basis = V1.find_basis_of_maximal_totally_isotropic_subspace()
+                M1_iso_columns = Matrix(self.base_field(), V1_iso_basis).transpose()    ## Make a matrix of columns (w.r.t. the standard basis for V1)
+                M_nondeg_columns = Matrix(self.base_field(), nondeg_basis).transpose()    ## Make a matrix of columns (w.r.t. the standard basis for V)
+    
+                ## Find the radical and non-degenerate vectors that give a maximal isotropic subspace
+                T_new = Matrix(self.base_field(), radical_basis + (M_nondeg_columns * M1_iso_columns).columns())
+    
+    
+            ## Here we suppose that the space is non-degenerate...
+            ## ---------------------------------------------------
+            else:
+                ## DIAGNOSTIC
+                verbose("\n\n\n\nStarting the non-degenerate case...")
+    
+                
+                G = self.gram_matrix()
+                n = G.nrows()
+    
+                p = G.parent().base_ring().characteristic()
+    
+    
+    
+                ## Make the transformation matrix (of rows!!!)
+                T = matrix(F, 0, n, [])
+    
+                ## Find one isotropic vector
+                v = self.find_isotropic_vector()
+    
+                ## Check if we're done.
+                if v == False:
+                    return T
+    
+    
+                ## Split off a hyperbolic plane, since we're non-degenerate:
+                ## ---------------------------------------------------------
+    
+                ## Find a hyperbolic plane H containing the given isotropic vector
+                w = self.hyperbolic_complement_for_isotropic_vector(v)
+                
+                ## Find the smaller subspace (orthogonal to H) and its Gram matrix to use in the recursion
+                K1 = self.orthogonal_subspace_to_vector_list([v,w]).basis_matrix()    ## Note: Row vectors here, in reduced row echelon form!
+                G1 = K1 * G * K1.transpose()
+    
+                ## DIAGNOSIC
+                verbose("\n K1 = " + str(K1))
+                verbose("\n G1 = " + str(G1))
+    
+                ## Perform the recursion
+                SBS1 = SymmetricBilinearSpace(self.base_field(), G1)
+                T1 = SBS1.find_basis_of_maximal_totally_isotropic_subspace(return_type="row_matrix")
+                T_last = T1 * K1
+                T_new = (T_last.transpose().augment(v.transpose())).transpose()   ## Augment T_last by adding the row v
+    
+                ## DIAGNOSTIC
+                verbose("\n T_new = " + str(T_new))
+                verbose("\n Found T_new of dimension " + str(T_new.nrows()))
+                verbose("\n return_type = " + str(return_type))
                         
 
 
@@ -1201,39 +1533,41 @@
             [0 0 1 0]
             [0 0 0 1]
 
+            sage: SBS = SymmetricBilinearSpace(QQ, 2*DiagonalMatrix(QQ, [1,5,25,125]))
+            sage: L = SBS.maximal_bilinear_lattice()
+            sage: L.gram_matrix(rational_matrix=True)
+            [1 0 0 0]
+            [0 1 0 0]
+            [0 0 1 0]
+            [0 0 0 1]
 
-            ## CHECK THESE!!! -- THESE ARE NOT CHECKED BY HAND! =(
+
+
+            ## CHECK THESE BELOW!!! -- THESE ARE NOT CHECKED BY HAND! =(
 
             sage: SBS = SymmetricBilinearSpace(QQ, DiagonalMatrix(QQ, [1,3,9,27]))
             sage: L = SBS.maximal_bilinear_lattice()
-            sage: L.gram_matrix()
-
+            sage: L.gram_matrix(rational_matrix=True)
             [1 0 0 0]
             [0 1 0 0]
             [0 0 3 0]
             [0 0 0 3]
-            sage:
-            sage:
-            sage:
-            sage: SBS = SymmetricBilinearSpace(QQ, 2 * DiagonalMatrix(QQ, [1,5,25,125]))
+            sage: 
+            sage: SBS = SymmetricBilinearSpace(QQ, 2 * DiagonalMatrix(QQ, [1,3,9,27]))
             sage: L = SBS.maximal_bilinear_lattice()
-            sage: L.gram_matrix()
-
-            [2 0 0 0]
-            [0 2 0 0]
-            [0 0 1 0]
-            [0 0 0 1]
-            sage:
-            sage:
-            sage: SBS = SymmetricBilinearSpace(QQ, DiagonalMatrix(QQ, [1,5,25,125]))
-            sage:
+            sage: L.gram_matrix(rational_matrix=True)
+            [2 0 1 0]
+            [0 2 0 1]
+            [1 0 2 0]
+            [0 1 0 2]
+            sage: 
+            sage: SBS = SymmetricBilinearSpace(QQ, 4 * DiagonalMatrix(QQ, [1,3,9,27]))
             sage: L = SBS.maximal_bilinear_lattice()
-            sage: L.gram_matrix()
-
+            sage: L.gram_matrix(rational_matrix=True)
             [1 0 0 0]
             [0 1 0 0]
-            [0 0 1 0]
-            [0 0 0 1]
+            [0 0 3 0]
+            [0 0 0 3]
 
         """
         n = self.dim()
@@ -1275,6 +1609,7 @@
         A = Matrix(ZZ, L_dual.gram_matrix(rational_matrix=True).inverse())     ## This matrix describes L in the given basis of L^#
         D, U, V = A.smith_form()
         iso_eligible_primes = prime_divisors(D[-2,-2])        ## The list of primes which have at most a 2-dim'l subspace in L^#/L
+        iso_prime_product = prod(iso_eligible_primes)
         #L1_dual = L_dual.apply_linear_transformation_on_right(U)        ## This is the dual lattice in the 'nice' basis, so a basis of L is multiples
         L1_dual = L_dual.apply_linear_transformation_on_right(U.inverse())        ## This is the dual lattice in the 'nice' basis, so a basis of L is multiples
         
@@ -1307,7 +1642,7 @@
 
             ## Create the bilinear lattice in the basis
             small_SBS = SymmetricBilinearSpace(GF(p), p * small_gram)  ## This mult-by-p makes the gram matrix p-integral
-            Tp = small_SBS.find_basis_of_maximal_isotropic_subspace(return_type="row_matrix")
+            Tp = small_SBS.find_basis_of_maximal_totally_isotropic_subspace(return_type="row_matrix")
 
             ## DIAGNOSTIC
             verbose("\n \n\n After one eligible prime:")
@@ -1320,12 +1655,28 @@
             verbose("\n Finished finding maximal isotropic subspace at prime " + str(p))
 
 
+            ## Now add an integral lift of this subspace to the basis of our submodule in L^#/L
             if Tp.nrows() != 0:
 
+ 
+
+                ## Find the appropriate lift factor to multiply the (mod p) vector by to lift it to ZZ only at p (and is the zero vector at other primes!).
+                iso_prime_prod_not_p = ZZ(iso_prime_product / p)
+                iso_prime_lift_multiplier = (iso_prime_prod_not_p) * (GF(p)(iso_prime_prod_not_p)**(-1)).lift()
+
+
+                ## Find integer lifts of our vectors (being careful to have the vectors to initially be primitive relative to all other primes)
+                Tp_lift_list = []
+                for v in Tp.rows():
+                    v1 = vector(ZZ, v.lift())
+                    g = GCD(list(v1))
+                    v2 = v1 * (1/g) 
+                    Tp_lift_list.append(v2 * iso_prime_lift_multiplier)
+                
 
                 ## Add lifts of this subspace to our matrix of generators
                 TZ_top_as_rows = Matrix(ZZ, Tp.nrows(), (n - d_p))
-                TZ_bottom_as_rows = Tp
+                TZ_bottom_as_rows = Matrix(ZZ, Tp_lift_list)
                 TZ = TZ_top_as_rows.augment(TZ_bottom_as_rows).transpose()   ## extend the isotropic basis correctly in the basis of L^#
                 #dp_cols_small = U.matrix_from_columns(range(d_p))    ## These columns are the basis of L^# we used to find the maximal iso subspace.
                 #TZ = dp_cols_small * matrix(ZZ,Tp).transpose()  ## Add (a lift to ZZ of) these vectors to a (column) matrix of generators.
@@ -1334,6 +1685,9 @@
                 ## DIAGNOSTIC
                 verbose("\n \n\n This prime gives the lifts:")
                 verbose("\n ----------------------------")
+                verbose("\n iso_prime_product = " + str(iso_prime_product))
+                verbose("\n iso_prime_prod_not_p = " + str(iso_prime_prod_not_p))
+                verbose("\n iso_prime_lift_multiplier = " + str(iso_prime_lift_multiplier))
                 verbose("\n TZ_top_as_rows = " + str(TZ_top_as_rows))
                 verbose("\n TZ_bottom_as_rows = " + str(TZ_bottom_as_rows))
                 verbose("\n TZ = " + str(TZ))
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1294485707 18000
# Node ID 6ff544e9f3182ed12086ab501dd976d7ac938f58
# Parent  465435dcdf311ce173534df34e1cdf472df24bb7
Got the maximal_quadratic_lattice() method to work now! =)

diff -r 465435dcdf31 -r 6ff544e9f318 sage/quadratic_forms/quadratic_space.py
--- a/sage/quadratic_forms/quadratic_space.py	Sat Jan 08 05:26:21 2011 -0500
+++ b/sage/quadratic_forms/quadratic_space.py	Sat Jan 08 06:21:47 2011 -0500
@@ -31,6 +31,7 @@
 
 from sage.misc.functional import squarefree_part, is_even, is_odd
 from sage.misc.misc import prod, verbose
+from sage.misc.mrange import mrange
 
 
 from sage.quadratic_forms.quadratic_form import QuadraticForm, DiagonalQuadraticForm
@@ -1470,6 +1471,7 @@
             
 
         """
+        F = self.base_field()
         n = self.dim()
         
         ## Check that we're working over QQ
@@ -1483,13 +1485,17 @@
         ## Find a maximal lattice for the associated Hessian bilinear space
         Hessian_maximal_lattice = self.__hessian_bilinear_space.maximal_bilinear_lattice()
 
+        print "Hessian_maximal_lattice = " + str(Hessian_maximal_lattice)
 
         ## Find the even sublattice, and look for a maximal even superlattice of it
         Even_sublattice = Hessian_maximal_lattice.even_sublattice()
-        Pn_Z2 = mrange(4*[2])[1:]   ## This runs over all vertors of P^n(GF(2))
+
+        print "Even_sublattice = " + str(Even_sublattice)
+
+        Pn_Z2 = mrange(4*[2])[1:]   ## This runs over all vectors of P^n(GF(2))
         ## Loop through all index 2 superlattices, looking for an even one
         for v in Pn_Z2:              
-            v1_list = (Matrix(self.base_field(), ZZ(1)/ZZ(2) * v) * Even_sublattice.basis_matrix_of_rows()).rows()
+            v1_list = (Matrix(F, vector(F, v) * (ZZ(1)/ZZ(2))) * Even_sublattice.basis_matrix_of_rows()).rows()
             L = Even_sublattice.sum_with(v1_list)
             if L.is_even():
                 return QuadraticLattice(self, L.basis())
diff -r 465435dcdf31 -r 6ff544e9f318 sage/quadratic_forms/symmetric_bilinear.py
--- a/sage/quadratic_forms/symmetric_bilinear.py	Sat Jan 08 05:26:21 2011 -0500
+++ b/sage/quadratic_forms/symmetric_bilinear.py	Sat Jan 08 06:21:47 2011 -0500
@@ -1943,16 +1943,39 @@
 
 
 
+    def is_integral(self):
+        """
+        Determine if the symmetric bilinear lattice is integer-valued.        
+        """
+        A_rational = self.gram_matrix(rational_matrix=True)
+        n = self.rank()
+        
+        ## Check that the matrix is ZZ-valued
+        try:
+            A = MatrixSpace(ZZ, n, n)(A_rational)
+            return True
+        except:
+            return False
+
+
+
+
     def is_even(self):
         """
         Determines if the given (Z-valued symmetric bilinear) lattice is even.
+        
         """
-        L, X, even_flag = self.even_sublattice()
+        ## Check if the lattice is integer-valued
+        if not self.is_integral():
+            return False
+        
+        ## Check if the lattice is even!
+        L, X, even_flag = self.even_sublattice(return_extended_info=True)
         return even_flag
 
 
 
-    def even_sublattice(self):
+    def even_sublattice(self, return_extended_info=False):
         """
         Returns the even symmetric bilinear lattice of the given
         lattice, its associated transformation (on rows), and whether
@@ -1973,14 +1996,14 @@
             [0 1], False)
 
         """
-        A = self.gram_matrix()
-        n = self.rank()
-        
         ## Check that the matrix is ZZ-valued
-        if not A in MatrixSpace(ZZ, n, n):
+        if not self.is_integral():
             raise TypeError, "The symmetric bilinear lattice is not integer-valued!"
 
 
+        ## Initialize some variables
+        n = self.rank()
+        A = self.gram_matrix()
         X = matrix(ZZ, n, n, 1)
 
 
@@ -1995,18 +2018,19 @@
         if odd_ind == -1:
             return self, X, True
 
-        ## Make the transformation matrix
+        ## Make the transformation matrix (on row vectors!)
         X[odd_ind, odd_ind] = 2
         for i in range(odd_ind + 1, n):
             if A[i,i] % 2 != 0:
-                X[odd_ind, i] = 1
+                X[i, odd_ind] = 1
 
 
         ## Return the even sublattice
-        return SymmetricBilinearLattice(self.ambient_space(), (X * self.basis_matrix_of_rows()).rows()), X, False
+        if return_extended_info:
+            return SymmetricBilinearLattice(self.ambient_space(), (X * self.basis_matrix_of_rows()).rows()), X, False
+        else:
+            return SymmetricBilinearLattice(self.ambient_space(), (X * self.basis_matrix_of_rows()).rows())
 
-        ## Return the even matrix
-        #return X.transpose() * A * X, X, False
 
 
 
@@ -2015,7 +2039,11 @@
         """
         Returns the ambient symmetric bilinear space that this lattice sits in.
         """
-        return deepcopy(self.__ambient_bilinear_space)
+        ## We should be able to use this -- but we can't due a characteristic 2 vector space bug!  (TRAC #)
+        #return deepcopy(self.__ambient_bilinear_space)
+
+        ## Here is our workaround!
+        return SymmetricBilinearSpace(self.__ambient_bilinear_space.base_field(), self.__ambient_bilinear_space.gram_matrix())
 
 
 
@@ -2044,6 +2072,47 @@
             return Matrix(self.base_ring(), G)
 
 
+
+
+
+    def sum_with(self, other):
+        """
+        Find the sum of this lattice with the lattice L (in the same vector space).
+ 
+        Here other can be a SymmetricBilinearLattice, or a list of vectors that coerce to the SymmetricBilinearSpace!
+        
+        TO DO: Allow other to be a Lattice as well.
+
+        """
+        ## Initialize from a list of vectors
+        if isinstance(other, list):
+            new_gens_list = other
+
+        ## Initialize from a SymmetricBilinearSpace
+        elif isinstance(other, SymmetricBilinearLattice):
+                ## Check that both lattices live on the same ambient space
+            if not self.ambient_space() == other.ambient_space():
+                raise TypeError, "The two lattices live on different ambient spaces!"
+
+            new_gens_list = other.generators()
+
+        else:
+            raise TypeError, "The type of other is presently not supported!"
+
+
+        ## Find a basis for the sum of the two lattices
+        M = Matrix(self.__ambient_bilinear_space.base_field(), self.generators() + new_gens_list)
+        M_denom = LCM([denominator(M[i,j])  for i in range(M.nrows())  for j in range(M.ncols())])
+        M_int = Matrix(self.base_ring(), M * M_denom)
+        B = [v / M_denom  for v in M_int.row_module().basis()]
+
+
+        ## Return the lattice generated by generators of both lattices
+        return SymmetricBilinearLattice(self.__ambient_bilinear_space, B)
+
+
+
+
 ############################################################################################
 ##  the methods below are copied directly from the Lattice class
 ############################################################################################
@@ -2087,25 +2156,6 @@
         return True
 
 
-    def sum_with(self, other):
-        """
-        Find the sum of this lattice with the lattice L (in the same vector space).
-        """
-        ## Check that both lattices live on the same ambient space
-        if not self.ambient_space() == other.ambient_space():
-            raise TypeError, "The two lattices live on different ambient spaces!"
-
-
-        ## Find a basis for the sum of the two lattices
-        M = Matrix(self.__ambient_bilinear_space.base_field(), self.generators() + other.generators())
-        M_denom = LCM([denominator(M[i,j])  for i in range(M.nrows())  for j in range(M.ncols())])
-        M_int = Matrix(self.base_ring(), M * M_denom)
-        B = [v / M_denom  for v in M_int.row_module().basis()]
-
-
-        ## Return the lattice generated by generators of both lattices
-        return SymmetricBilinearLattice(self.__ambient_bilinear_space, B)
-
 
     def intersect_with(self, other):
         """
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1294535797 18000
# Node ID 01ac57b921138a0e011be0c2f2fb6641fbe39ad6
# Parent  6ff544e9f3182ed12086ab501dd976d7ac938f58
Manually adding the quadratic_form__neightbors.py file from my sage-4.1.1 code, which was missed in the merge before.

diff -r 6ff544e9f318 -r 01ac57b92113 sage/quadratic_forms/quadratic_form__neighbors.py
--- a/sage/quadratic_forms/quadratic_form__neighbors.py	Sat Jan 08 06:21:47 2011 -0500
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,257 +0,0 @@
-"""
-Neighbors
-"""
-from sage.modules.free_module_element import vector
-from sage.rings.integer_ring import ZZ
-from copy import deepcopy
-from sage.quadratic_forms.extras import extend_to_primitive
-from sage.matrix.constructor import matrix
-#from sage.quadratic_forms.quadratic_form import QuadraticForm    ## This creates a circular import! =(
-
-
-####################################################################################
-## Routines used for understanding p-neighbors, and computing classes in a genus. ##
-####################################################################################
-
-
-def find_primitive_p_divisible_vector__random(self, p):
-    """
-    Finds a random `p`-primitive vector in `L/pL` whose value is `p`-divisible.
-
-    .. note::
-    
-        Since there are about `p^{(n-2)}` of these lines, we have a `1/p`
-        chance of randomly finding an appropriate vector.
-
-    .. warning::
-    
-        If there are local obstructions for this to happen, then this algorithm
-        will never terminate... =(  We should check for this too!
-
-    EXAMPLES::
-    
-        sage: Q = QuadraticForm(ZZ, 2, [10,1,4])
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (1, 1)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (1, 0)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (2, 0)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (2, 2)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (3, 3)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (3, 3)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (2, 0)
-
-    """
-    n = self.dim()
-    v = vector([ZZ.random_element(p)  for i in range(n)])
-
-    ## Repeatedly choose random vectors, and evaluate until the value is p-divisible.
-    while True:
-        if (self(v) % p == 0) and (v != 0):         
-            return v
-        else: 
-            v[ZZ.random_element(n)] = ZZ.random_element(p)      ## Replace a random entry and try again.
-
-
-
-
-#def find_primitive_p_divisible_vector__all(self, p):
-#    """
-#    Finds all random p-primitive vectors (up to scaling) in L/pL whose
-#    value is p-divisible.
-#
-#    Note: Since there are about p^(n-2) of these lines, we should avoid this for large n.
-#    """
-#    pass
-
-
-def find_primitive_p_divisible_vector__next(self, p, v=None):
-    """
-    Finds the next `p`-primitive vector (up to scaling) in `L/pL` whose
-    value is `p`-divisible, where the last vector returned was `v`.  For
-    an intial call, no `v` needs to be passed.
-
-    Returns vectors whose last non-zero entry is normalized to 0 or 1 (so no
-    lines are counted repeatedly).  The ordering is by increasing the
-    first non-normalized entry.  If we have tested all (lines of)
-    vectors, then return None.
-
-    OUTPUT:
-        vector or None
-
-    EXAMPLES::
-    
-        sage: Q = QuadraticForm(ZZ, 2, [10,1,4])
-        sage: v = Q.find_primitive_p_divisible_vector__next(5); v
-        (1, 1)
-        sage: v = Q.find_primitive_p_divisible_vector__next(5, v); v
-        (1, 0)
-        sage: v = Q.find_primitive_p_divisible_vector__next(5, v); v
-
-
-    """
-    ## Initialize 
-    n = self.dim()
-    if v == None:
-        w = vector([ZZ(0) for i in range(n-1)] + [ZZ(1)])
-    else:
-        w = deepcopy(v)
-
-
-    ## Handle n = 1 separately.
-    if n <= 1:
-        raise RuntimeError, "Sorry -- Not implemented yet!"
-
-
-    ## Look for the last non-zero entry (which must be 1)
-    nz = n - 1
-    while w[nz] == 0:
-        nz += -1
-
-    ## Test that the last non-zero entry is 1 (to detect tampering).
-    if w[nz] != 1:
-        print "Warning: The input vector to QuadraticForm.find_primitive_p_divisible_vector__next() is not normalized properly."
-
-
-
-    ## Look for the next vector, until w == 0
-    while True:
-
-
-        ## Look for the first non-maximal (non-normalized) entry
-        ind = 0
-        while (ind < nz) and (w[ind] == p-1):
-            ind += 1
-
-        #print ind, nz, w
-
-        ## Increment 
-        if (ind < nz):
-            w[ind] += 1
-            for j in range(ind):
-                w[j] = 0        
-        else:  
-            for j in range(ind+1):    ## Clear all entries
-                w[j] = 0        
-
-            if nz != 0:               ## Move the non-zero normalized index over by one, or return the zero vector
-                w[nz-1] = 1
-                nz += -1
-
-
-        ## Test for zero vector
-        if w == 0:
-            return None
-
-        ## Test for p-divisibility
-        if (self(w) % p == 0):
-            return w
-
-
-
-
-## ----------------------------------------------------------------------------------------------
-
-def find_p_neighbor_from_vec(self, p, v):
-    """
-    Finds the `p`-neighbor of this quadratic form associated to a given
-    vector `v` satisfying:
-
-    #. `Q(v) = 0  \pmod p`
-    #. `v` is a non-singular point of the conic `Q(v) = 0 \pmod p`.
-
-    Reference:  Gonzalo Tornaria's Thesis, Thrm 3.5, p34.
-
-    EXAMPLES::
-    
-        sage: Q = DiagonalQuadraticForm(ZZ,[1,1,1,1])
-        sage: v = vector([0,2,1,1])
-        sage: X = Q.find_p_neighbor_from_vec(3,v); X
-        Quadratic form in 4 variables over Integer Ring with coefficients: 
-        [ 3 10 0 -4 ]
-        [ * 9 0 -6 ]
-        [ * * 1 0 ]
-        [ * * * 2 ]
-
-    """
-    R = self.base_ring()
-    n = self.dim()
-    B2 = self.matrix()
-
-    ## Find a (dual) vector w with B(v,w) != 0 (mod p)
-    v_dual = B2 * vector(v)     ## We want the dot product with this to not be divisible by 2*p.
-    y_ind = 0
-    while ((y_ind < n) and (v_dual[y_ind] % p) == 0):   ## Check the dot product for the std basis vectors!
-        y_ind += 1
-    if y_ind == n:
-        raise RuntimeError, "Oops!  One of the standard basis vectors should have worked."
-    w = vector([R(i == y_ind)  for i in range(n)])
-    vw_prod = (v * self.matrix()).dot_product(w)
-
-    ## DIAGNOSTIC
-    #if vw_prod == 0:
-    #   print "v = ", v
-    #   print "v_dual = ", v_dual
-    #   print "v_dual[y_ind] = ", v_dual[y_ind]
-    #   print "(v_dual[y_ind] % p) = ", (v_dual[y_ind] % p)
-    #   print "w = ", w
-    #   print "p = ", p
-    #   print "vw_prod = ", vw_prod
-    #   raise RuntimeError, "ERROR: Why is vw_prod = 0?"
-
-    ## DIAGNOSTIC
-    #print "v = ", v
-    #print "w = ", w
-    #print "vw_prod = ", vw_prod
-
-
-    ## Lift the vector v to a vector v1 s.t. Q(v1) = 0 (mod p^2)
-    s = self(v)
-    if (s % p**2 != 0):
-        al = (-s / (p * vw_prod)) % p
-        v1 = v + p * al * w
-        v1w_prod = (v1 * self.matrix()).dot_product(w)
-    else:
-        v1 = v
-        v1w_prod = vw_prod
-
-    ## DIAGNOSTIC
-    #if (s % p**2 != 0):
-    #    print "al = ", al
-    #print "v1 = ", v1
-    #print "v1w_prod = ", v1w_prod
-
-
-    ## Construct a special p-divisible basis to use for the p-neighbor switch
-    good_basis = extend_to_primitive([v1, w])
-    for i in range(2,n):
-        ith_prod = (good_basis[i] * self.matrix()).dot_product(v)
-        c = (ith_prod / v1w_prod) % p
-        good_basis[i] = good_basis[i] - c * w  ## Ensures that this extenstion has <v_i, v> = 0 (mod p)
-
-    ## DIAGNOSTIC
-    #print "original good_basis = ", good_basis
-
-    ## Perform the p-neighbor switch
-    good_basis[0]  = vector([x/p  for x in good_basis[0]])    ## Divide v1 by p
-    good_basis[1]  = good_basis[1] * p                          ## Multiply w by p
-
-    ## Return the associated quadratic form
-    M = matrix(good_basis)
-    new_Q = deepcopy(self)                        ## Note: This avoids a circular import of QuadraticForm!
-    new_Q.__init__(R, M * self.matrix() * M.transpose())
-    return new_Q
-    return QuadraticForm(R, M * self.matrix() * M.transpose())
-
-
-## ----------------------------------------------------------------------------------------------
-
-
-#def find_classes_in_genus(self):
-
-
diff -r 6ff544e9f318 -r 01ac57b92113 sage/quadratic_forms/quadratic_form__neighbors__NEW.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/quadratic_form__neighbors__NEW.py	Sat Jan 08 20:16:37 2011 -0500
@@ -0,0 +1,638 @@
+
+from sage.rings.all import GF
+from sage.misc.functional import sqrt
+
+from sage.structure.element import is_Vector
+
+from sage.modules.free_module_element import vector
+from sage.rings.all import ZZ, QQ
+from copy import deepcopy
+
+from sage.matrix.constructor import Matrix
+
+from sage.quadratic_forms.extras import extend_to_primitive
+#from sage.quadratic_forms.maximal_extras import 
+#    even_sublattice_of_bilinear_gram_matrix, \
+#    find_basis_of_maximal_isotropic_subspace, \
+#    diagonalise_mod_2, \
+#    even_neighbor_of_bilinear_gram_matrix
+
+from sage.matrix.constructor import matrix
+#from sage.quadratic_forms.quadratic_form import QuadraticForm    ## This creates a circular import! =(
+
+from sage.rings.arith import prime_divisors
+
+from sage.quadratic_forms.projective_iterators import normalized_finite_projective_space_generator
+
+
+
+
+
+
+
+#def genus_representatives(self,  exhaust_neighbor_lattice):
+#    """
+#    Compute a list of globally inequavalent representatives for the genus of Q.
+#
+#    THIS SHOULD ONLY 
+#    """
+#    ## Sanity Check:  Base ring = ZZ only!
+#    if self.base_ring() != ZZ:
+#        raise NotImplementedError, "The genus representatives routine is only implemented over the base ring ZZ."
+#
+#
+#    ## Extend the known representatives with p-neighbor graphs until
+#    ## we exhaust the genus (either check that all adjacency row sums
+#    ## are of maximal degree, or use the mass formula).
+#    pass
+
+
+
+
+def p_neighbors_up_to_isometry(self, p, use_code="mass_check"):
+    """
+    Returns a list of p-neighbors up to isometry (i.e. integral equivalence).
+
+    QUESTIONS:  Which primes p are allowed?
+
+    INPUT:
+        p -- a prime number (with some restrictions???)
+
+    OUTPUT:
+        a list of quadratic forms
+
+    EXAMPLES:
+
+
+    """
+    ## Determine the algorithm to use
+    if use_code == "mass_check":
+        return self.p_neighbors_up_to_isometry__with_mass_check(p)     ## Default
+    elif use_code == "find_graph":
+        return self.p_neighbor_graph(p)[0]
+    else:
+        raise TypeError, " You entered an invalid use_code string.  Try using 'mass_check' (default) or 'find_graph' (somewhat slower)." 
+
+
+
+
+
+
+def p_neighbors_up_to_isometry__with_mass_check(self, p, known_distinct_representatives=[]):
+    """
+    Compute a graph of the isometry classes of p-neighbors with edges
+    given by the p-neighbor relation, allowing loops and multiplicities.
+
+
+    TO DO:  Fix the mass to give the spinor mass or the sum of to spinor masses!
+
+
+    INPUT:
+        p -- a prime number (currently we require that p not divide the Hessian determinant -- see below.)
+        known_distinct_reprsentatives -- these are required to be in different classes (i.e., pairwise globally inequivalent!).
+    
+    OUTPUT:
+        a pair (L, A) where L is a list of globally inequivalent quadratic forms, 
+        and A is the p-neighbor (symmetrix) adjacency matrix (with integer coeffs >= 0).
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+        sage: Q.p_neighbors_up_to_isometry__with_mass_check(3)
+        [Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 1 0 0 ]
+        [ * 1 0 ]
+        [ * * 1 ]
+        ]
+
+    """
+    ## Setup the initial neighbor list
+    if known_distinct_representatives == []:
+        Neighbor_list = [self]
+    else:
+        Neighbor_list = deepcopy(known_distinct_representatives)     ## Note: We allow known representatives for genus and spinor genus enumeration.
+    N_len = len(Neighbor_list)
+    n = self.dim()
+
+
+    ## Setup Inital Mass info (TO DO: Presently we are incorrectly assuming that the total_neighbor_mass is the genus mass)
+    total_neighbor_mass = self.conway_mass()
+    auto_list = [ZZ(1) / Q.number_of_automorphisms()  for Q in Neighbor_list]
+    partial_neighbor_mass = sum(auto_list)
+
+
+    ## Setup the initial p-neighbor multiplicity
+    if self.det() % p != 0:
+        p_neighbor_multiplicity = ZZ(p**(n-1) - 1) / ZZ(p-1) 
+    else:
+        raise NotImplementedError, "We need to find the p_neighbor_multiplicity from the dimension of the maximal non-degernrate subspace of Q over F_p."
+        p_neighbor_multiplicity = -1    ## TO DO: WE NEED TO SET THIS!!!!!!!!!!!!!!!!!!!!!!!!!
+
+
+
+
+
+    ## Run through all neighbors of all lattices until we're done!
+    i = 0
+    while i < len(Neighbor_list):
+
+        ## Set the starting form and run through all of its neighbors
+        Q_start = Neighbor_list[i]
+        num_of_i_neighbors_found = 0
+
+        ## If there are no more neighbors to find, then move to the next form to look for neighbors
+        if True:
+            for v in normalized_finite_projective_space_generator(Q_start.dim(), p):
+                try:
+                    Q_neighbor = Q_start.compute_p_neighbor_from_vector(p, v)
+                
+                    ## Run through all neighbors looking for an isometry
+                    new_flag = True
+                    num_of_i_neighbors_found += 1
+                    for j in range(len(Neighbor_list)):
+                    
+                        ## Record any isometries with known forms  (in the upper triangular entries of A)
+                        if Q_neighbor.is_globally_equivalent_to(Neighbor_list[j]):
+                            new_flag = False
+                            break              ## Don't test past one successful isometry
+
+                    ## If this form is new, record it and augment and increment the adjacency matrix (only upper-triangular entries)
+                    if new_flag:
+                        Neighbor_list.append(Q_neighbor)
+                        auto_list.append(ZZ(1) / Q_neighbor.number_of_automorphisms())
+                        partial_neighbor_mass = sum(auto_list)
+
+                    ## If there are no more neighbors to find, then move to the next form to look for neighbors
+                    if num_of_i_neighbors_found == p_neighbor_multiplicity:
+                        break
+
+                    ## If we have all representatives of this neighbor graph, then return with the representatives
+                    if total_neighbor_mass == partial_neighbor_mass:
+                        return Neighbor_list
+
+                ## Move to the next vector if we don't have a neighbor from v
+                except AttributeError: 
+                    pass
+
+
+        ## Increment the starting form
+        i += 1
+        #print " len(Neighbor_list) = ", len(Neighbor_list) 
+        #print "===============  Finishing i = ", i, " ================="
+
+
+
+    ## Return the list of neighbors and the adjacency matrix
+    return Neighbor_list
+
+
+
+
+
+
+
+
+
+def p_neighbor_graph(self, p, known_distinct_representatives=[], ignore_multiplicity_check=False):
+    """
+    Compute a graph of the isometry classes of p-neighbors with edges
+    given by the p-neighbor relation, allowing loops and multiplicities.
+
+    INPUT:
+        p -- a prime number (currently we require that p not divide the Hessian determinant -- see below.)
+        known_distinct_reprsentatives -- these are required to be in different classes (i.e., pairwise globally inequivalent!).
+    
+    OUTPUT:
+        a pair (L, A) where L is a list of globally inequivalent quadratic forms, 
+        and A is the p-neighbor (symmetrix) adjacency matrix (with integer coeffs >= 0).
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+        sage: Q.p_neighbor_graph(3)
+        ([Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 1 0 0 ]
+        [ * 1 0 ]
+        [ * * 1 ]
+        ],
+         [4])
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 48, 144])
+        sage: N5, A5 = Q.p_neighbor_graph(5,  ignore_multiplicity_check=True)
+        sage: len(N5)
+        4
+        sage: A5
+        [0 2 4 0]
+        [2 0 0 4]
+        [4 0 0 2]
+        [0 4 2 0]        
+        sage: N7, A7 = Q.p_neighbor_graph(7,  ignore_multiplicity_check=True)
+        sage: len(N7)
+        2
+        sage: A7
+        [4 4]
+        [4 4]
+
+    """
+    ## Setup the initial neighbor list and adjacency matrix
+    if known_distinct_representatives == []:
+        Neighbor_list = [self]
+    else:
+        Neighbor_list = deepcopy(known_distinct_representatives)     ## Note: We allow known representatives for genus and spinor genus enumeration.
+    N_len = len(Neighbor_list)
+    A = Matrix(ZZ, N_len, N_len, 0)            ## Adjacency_matrix
+    small_zero_matrix = Matrix(ZZ, 1, 1, 0)
+
+
+    ## Find the p-neighbor multiplicity (if we use it)
+    n = self.dim()
+    if not ignore_multiplicity_check:
+        if self.det() % p != 0:
+            p_neighbor_multiplicity = ZZ(p**(n-1) - 1) / ZZ(p-1) 
+        else:
+            raise NotImplementedError, "We need to find the p_neighbor_multiplicity from the dimension of the maximal non-degernrate subspace of Q over F_p."
+            p_neighbor_multiplicity = -1    ## TO DO: WE NEED TO SET THIS!!!!!!!!!!!!!!!!!!!!!!!!!
+
+
+    ## Run through all neighbors of all lattices until we're done!
+    i = 0
+    while i < len(Neighbor_list):
+
+        ## Set the starting form and run through all of its neighbors
+        Q_start = Neighbor_list[i]
+        if not ignore_multiplicity_check:
+            i_multiplicity_sum = sum([A[i, s]  for s in range(A.ncols())])
+            #print "p_neighbor_mutliplicity = ", p_neighbor_multiplicity
+            #print "i_mutliplicity_sum = ", i_multiplicity_sum
+
+
+        ## If there are no more neighbors to find, then move to the next form to look for neighbors
+        if ignore_multiplicity_check or ((not ignore_multiplicity_check) and (i_multiplicity_sum != p_neighbor_multiplicity)):
+            for v in normalized_finite_projective_space_generator(Q_start.dim(), p):
+                try:
+                    Q_neighbor = Q_start.compute_p_neighbor_from_vector(p, v)
+                
+                    ## Run through all neighbors looking for an isometry
+                    new_flag = True
+                    for j in range(len(Neighbor_list)):
+                    
+                        ## Record any isometries with known forms  (in the upper triangular entries of A)
+                        if Q_neighbor.is_globally_equivalent_to(Neighbor_list[j]):
+                            new_flag = False
+                            if i <= j:
+                                if not ignore_multiplicity_check:
+                                    i_multiplicity_sum += 1          ## Count only the new neighbor edges
+                                A[i, j] += 1
+                            break              ## Don't test past one successful isometry
+
+                    ## If this form is new, record it and augment and increment the adjacency matrix (only upper-triangular entries)
+                    if new_flag:
+                        Neighbor_list.append(Q_neighbor)
+                        A = A.block_sum(small_zero_matrix)
+                        if not ignore_multiplicity_check:
+                            i_multiplicity_sum += 1                
+                        A[i, -1] += 1
+
+
+                    if not ignore_multiplicity_check:
+                        #print "p_neighbor_mutliplicity = ", p_neighbor_multiplicity
+                        #print "i_mutliplicity_sum = ", i_multiplicity_sum
+                        pass
+
+
+                    ## If there are no more neighbors to find, then move to the next form to look for neighbors
+                    if (not ignore_multiplicity_check) and (i_multiplicity_sum == p_neighbor_multiplicity):
+                        break
+
+                ## Move to the next vector if we don't have a neighbor from v
+                except AttributeError: 
+                    pass
+
+
+        ## Increment the starting form
+        i += 1
+        #print " len(Neighbor_list) = ", len(Neighbor_list) 
+        #print "===============  Finishing i = ", i, " ================="
+
+
+    ## Symmetrize the (presently upper-triangular) adjacency matrix
+    for i in range(1, A.nrows()):
+        for j in range(i):
+            A[i,j] = A[j,i]
+
+
+    ## Return the list of neighbors and the adjacency matrix
+    return Neighbor_list, A
+
+
+
+
+
+
+
+
+
+
+def compute_p_neighbor_once(self, p):
+    """
+    Compute exactly one p-neighbor of the given quadratic form.
+
+    RESTRICTIONS ON p???
+
+    """
+    ## TO DO: ADD SANITY CHECKS FOR THE PRIME p.
+
+
+    ## Look for the first p-neighbor form
+    for v in normalized_finite_projective_space_generator(Q_start.dim(), p):
+
+        ## Try to compute a p-neighboring form from the vector v
+        try:
+            Q_neighbor = Q_start.compute_p_neighbor_from_vector(p, v)
+ 
+        ## Move to the next vector if we don't have a neighbor from v
+        except AttributeError: 
+            pass
+
+        ## Return the p-neighbor if we have one
+        if Q_neighbor != None:
+            return Q_neighbor
+
+
+
+
+
+
+
+
+
+## ----------------------------------------------------------------------------------------------------------------------
+
+
+## Routines from the paper of Scharlau/Hempkemeier for finding neighbors.
+
+
+
+def compute_p_neighbors(self, p, return_vectors=False):
+    """
+    Compute a list of all the (p^(n-1) - 1) p-neighbors of the
+    current quadratic form.  
+
+    return_vectors -- boolean -- returns pairs [Q', v'] where v' is the normalized projective vector giving the p-neighbor Q' of Q.
+
+
+    TO DO: If a neighbor_index >0 and < p^n is passed, then the
+    p-neighbor associated to the staring with the vector   
+
+    EXAMPLES:
+    """
+    ## Make a list of p-neighbors naively, excluding those vectors which produce bad p-neighbor lattices.
+    Neighbor_list = []
+    for v in normalized_finite_projective_space_generator(self.dim(), p):
+        try:
+            Q_neighbor = self.compute_p_neighbor_from_vector(p, v)
+
+            if return_vectors:
+                Neighbor_list.append([Q_neighbor, v])
+            else:
+                Neighbor_list.append(Q_neighbor)
+        except AttributeError: 
+            pass
+
+    return Neighbor_list
+
+
+
+
+
+def compute_p_neighbor_from_vector(self, p, v, return_transformation=False):
+    """
+    Compute the p-neighbor of the current quadratic form associated to
+    the vector v, assuming that:
+
+        - p^2 divides Q(v) 
+        - v is not in p * (dual lattice of Z^n w.r.t. the Hessian bilinear form)
+        
+     (Note: A stronger condition is that p doesn't divide the Hessian determinant of Q)
+
+
+     INPUT:
+         return_transformation -- boolean -- returns the linear transformation.
+
+
+    TO DO: If a neighbor_index >0 and < p^n is passed, then the
+    p-neighbor associated to the staring with the vector   
+
+    EXAMPLES:
+    """
+    Q = self
+    n = Q.dim()
+    M = Q.matrix()
+
+
+    ## Sanity Checks:
+    ## --------------
+    #print
+    #print "Checking the vector v = ", v 
+    #print "Q(v) = ", Q(v)
+
+    ## TO DO: Perhaps check for primitivity or rescale the form?
+  
+      
+    ## Check if Q(v) = 0 (mod p) and <v,.> is not identically zero (mod p)  
+    ## (i.e., it is non-singular on the associated projective conic)
+    zero_vec = vector(n * [ZZ(0)])
+    if (Q(v) % p == 0) and ((vector(v) * M) % p != zero_vec):
+        #print "Found Q(v) = 0 (mod p) which is non-singular on the conic"
+        pass
+    else:
+        raise AttributeError, "The vector v isn't non-singular on the conic mod p."
+
+
+    #######################
+    ## This isn't required -- we can arrange for this (when p > 2?).
+    ############################################################################################################
+    ## Check that Q(v) = 0 (mod p^2), which is required for
+    ## integrality of the p-neighbor lattice.
+    #if Q(v) % p**2 == 0:
+    #    print "Q(v) = 0 (mod p^2), so the associated p-neighbor will be integer-valued."
+    #else:
+    #    raise AttributeError, "Q(v) = 0 (mod p^2), so the associated p-neighbor won't be integer-valued."
+    ############################################################################################################
+
+
+
+
+    ## STEP 1: Adjust the vector v to be isotropic mod p^2
+    ## ---------------------------------------------------
+
+    ## Find the index v_ind of the first non-zero coefficient of v (which should be 1 by our normalization convention)
+    for i in range(n):
+        if v[i] % p != 0:
+            if v[i] != 1:          ## This is just a safety check -- not needed at all.
+                raise RuntimeError, "Something is very wrong with the normalized vector "+ str(v) + \
+                    " -- it's first non-zero coeff should be 1."
+            v_ind = i
+            break
+
+    ## Find a basis vector e_m which has non-zero pairing with v (mod p)
+    v_pairing_vec = vector(v) * M
+    for i in range(n):
+        if (i != v_ind) and (v_pairing_vec[i] % p != 0):
+            v_pairing_non_singular_index = i
+            v_pairing_non_zero_basis_vec = vector([0  for j in range(i)] + [1] + [0  for j in range(i+1, n)])
+            vb_coeff = v_pairing_vec[i]
+            break
+
+    #print "v_pairing_vec = ", v_pairing_vec
+    #print "v_pairing_non_singular_index = ", v_pairing_non_singular_index
+    #print "v_pairing_non_zero_basis_vec = ", v_pairing_non_zero_basis_vec
+    #print "vb_coeff = ", vb_coeff
+            
+            
+
+
+    ## Adjust v (to a new vector v1) so that Q(v1) = 0 (mod p^2) 
+    ## by adding a multiple of an independent basis vector
+    ## whose bilinear pairing with v doesn't vanish
+    c = -Q(v) / (p * vb_coeff) % p
+    v1 = v + p * c * v_pairing_non_zero_basis_vec
+
+    #print "v1 = ", v1
+    #print "Q(v1) = ", Q(v1)
+
+
+    ## Check that Q(v1) = 0 (mod p^2)
+    if Q(v1) % p*p != 0:
+        raise RuntimeError, "The adjusted vector v1 is not isotropic mod p^2!"
+
+
+    ## STEP 2: Compute the associated p-neighbor
+    ## -----------------------------------------
+
+    ## Find the associated (non-integral) change of basis matrix
+    X = matrix(self.base_ring().fraction_field(), n, n, 1)
+    ns_ind = v_pairing_non_singular_index
+    for i in range(n):
+        if i == v_ind:
+            X.set_column(i, v1/p)     ## Scale v1 by 1/p
+        elif i == ns_ind:
+            X[i,i] = p                ## Scale the dual basis vector to v1 by p
+        else:
+            X[ns_ind,i] = -v_pairing_vec[i] / v_pairing_vec[ns_ind] % p     ## Arrange for an orthogonal basis to v (mod p) at most vectors.
+            
+    #print "X = ", X
+
+
+    ## Change basis to find the assiciated p-neighbor
+    #Q1 = Q((p * X).inverse())
+    Q1 = Q(p * X)
+    Q2 = Q1.scale_by_factor(1/(p*p))      ## TO DO:  Simplify this code when the coefficient_ring is separated from the equivalence_ring
+    #print
+    #print "Found the neighbor: ", Q2
+    #print
+
+
+    ## Return the p-neighbor
+    return Q2
+
+
+
+
+
+## ----------------------------------------------------------------------------------------------
+
+def find_p_neighbor_from_vec(self, p, v):
+    """
+    Finds the p-neighbor of this quadratic form associated to a given
+    vector v satisfying:
+        a) Q(v) = 0  (mod p)
+        b) v is a non-singular point of the conic Q(v) = 0 (mod p).
+
+    Reference:  Gonzalo Tornaria's Thesis, Thrm 3.5, p34.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ,[1,1,1,1])
+        sage: v = vector([0,2,1,1])
+        sage: X = Q.find_p_neighbor_from_vec(3,v); X
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 3 10 0 -4 ]
+        [ * 9 0 -6 ]
+        [ * * 1 0 ]
+        [ * * * 2 ]
+
+    """
+    R = self.base_ring()
+    n = self.dim()
+    B2 = self.matrix()
+
+    ## Find a (dual) vector w with B(v,w) != 0 (mod p)
+    v_dual = B2 * vector(v)     ## We want the dot product with this to not be divisible by 2*p.
+    y_ind = 0
+    while ((y_ind < n) and (v_dual[y_ind] % p) == 0):   ## Check the dot product for the std basis vectors!
+        y_ind += 1
+    if y_ind == n:
+        raise RuntimeError, "Oops!  One of the standard basis vectors should have worked."
+    w = vector([R(i == y_ind)  for i in range(n)])
+    vw_prod = (v * self.matrix()).dot_product(w)
+
+    ## DIAGNOSTIC
+    #if vw_prod == 0:
+    #   print "v = ", v
+    #   print "v_dual = ", v_dual
+    #   print "v_dual[y_ind] = ", v_dual[y_ind]
+    #   print "(v_dual[y_ind] % p) = ", (v_dual[y_ind] % p)
+    #   print "w = ", w
+    #   print "p = ", p
+    #   print "vw_prod = ", vw_prod
+    #   raise RuntimeError, "ERROR: Why is vw_prod = 0?"
+
+    ## DIAGNOSTIC
+    #print "v = ", v
+    #print "w = ", w
+    #print "vw_prod = ", vw_prod
+
+
+    ## Lift the vector v to a vector v1 s.t. Q(v1) = 0 (mod p^2)
+    s = self(v)
+    if (s % p**2 != 0):
+        al = (-s / (p * vw_prod)) % p
+        v1 = v + p * al * w
+        v1w_prod = (v1 * self.matrix()).dot_product(w)
+    else:
+        v1 = v
+        v1w_prod = vw_prod
+
+    ## DIAGNOSTIC
+    #if (s % p**2 != 0):
+    #    print "al = ", al
+    #print "v1 = ", v1
+    #print "v1w_prod = ", v1w_prod
+
+
+    ## Construct a special p-divisible basis to use for the p-neighbor switch
+    good_basis = extend_to_primitive([v1, w])
+    for i in range(2,n):
+        ith_prod = (good_basis[i] * self.matrix()).dot_product(v)
+        c = (ith_prod / v1w_prod) % p
+        good_basis[i] = good_basis[i] - c * w  ## Ensures that this extenstion has <v_i, v> = 0 (mod p)
+
+    ## DIAGNOSTIC
+    #print "original good_basis = ", good_basis
+
+    ## Perform the p-neighbor switch
+    good_basis[0]  = vector([x/p  for x in good_basis[0]])    ## Divide v1 by p
+    good_basis[1]  = good_basis[1] * p                          ## Multiply w by p
+
+    ## Return the associated quadratic form
+    M = matrix(good_basis)
+    new_Q = deepcopy(self)                        ## Note: This avoids a circular import of QuadraticForm!
+    new_Q.__init__(R, M * self.matrix() * M.transpose())
+    return new_Q
+    return QuadraticForm(R, M * self.matrix() * M.transpose())
+
+
+## ----------------------------------------------------------------------------------------------
+
+
+#def find_classes_in_genus(self):
+
+
diff -r 6ff544e9f318 -r 01ac57b92113 sage/quadratic_forms/quadratic_form__neighbors__OLD.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/quadratic_form__neighbors__OLD.py	Sat Jan 08 20:16:37 2011 -0500
@@ -0,0 +1,257 @@
+"""
+Neighbors
+"""
+from sage.modules.free_module_element import vector
+from sage.rings.integer_ring import ZZ
+from copy import deepcopy
+from sage.quadratic_forms.extras import extend_to_primitive
+from sage.matrix.constructor import matrix
+#from sage.quadratic_forms.quadratic_form import QuadraticForm    ## This creates a circular import! =(
+
+
+####################################################################################
+## Routines used for understanding p-neighbors, and computing classes in a genus. ##
+####################################################################################
+
+
+def find_primitive_p_divisible_vector__random(self, p):
+    """
+    Finds a random `p`-primitive vector in `L/pL` whose value is `p`-divisible.
+
+    .. note::
+    
+        Since there are about `p^{(n-2)}` of these lines, we have a `1/p`
+        chance of randomly finding an appropriate vector.
+
+    .. warning::
+    
+        If there are local obstructions for this to happen, then this algorithm
+        will never terminate... =(  We should check for this too!
+
+    EXAMPLES::
+    
+        sage: Q = QuadraticForm(ZZ, 2, [10,1,4])
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (1, 1)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (1, 0)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (2, 0)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (2, 2)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (3, 3)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (3, 3)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (2, 0)
+
+    """
+    n = self.dim()
+    v = vector([ZZ.random_element(p)  for i in range(n)])
+
+    ## Repeatedly choose random vectors, and evaluate until the value is p-divisible.
+    while True:
+        if (self(v) % p == 0) and (v != 0):         
+            return v
+        else: 
+            v[ZZ.random_element(n)] = ZZ.random_element(p)      ## Replace a random entry and try again.
+
+
+
+
+#def find_primitive_p_divisible_vector__all(self, p):
+#    """
+#    Finds all random p-primitive vectors (up to scaling) in L/pL whose
+#    value is p-divisible.
+#
+#    Note: Since there are about p^(n-2) of these lines, we should avoid this for large n.
+#    """
+#    pass
+
+
+def find_primitive_p_divisible_vector__next(self, p, v=None):
+    """
+    Finds the next `p`-primitive vector (up to scaling) in `L/pL` whose
+    value is `p`-divisible, where the last vector returned was `v`.  For
+    an intial call, no `v` needs to be passed.
+
+    Returns vectors whose last non-zero entry is normalized to 0 or 1 (so no
+    lines are counted repeatedly).  The ordering is by increasing the
+    first non-normalized entry.  If we have tested all (lines of)
+    vectors, then return None.
+
+    OUTPUT:
+        vector or None
+
+    EXAMPLES::
+    
+        sage: Q = QuadraticForm(ZZ, 2, [10,1,4])
+        sage: v = Q.find_primitive_p_divisible_vector__next(5); v
+        (1, 1)
+        sage: v = Q.find_primitive_p_divisible_vector__next(5, v); v
+        (1, 0)
+        sage: v = Q.find_primitive_p_divisible_vector__next(5, v); v
+
+
+    """
+    ## Initialize 
+    n = self.dim()
+    if v == None:
+        w = vector([ZZ(0) for i in range(n-1)] + [ZZ(1)])
+    else:
+        w = deepcopy(v)
+
+
+    ## Handle n = 1 separately.
+    if n <= 1:
+        raise RuntimeError, "Sorry -- Not implemented yet!"
+
+
+    ## Look for the last non-zero entry (which must be 1)
+    nz = n - 1
+    while w[nz] == 0:
+        nz += -1
+
+    ## Test that the last non-zero entry is 1 (to detect tampering).
+    if w[nz] != 1:
+        print "Warning: The input vector to QuadraticForm.find_primitive_p_divisible_vector__next() is not normalized properly."
+
+
+
+    ## Look for the next vector, until w == 0
+    while True:
+
+
+        ## Look for the first non-maximal (non-normalized) entry
+        ind = 0
+        while (ind < nz) and (w[ind] == p-1):
+            ind += 1
+
+        #print ind, nz, w
+
+        ## Increment 
+        if (ind < nz):
+            w[ind] += 1
+            for j in range(ind):
+                w[j] = 0        
+        else:  
+            for j in range(ind+1):    ## Clear all entries
+                w[j] = 0        
+
+            if nz != 0:               ## Move the non-zero normalized index over by one, or return the zero vector
+                w[nz-1] = 1
+                nz += -1
+
+
+        ## Test for zero vector
+        if w == 0:
+            return None
+
+        ## Test for p-divisibility
+        if (self(w) % p == 0):
+            return w
+
+
+
+
+## ----------------------------------------------------------------------------------------------
+
+def find_p_neighbor_from_vec(self, p, v):
+    """
+    Finds the `p`-neighbor of this quadratic form associated to a given
+    vector `v` satisfying:
+
+    #. `Q(v) = 0  \pmod p`
+    #. `v` is a non-singular point of the conic `Q(v) = 0 \pmod p`.
+
+    Reference:  Gonzalo Tornaria's Thesis, Thrm 3.5, p34.
+
+    EXAMPLES::
+    
+        sage: Q = DiagonalQuadraticForm(ZZ,[1,1,1,1])
+        sage: v = vector([0,2,1,1])
+        sage: X = Q.find_p_neighbor_from_vec(3,v); X
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 3 10 0 -4 ]
+        [ * 9 0 -6 ]
+        [ * * 1 0 ]
+        [ * * * 2 ]
+
+    """
+    R = self.base_ring()
+    n = self.dim()
+    B2 = self.matrix()
+
+    ## Find a (dual) vector w with B(v,w) != 0 (mod p)
+    v_dual = B2 * vector(v)     ## We want the dot product with this to not be divisible by 2*p.
+    y_ind = 0
+    while ((y_ind < n) and (v_dual[y_ind] % p) == 0):   ## Check the dot product for the std basis vectors!
+        y_ind += 1
+    if y_ind == n:
+        raise RuntimeError, "Oops!  One of the standard basis vectors should have worked."
+    w = vector([R(i == y_ind)  for i in range(n)])
+    vw_prod = (v * self.matrix()).dot_product(w)
+
+    ## DIAGNOSTIC
+    #if vw_prod == 0:
+    #   print "v = ", v
+    #   print "v_dual = ", v_dual
+    #   print "v_dual[y_ind] = ", v_dual[y_ind]
+    #   print "(v_dual[y_ind] % p) = ", (v_dual[y_ind] % p)
+    #   print "w = ", w
+    #   print "p = ", p
+    #   print "vw_prod = ", vw_prod
+    #   raise RuntimeError, "ERROR: Why is vw_prod = 0?"
+
+    ## DIAGNOSTIC
+    #print "v = ", v
+    #print "w = ", w
+    #print "vw_prod = ", vw_prod
+
+
+    ## Lift the vector v to a vector v1 s.t. Q(v1) = 0 (mod p^2)
+    s = self(v)
+    if (s % p**2 != 0):
+        al = (-s / (p * vw_prod)) % p
+        v1 = v + p * al * w
+        v1w_prod = (v1 * self.matrix()).dot_product(w)
+    else:
+        v1 = v
+        v1w_prod = vw_prod
+
+    ## DIAGNOSTIC
+    #if (s % p**2 != 0):
+    #    print "al = ", al
+    #print "v1 = ", v1
+    #print "v1w_prod = ", v1w_prod
+
+
+    ## Construct a special p-divisible basis to use for the p-neighbor switch
+    good_basis = extend_to_primitive([v1, w])
+    for i in range(2,n):
+        ith_prod = (good_basis[i] * self.matrix()).dot_product(v)
+        c = (ith_prod / v1w_prod) % p
+        good_basis[i] = good_basis[i] - c * w  ## Ensures that this extenstion has <v_i, v> = 0 (mod p)
+
+    ## DIAGNOSTIC
+    #print "original good_basis = ", good_basis
+
+    ## Perform the p-neighbor switch
+    good_basis[0]  = vector([x/p  for x in good_basis[0]])    ## Divide v1 by p
+    good_basis[1]  = good_basis[1] * p                          ## Multiply w by p
+
+    ## Return the associated quadratic form
+    M = matrix(good_basis)
+    new_Q = deepcopy(self)                        ## Note: This avoids a circular import of QuadraticForm!
+    new_Q.__init__(R, M * self.matrix() * M.transpose())
+    return new_Q
+    return QuadraticForm(R, M * self.matrix() * M.transpose())
+
+
+## ----------------------------------------------------------------------------------------------
+
+
+#def find_classes_in_genus(self):
+
+
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1294546708 18000
# Node ID b4a2b705be3a007ea6b064a3314a96d022fe5672
# Parent  01ac57b921138a0e011be0c2f2fb6641fbe39ad6
Got the neighbor code working, and (by hand) installed the Souvigner binaries!

diff -r 01ac57b92113 -r b4a2b705be3a sage/quadratic_forms/quadratic_form.py
--- a/sage/quadratic_forms/quadratic_form.py	Sat Jan 08 20:16:37 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form.py	Sat Jan 08 23:18:28 2011 -0500
@@ -302,8 +302,13 @@
 
     ## Routines to compute p-neighbors
     from sage.quadratic_forms.quadratic_form__neighbors import \
-            find_p_neighbor_from_vec
-
+            p_neighbors_up_to_isometry, \
+            p_neighbors_up_to_isometry__with_mass_check, \
+            p_neighbor_graph, \
+            compute_p_neighbor_once, \
+            compute_p_neighbors, \
+            compute_p_neighbor_from_vector
+            
     ## Routines to reduce a given quadratic form
     from sage.quadratic_forms.quadratic_form__reduction_theory import \
             reduced_binary_form1, \
@@ -311,6 +316,7 @@
             reduced_binary_form, \
             minkowski_reduction, \
             minkowski_reduction_for_4vars__SP
+    
     ## Wrappers for Conway-Sloane genus routines (in ./genera/)
     from sage.quadratic_forms.quadratic_form__genus import \
             global_genus_symbol, \
diff -r 01ac57b92113 -r b4a2b705be3a sage/quadratic_forms/quadratic_form__automorphisms.py
--- a/sage/quadratic_forms/quadratic_form__automorphisms.py	Sat Jan 08 20:16:37 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form__automorphisms.py	Sat Jan 08 23:18:28 2011 -0500
@@ -355,6 +355,12 @@
 
 
 
+###################
+   ## TO DO:  Be sure to fix the SOUVIGNER CODE binaries, and change the 'use_code="Souvigner"' below!
+###################
+
+
+
 
 def number_of_automorphisms(self, recompute=False, use_code="Souvigner"):
     """
@@ -439,6 +445,7 @@
         3840
     
     """
+    
     ## Write an input text file
     F_filename = '/tmp/tmp_isom_input' + str(random()) + ".txt"
     F = open(F_filename, 'w')
diff -r 01ac57b92113 -r b4a2b705be3a sage/quadratic_forms/quadratic_form__genus_enumeration.py
--- a/sage/quadratic_forms/quadratic_form__genus_enumeration.py	Sat Jan 08 20:16:37 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form__genus_enumeration.py	Sat Jan 08 23:18:28 2011 -0500
@@ -11,7 +11,7 @@
 
 
 
-
+ 
 
 
 
@@ -119,10 +119,12 @@
     reps_auto_list = [ZZ(1)/Q.number_of_automorphisms()  for Q in genus_reps_list]
     mass_of_reps = sum(reps_auto_list)
 
-     
+    print "reps_auto_list = " + str(reps_auto_list)
+    print "mass_of_reps = " + str(mass_of_reps)
+    print "mass = " + str(mass)
 
 
-    ## Look for primes where one p-neighbors gives an new inequivalent form, until the mass formula is satisfied
+    ## Look for primes where some p-neighbor gives a new (inequivalent) form, until the mass formula is satisfied
     new_prime_list = []
     for p in prime_range(next_prime(p_initial), 200):                              ## THIS IS AWFUL -- CHANGE THIS TO HAVE AN EXIT CONDITION!
 
@@ -135,19 +137,23 @@
                 ", which have reciprocal automorphism sizes " + str(reps_auto_list) + "."
 
         ## Generate a p-neighbor
-        tmp_neighbor = self.p_neighbor_once(p)
+        tmp_neighbor = self.compute_p_neighbor_once(p)
+
+        print "Found some p-neighbor for p = " + str(p)
 
         ## Test that it is not isometric to any known forms
-        new_flag = True
-        if tmp_neighbor.is_globally_equivalent_to(genus_reps_list[j]):
-            new_flag = False
-            break              ## Don't test past one successful isometry      
+        new_genus_rep = True
+        for rep in genus_reps_list:
+            if tmp_neighbor.is_globally_equivalent_to(rep):
+                new_genus_rep = False
+                break              ## Don't test past one successful isometry      
 
         ## Generate its p_initial neighbors if we get a new form.
-        new_prime_list.append(p)
-        new_reps_list = tmp_neighbor.p_neighbors_up_to_isometry(p)
-        reps_auto_list += [Q.number_of_automorphisms()  for Q in new_reps_list]
-        mass_of_reps = sum(reps_auto_list)
+        if new_genus_rep:
+            new_prime_list.append(p)
+            new_reps_list = tmp_neighbor.p_neighbors_up_to_isometry(p)
+            reps_auto_list += [Q.number_of_automorphisms()  for Q in new_reps_list]
+            mass_of_reps = sum(reps_auto_list)
 
 
     ## Sanity Check:
diff -r 01ac57b92113 -r b4a2b705be3a sage/quadratic_forms/quadratic_form__neighbors.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/quadratic_forms/quadratic_form__neighbors.py	Sat Jan 08 23:18:28 2011 -0500
@@ -0,0 +1,542 @@
+
+from sage.rings.all import GF
+from sage.misc.functional import sqrt
+
+from sage.structure.element import is_Vector
+
+from sage.modules.free_module_element import vector
+from sage.rings.all import ZZ, QQ
+from copy import deepcopy
+
+from sage.matrix.constructor import Matrix
+
+from sage.quadratic_forms.extras import extend_to_primitive
+#from sage.quadratic_forms.maximal_extras import 
+#    even_sublattice_of_bilinear_gram_matrix, \
+#    find_basis_of_maximal_isotropic_subspace, \
+#    diagonalise_mod_2, \
+#    even_neighbor_of_bilinear_gram_matrix
+
+from sage.matrix.constructor import matrix
+#from sage.quadratic_forms.quadratic_form import QuadraticForm    ## This creates a circular import! =(
+
+from sage.rings.arith import prime_divisors
+
+from sage.quadratic_forms.projective_iterators import normalized_finite_projective_space_generator
+
+
+
+
+
+
+
+#def genus_representatives(self,  exhaust_neighbor_lattice):
+#    """
+#    Compute a list of globally inequavalent representatives for the genus of Q.
+#
+#    THIS SHOULD ONLY 
+#    """
+#    ## Sanity Check:  Base ring = ZZ only!
+#    if self.base_ring() != ZZ:
+#        raise NotImplementedError, "The genus representatives routine is only implemented over the base ring ZZ."
+#
+#
+#    ## Extend the known representatives with p-neighbor graphs until
+#    ## we exhaust the genus (either check that all adjacency row sums
+#    ## are of maximal degree, or use the mass formula).
+#    pass
+
+
+
+
+def p_neighbors_up_to_isometry(self, p, use_code="find_graph"):
+    """
+    Returns a list of p-neighbors up to isometry (i.e. integral equivalence).
+
+    QUESTIONS:  Which primes p are allowed?
+
+    INPUT:
+        p -- a prime number (with some restrictions???)
+
+    OUTPUT:
+        a list of quadratic forms
+
+    EXAMPLES:
+
+
+    """
+    ## Determine the algorithm to use
+    if use_code == "mass_check":
+        return self.p_neighbors_up_to_isometry__with_mass_check(p)     ## Default
+    elif use_code == "find_graph":
+        return self.p_neighbor_graph(p)[0]
+    else:
+        raise TypeError, " You entered an invalid use_code string.  Try using 'mass_check' (default) or 'find_graph' (somewhat slower)." 
+
+
+
+
+
+
+def p_neighbors_up_to_isometry__with_mass_check(self, p, known_distinct_representatives=[]):
+    """
+    Compute a graph of the isometry classes of p-neighbors with edges
+    given by the p-neighbor relation, allowing loops and multiplicities.
+
+
+    TO DO:  Fix the mass to give the spinor mass or the sum of to spinor masses!
+
+
+    INPUT:
+        p -- a prime number (currently we require that p not divide the Hessian determinant -- see below.)
+        known_distinct_reprsentatives -- these are required to be in different classes (i.e., pairwise globally inequivalent!).
+    
+    OUTPUT:
+        a pair (L, A) where L is a list of globally inequivalent quadratic forms, 
+        and A is the p-neighbor (symmetrix) adjacency matrix (with integer coeffs >= 0).
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+        sage: Q.p_neighbors_up_to_isometry__with_mass_check(3)
+        [Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 1 0 0 ]
+        [ * 1 0 ]
+        [ * * 1 ]
+        ]
+
+    """
+    ## Setup the initial neighbor list
+    if known_distinct_representatives == []:
+        Neighbor_list = [self]
+    else:
+        Neighbor_list = deepcopy(known_distinct_representatives)     ## Note: We allow known representatives for genus and spinor genus enumeration.
+    N_len = len(Neighbor_list)
+    n = self.dim()
+
+
+    ## Setup Inital Mass info (TO DO: Presently we are incorrectly assuming that the total_neighbor_mass is the genus mass)
+    total_neighbor_mass = self.conway_mass()
+    auto_list = [ZZ(1) / Q.number_of_automorphisms()  for Q in Neighbor_list]
+    partial_neighbor_mass = sum(auto_list)
+
+
+    ## Setup the initial p-neighbor multiplicity
+    if self.det() % p != 0:
+        p_neighbor_multiplicity = ZZ(p**(n-1) - 1) / ZZ(p-1) 
+    else:
+        raise NotImplementedError, "We need to find the p_neighbor_multiplicity from the dimension of the maximal non-degernrate subspace of Q over F_p."
+        p_neighbor_multiplicity = -1    ## TO DO: WE NEED TO SET THIS!!!!!!!!!!!!!!!!!!!!!!!!!
+
+
+
+
+
+    ## Run through all neighbors of all lattices until we're done!
+    i = 0
+    while i < len(Neighbor_list):
+
+        ## Set the starting form and run through all of its neighbors
+        Q_start = Neighbor_list[i]
+        num_of_i_neighbors_found = 0
+
+        ## If there are no more neighbors to find, then move to the next form to look for neighbors
+        if True:
+            for v in normalized_finite_projective_space_generator(Q_start.dim(), p):
+                try:
+                    Q_neighbor = Q_start.compute_p_neighbor_from_vector(p, v)
+                
+                    ## Run through all neighbors looking for an isometry
+                    new_flag = True
+                    num_of_i_neighbors_found += 1
+                    for j in range(len(Neighbor_list)):
+                    
+                        ## Record any isometries with known forms  (in the upper triangular entries of A)
+                        if Q_neighbor.is_globally_equivalent_to(Neighbor_list[j]):
+                            new_flag = False
+                            break              ## Don't test past one successful isometry
+
+                    ## If this form is new, record it and augment and increment the adjacency matrix (only upper-triangular entries)
+                    if new_flag:
+                        Neighbor_list.append(Q_neighbor)
+                        auto_list.append(ZZ(1) / Q_neighbor.number_of_automorphisms())
+                        partial_neighbor_mass = sum(auto_list)
+
+                    ## If there are no more neighbors to find, then move to the next form to look for neighbors
+                    if num_of_i_neighbors_found == p_neighbor_multiplicity:
+                        break
+
+                    ## If we have all representatives of this neighbor graph, then return with the representatives
+                    if total_neighbor_mass == partial_neighbor_mass:
+                        return Neighbor_list
+                    elif (total_neighbor_mass < partial_neighbor_mass):
+                        raise RuntimeError, "There is a problem with the mass formula -- we have more than the allowed mass!"
+
+                ## Move to the next vector if we don't have a neighbor from v
+                except AttributeError: 
+                    pass
+
+
+        ## Increment the starting form
+        i += 1
+        #print " len(Neighbor_list) = ", len(Neighbor_list) 
+        #print "===============  Finishing i = ", i, " ================="
+
+
+
+    ## Return the list of neighbors and the adjacency matrix
+    return Neighbor_list
+
+
+
+
+
+
+
+
+
+def p_neighbor_graph(self, p, known_distinct_representatives=[], ignore_multiplicity_check=False):
+    """
+    Compute a graph of the isometry classes of p-neighbors with edges
+    given by the p-neighbor relation, allowing loops and multiplicities.
+
+    INPUT:
+        p -- a prime number (currently we require that p not divide the Hessian determinant -- see below.)
+        known_distinct_reprsentatives -- these are required to be in different classes (i.e., pairwise globally inequivalent!).
+    
+    OUTPUT:
+        a pair (L, A) where L is a list of globally inequivalent quadratic forms, 
+        and A is the p-neighbor (symmetrix) adjacency matrix (with integer coeffs >= 0).
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+        sage: Q.p_neighbor_graph(3)
+        ([Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 1 0 0 ]
+        [ * 1 0 ]
+        [ * * 1 ]
+        ],
+         [4])
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 48, 144])
+        sage: N5, A5 = Q.p_neighbor_graph(5,  ignore_multiplicity_check=True)
+        sage: len(N5)
+        4
+        sage: A5
+        [0 2 4 0]
+        [2 0 0 4]
+        [4 0 0 2]
+        [0 4 2 0]        
+        sage: N7, A7 = Q.p_neighbor_graph(7,  ignore_multiplicity_check=True)
+        sage: len(N7)
+        2
+        sage: A7
+        [4 4]
+        [4 4]
+
+    """
+    ## Setup the initial neighbor list and adjacency matrix
+    if known_distinct_representatives == []:
+        Neighbor_list = [self]
+    else:
+        Neighbor_list = deepcopy(known_distinct_representatives)     ## Note: We allow known representatives for genus and spinor genus enumeration.
+    N_len = len(Neighbor_list)
+    A = Matrix(ZZ, N_len, N_len, 0)            ## Adjacency_matrix
+    small_zero_matrix = Matrix(ZZ, 1, 1, 0)
+
+
+    ## Find the p-neighbor multiplicity (if we use it)
+    n = self.dim()
+    if not ignore_multiplicity_check:
+        if self.det() % p != 0:
+            p_neighbor_multiplicity = ZZ(p**(n-1) - 1) / ZZ(p-1) 
+        else:
+            raise NotImplementedError, "We need to find the p_neighbor_multiplicity from the dimension of the maximal non-degernrate subspace of Q over F_p."
+            p_neighbor_multiplicity = -1    ## TO DO: WE NEED TO SET THIS!!!!!!!!!!!!!!!!!!!!!!!!!
+
+
+    ## Run through all neighbors of all lattices until we're done!
+    i = 0
+    while i < len(Neighbor_list):
+
+        ## Set the starting form and run through all of its neighbors
+        Q_start = Neighbor_list[i]
+        if not ignore_multiplicity_check:
+            i_multiplicity_sum = sum([A[i, s]  for s in range(A.ncols())])
+            #print "p_neighbor_mutliplicity = ", p_neighbor_multiplicity
+            #print "i_mutliplicity_sum = ", i_multiplicity_sum
+
+
+        ## If there are no more neighbors to find, then move to the next form to look for neighbors
+        if ignore_multiplicity_check or ((not ignore_multiplicity_check) and (i_multiplicity_sum != p_neighbor_multiplicity)):
+            for v in normalized_finite_projective_space_generator(Q_start.dim(), p):
+                try:
+                    Q_neighbor = Q_start.compute_p_neighbor_from_vector(p, v)
+                
+                    ## Run through all neighbors looking for an isometry
+                    new_flag = True
+                    for j in range(len(Neighbor_list)):
+                    
+                        ## Record any isometries with known forms  (in the upper triangular entries of A)
+                        if Q_neighbor.is_globally_equivalent_to(Neighbor_list[j]):
+                            new_flag = False
+                            if i <= j:
+                                if not ignore_multiplicity_check:
+                                    i_multiplicity_sum += 1          ## Count only the new neighbor edges
+                                A[i, j] += 1
+                            break              ## Don't test past one successful isometry
+
+                    ## If this form is new, record it and augment and increment the adjacency matrix (only upper-triangular entries)
+                    if new_flag:
+                        Neighbor_list.append(Q_neighbor)
+                        A = A.block_sum(small_zero_matrix)
+                        if not ignore_multiplicity_check:
+                            i_multiplicity_sum += 1                
+                        A[i, -1] += 1
+
+
+                    if not ignore_multiplicity_check:
+                        #print "p_neighbor_mutliplicity = ", p_neighbor_multiplicity
+                        #print "i_mutliplicity_sum = ", i_multiplicity_sum
+                        pass
+
+
+                    ## If there are no more neighbors to find, then move to the next form to look for neighbors
+                    if (not ignore_multiplicity_check) and (i_multiplicity_sum == p_neighbor_multiplicity):
+                        break
+
+                ## Move to the next vector if we don't have a neighbor from v
+                except AttributeError: 
+                    pass
+
+
+        ## Increment the starting form
+        i += 1
+        #print " len(Neighbor_list) = ", len(Neighbor_list) 
+        #print "===============  Finishing i = ", i, " ================="
+
+
+    ## Symmetrize the (presently upper-triangular) adjacency matrix
+    for i in range(1, A.nrows()):
+        for j in range(i):
+            A[i,j] = A[j,i]
+
+
+    ## Return the list of neighbors and the adjacency matrix
+    return Neighbor_list, A
+
+
+
+
+
+
+
+
+
+
+def compute_p_neighbor_once(self, p):
+    """
+    Compute exactly one p-neighbor of the given quadratic form.
+
+    RESTRICTIONS ON p???
+
+    """
+    ## TO DO: ADD SANITY CHECKS FOR THE PRIME p.
+
+
+    ## Look for the first p-neighbor form
+    for v in normalized_finite_projective_space_generator(self.dim(), p):
+
+        ## Try to compute a p-neighboring form from the vector v
+        try:
+            Q_neighbor = self.compute_p_neighbor_from_vector(p, v)
+ 
+        ## Move to the next vector if we don't have a neighbor from v
+        except AttributeError: 
+            Q_neighbor = None
+
+        ## Return the p-neighbor if we have one
+        if Q_neighbor != None:
+            return Q_neighbor
+
+
+
+
+
+
+
+
+
+## ----------------------------------------------------------------------------------------------------------------------
+
+
+## Routines from the paper of Scharlau/Hempkemeier for finding neighbors.
+
+
+
+def compute_p_neighbors(self, p, return_vectors=False):
+    """
+    Compute a list of all the (p^(n-1) - 1) p-neighbors of the
+    current quadratic form.  
+
+    return_vectors -- boolean -- returns pairs [Q', v'] where v' is the normalized projective vector giving the p-neighbor Q' of Q.
+
+
+    TO DO: If a neighbor_index >0 and < p^n is passed, then the
+    p-neighbor associated to the staring with the vector   
+
+    EXAMPLES:
+    """
+    ## Make a list of p-neighbors naively, excluding those vectors which produce bad p-neighbor lattices.
+    Neighbor_list = []
+    for v in normalized_finite_projective_space_generator(self.dim(), p):
+        try:
+            Q_neighbor = self.compute_p_neighbor_from_vector(p, v)
+
+            if return_vectors:
+                Neighbor_list.append([Q_neighbor, v])
+            else:
+                Neighbor_list.append(Q_neighbor)
+        except AttributeError: 
+            pass
+
+    return Neighbor_list
+
+
+
+
+
+def compute_p_neighbor_from_vector(self, p, v, return_transformation=False):
+    """
+    Compute the p-neighbor of the current quadratic form associated to
+    the vector v, assuming that:
+
+        - p^2 divides Q(v) 
+        - v is not in p * (dual lattice of Z^n w.r.t. the Hessian bilinear form)
+        
+     (Note: A stronger condition is that p doesn't divide the Hessian determinant of Q)
+
+
+     INPUT:
+         return_transformation -- boolean -- returns the linear transformation.
+
+
+    TO DO: If a neighbor_index >0 and < p^n is passed, then the
+    p-neighbor associated to the staring with the vector   
+
+    EXAMPLES:
+    """
+    Q = self
+    n = Q.dim()
+    M = Q.matrix()
+
+
+    ## Sanity Checks:
+    ## --------------
+    #print
+    #print "Checking the vector v = ", v 
+    #print "Q(v) = ", Q(v)
+
+    ## TO DO: Perhaps check for primitivity or rescale the form?
+  
+      
+    ## Check if Q(v) = 0 (mod p) and <v,.> is not identically zero (mod p)  
+    ## (i.e., it is non-singular on the associated projective conic)
+    zero_vec = vector(n * [ZZ(0)])
+    if (Q(v) % p == 0) and ((vector(v) * M) % p != zero_vec):
+        #print "Found Q(v) = 0 (mod p) which is non-singular on the conic"
+        pass
+    else:
+        raise AttributeError, "The vector v isn't non-singular on the conic mod p."
+
+
+    #######################
+    ## This isn't required -- we can arrange for this (when p > 2?).
+    ############################################################################################################
+    ## Check that Q(v) = 0 (mod p^2), which is required for
+    ## integrality of the p-neighbor lattice.
+    #if Q(v) % p**2 == 0:
+    #    print "Q(v) = 0 (mod p^2), so the associated p-neighbor will be integer-valued."
+    #else:
+    #    raise AttributeError, "Q(v) = 0 (mod p^2), so the associated p-neighbor won't be integer-valued."
+    ############################################################################################################
+
+
+
+
+    ## STEP 1: Adjust the vector v to be isotropic mod p^2
+    ## ---------------------------------------------------
+
+    ## Find the index v_ind of the first non-zero coefficient of v (which should be 1 by our normalization convention)
+    for i in range(n):
+        if v[i] % p != 0:
+            if v[i] != 1:          ## This is just a safety check -- not needed at all.
+                raise RuntimeError, "Something is very wrong with the normalized vector "+ str(v) + \
+                    " -- it's first non-zero coeff should be 1."
+            v_ind = i
+            break
+
+    ## Find a basis vector e_m which has non-zero pairing with v (mod p)
+    v_pairing_vec = vector(v) * M
+    for i in range(n):
+        if (i != v_ind) and (v_pairing_vec[i] % p != 0):
+            v_pairing_non_singular_index = i
+            v_pairing_non_zero_basis_vec = vector([0  for j in range(i)] + [1] + [0  for j in range(i+1, n)])
+            vb_coeff = v_pairing_vec[i]
+            break
+
+    #print "v_pairing_vec = ", v_pairing_vec
+    #print "v_pairing_non_singular_index = ", v_pairing_non_singular_index
+    #print "v_pairing_non_zero_basis_vec = ", v_pairing_non_zero_basis_vec
+    #print "vb_coeff = ", vb_coeff
+            
+            
+
+
+    ## Adjust v (to a new vector v1) so that Q(v1) = 0 (mod p^2) 
+    ## by adding a multiple of an independent basis vector
+    ## whose bilinear pairing with v doesn't vanish
+    c = -Q(v) / (p * vb_coeff) % p
+    v1 = v + p * c * v_pairing_non_zero_basis_vec
+
+    #print "v1 = ", v1
+    #print "Q(v1) = ", Q(v1)
+
+
+    ## Check that Q(v1) = 0 (mod p^2)
+    if Q(v1) % p*p != 0:
+        raise RuntimeError, "The adjusted vector v1 is not isotropic mod p^2!"
+
+
+    ## STEP 2: Compute the associated p-neighbor
+    ## -----------------------------------------
+
+    ## Find the associated (non-integral) change of basis matrix
+    X = matrix(self.base_ring().fraction_field(), n, n, 1)
+    ns_ind = v_pairing_non_singular_index
+    for i in range(n):
+        if i == v_ind:
+            X.set_column(i, v1/p)     ## Scale v1 by 1/p
+        elif i == ns_ind:
+            X[i,i] = p                ## Scale the dual basis vector to v1 by p
+        else:
+            X[ns_ind,i] = -v_pairing_vec[i] / v_pairing_vec[ns_ind] % p     ## Arrange for an orthogonal basis to v (mod p) at most vectors.
+            
+    #print "X = ", X
+
+
+    ## Change basis to find the assiciated p-neighbor
+    #Q1 = Q((p * X).inverse())
+    Q1 = Q(p * X)
+    Q2 = Q1.scale_by_factor(1/(p*p))      ## TO DO:  Simplify this code when the coefficient_ring is separated from the equivalence_ring
+    #print
+    #print "Found the neighbor: ", Q2
+    #print
+
+
+    ## Return the p-neighbor
+    return Q2
+
+
+
+
+
diff -r 01ac57b92113 -r b4a2b705be3a sage/quadratic_forms/quadratic_form__neighbors__NEW.py
--- a/sage/quadratic_forms/quadratic_form__neighbors__NEW.py	Sat Jan 08 20:16:37 2011 -0500
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,638 +0,0 @@
-
-from sage.rings.all import GF
-from sage.misc.functional import sqrt
-
-from sage.structure.element import is_Vector
-
-from sage.modules.free_module_element import vector
-from sage.rings.all import ZZ, QQ
-from copy import deepcopy
-
-from sage.matrix.constructor import Matrix
-
-from sage.quadratic_forms.extras import extend_to_primitive
-#from sage.quadratic_forms.maximal_extras import 
-#    even_sublattice_of_bilinear_gram_matrix, \
-#    find_basis_of_maximal_isotropic_subspace, \
-#    diagonalise_mod_2, \
-#    even_neighbor_of_bilinear_gram_matrix
-
-from sage.matrix.constructor import matrix
-#from sage.quadratic_forms.quadratic_form import QuadraticForm    ## This creates a circular import! =(
-
-from sage.rings.arith import prime_divisors
-
-from sage.quadratic_forms.projective_iterators import normalized_finite_projective_space_generator
-
-
-
-
-
-
-
-#def genus_representatives(self,  exhaust_neighbor_lattice):
-#    """
-#    Compute a list of globally inequavalent representatives for the genus of Q.
-#
-#    THIS SHOULD ONLY 
-#    """
-#    ## Sanity Check:  Base ring = ZZ only!
-#    if self.base_ring() != ZZ:
-#        raise NotImplementedError, "The genus representatives routine is only implemented over the base ring ZZ."
-#
-#
-#    ## Extend the known representatives with p-neighbor graphs until
-#    ## we exhaust the genus (either check that all adjacency row sums
-#    ## are of maximal degree, or use the mass formula).
-#    pass
-
-
-
-
-def p_neighbors_up_to_isometry(self, p, use_code="mass_check"):
-    """
-    Returns a list of p-neighbors up to isometry (i.e. integral equivalence).
-
-    QUESTIONS:  Which primes p are allowed?
-
-    INPUT:
-        p -- a prime number (with some restrictions???)
-
-    OUTPUT:
-        a list of quadratic forms
-
-    EXAMPLES:
-
-
-    """
-    ## Determine the algorithm to use
-    if use_code == "mass_check":
-        return self.p_neighbors_up_to_isometry__with_mass_check(p)     ## Default
-    elif use_code == "find_graph":
-        return self.p_neighbor_graph(p)[0]
-    else:
-        raise TypeError, " You entered an invalid use_code string.  Try using 'mass_check' (default) or 'find_graph' (somewhat slower)." 
-
-
-
-
-
-
-def p_neighbors_up_to_isometry__with_mass_check(self, p, known_distinct_representatives=[]):
-    """
-    Compute a graph of the isometry classes of p-neighbors with edges
-    given by the p-neighbor relation, allowing loops and multiplicities.
-
-
-    TO DO:  Fix the mass to give the spinor mass or the sum of to spinor masses!
-
-
-    INPUT:
-        p -- a prime number (currently we require that p not divide the Hessian determinant -- see below.)
-        known_distinct_reprsentatives -- these are required to be in different classes (i.e., pairwise globally inequivalent!).
-    
-    OUTPUT:
-        a pair (L, A) where L is a list of globally inequivalent quadratic forms, 
-        and A is the p-neighbor (symmetrix) adjacency matrix (with integer coeffs >= 0).
-
-    EXAMPLES:
-        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1, 1])
-        sage: Q.p_neighbors_up_to_isometry__with_mass_check(3)
-        [Quadratic form in 3 variables over Integer Ring with coefficients: 
-        [ 1 0 0 ]
-        [ * 1 0 ]
-        [ * * 1 ]
-        ]
-
-    """
-    ## Setup the initial neighbor list
-    if known_distinct_representatives == []:
-        Neighbor_list = [self]
-    else:
-        Neighbor_list = deepcopy(known_distinct_representatives)     ## Note: We allow known representatives for genus and spinor genus enumeration.
-    N_len = len(Neighbor_list)
-    n = self.dim()
-
-
-    ## Setup Inital Mass info (TO DO: Presently we are incorrectly assuming that the total_neighbor_mass is the genus mass)
-    total_neighbor_mass = self.conway_mass()
-    auto_list = [ZZ(1) / Q.number_of_automorphisms()  for Q in Neighbor_list]
-    partial_neighbor_mass = sum(auto_list)
-
-
-    ## Setup the initial p-neighbor multiplicity
-    if self.det() % p != 0:
-        p_neighbor_multiplicity = ZZ(p**(n-1) - 1) / ZZ(p-1) 
-    else:
-        raise NotImplementedError, "We need to find the p_neighbor_multiplicity from the dimension of the maximal non-degernrate subspace of Q over F_p."
-        p_neighbor_multiplicity = -1    ## TO DO: WE NEED TO SET THIS!!!!!!!!!!!!!!!!!!!!!!!!!
-
-
-
-
-
-    ## Run through all neighbors of all lattices until we're done!
-    i = 0
-    while i < len(Neighbor_list):
-
-        ## Set the starting form and run through all of its neighbors
-        Q_start = Neighbor_list[i]
-        num_of_i_neighbors_found = 0
-
-        ## If there are no more neighbors to find, then move to the next form to look for neighbors
-        if True:
-            for v in normalized_finite_projective_space_generator(Q_start.dim(), p):
-                try:
-                    Q_neighbor = Q_start.compute_p_neighbor_from_vector(p, v)
-                
-                    ## Run through all neighbors looking for an isometry
-                    new_flag = True
-                    num_of_i_neighbors_found += 1
-                    for j in range(len(Neighbor_list)):
-                    
-                        ## Record any isometries with known forms  (in the upper triangular entries of A)
-                        if Q_neighbor.is_globally_equivalent_to(Neighbor_list[j]):
-                            new_flag = False
-                            break              ## Don't test past one successful isometry
-
-                    ## If this form is new, record it and augment and increment the adjacency matrix (only upper-triangular entries)
-                    if new_flag:
-                        Neighbor_list.append(Q_neighbor)
-                        auto_list.append(ZZ(1) / Q_neighbor.number_of_automorphisms())
-                        partial_neighbor_mass = sum(auto_list)
-
-                    ## If there are no more neighbors to find, then move to the next form to look for neighbors
-                    if num_of_i_neighbors_found == p_neighbor_multiplicity:
-                        break
-
-                    ## If we have all representatives of this neighbor graph, then return with the representatives
-                    if total_neighbor_mass == partial_neighbor_mass:
-                        return Neighbor_list
-
-                ## Move to the next vector if we don't have a neighbor from v
-                except AttributeError: 
-                    pass
-
-
-        ## Increment the starting form
-        i += 1
-        #print " len(Neighbor_list) = ", len(Neighbor_list) 
-        #print "===============  Finishing i = ", i, " ================="
-
-
-
-    ## Return the list of neighbors and the adjacency matrix
-    return Neighbor_list
-
-
-
-
-
-
-
-
-
-def p_neighbor_graph(self, p, known_distinct_representatives=[], ignore_multiplicity_check=False):
-    """
-    Compute a graph of the isometry classes of p-neighbors with edges
-    given by the p-neighbor relation, allowing loops and multiplicities.
-
-    INPUT:
-        p -- a prime number (currently we require that p not divide the Hessian determinant -- see below.)
-        known_distinct_reprsentatives -- these are required to be in different classes (i.e., pairwise globally inequivalent!).
-    
-    OUTPUT:
-        a pair (L, A) where L is a list of globally inequivalent quadratic forms, 
-        and A is the p-neighbor (symmetrix) adjacency matrix (with integer coeffs >= 0).
-
-    EXAMPLES:
-        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1, 1])
-        sage: Q.p_neighbor_graph(3)
-        ([Quadratic form in 3 variables over Integer Ring with coefficients: 
-        [ 1 0 0 ]
-        [ * 1 0 ]
-        [ * * 1 ]
-        ],
-         [4])
-
-        sage: Q = DiagonalQuadraticForm(ZZ, [1, 48, 144])
-        sage: N5, A5 = Q.p_neighbor_graph(5,  ignore_multiplicity_check=True)
-        sage: len(N5)
-        4
-        sage: A5
-        [0 2 4 0]
-        [2 0 0 4]
-        [4 0 0 2]
-        [0 4 2 0]        
-        sage: N7, A7 = Q.p_neighbor_graph(7,  ignore_multiplicity_check=True)
-        sage: len(N7)
-        2
-        sage: A7
-        [4 4]
-        [4 4]
-
-    """
-    ## Setup the initial neighbor list and adjacency matrix
-    if known_distinct_representatives == []:
-        Neighbor_list = [self]
-    else:
-        Neighbor_list = deepcopy(known_distinct_representatives)     ## Note: We allow known representatives for genus and spinor genus enumeration.
-    N_len = len(Neighbor_list)
-    A = Matrix(ZZ, N_len, N_len, 0)            ## Adjacency_matrix
-    small_zero_matrix = Matrix(ZZ, 1, 1, 0)
-
-
-    ## Find the p-neighbor multiplicity (if we use it)
-    n = self.dim()
-    if not ignore_multiplicity_check:
-        if self.det() % p != 0:
-            p_neighbor_multiplicity = ZZ(p**(n-1) - 1) / ZZ(p-1) 
-        else:
-            raise NotImplementedError, "We need to find the p_neighbor_multiplicity from the dimension of the maximal non-degernrate subspace of Q over F_p."
-            p_neighbor_multiplicity = -1    ## TO DO: WE NEED TO SET THIS!!!!!!!!!!!!!!!!!!!!!!!!!
-
-
-    ## Run through all neighbors of all lattices until we're done!
-    i = 0
-    while i < len(Neighbor_list):
-
-        ## Set the starting form and run through all of its neighbors
-        Q_start = Neighbor_list[i]
-        if not ignore_multiplicity_check:
-            i_multiplicity_sum = sum([A[i, s]  for s in range(A.ncols())])
-            #print "p_neighbor_mutliplicity = ", p_neighbor_multiplicity
-            #print "i_mutliplicity_sum = ", i_multiplicity_sum
-
-
-        ## If there are no more neighbors to find, then move to the next form to look for neighbors
-        if ignore_multiplicity_check or ((not ignore_multiplicity_check) and (i_multiplicity_sum != p_neighbor_multiplicity)):
-            for v in normalized_finite_projective_space_generator(Q_start.dim(), p):
-                try:
-                    Q_neighbor = Q_start.compute_p_neighbor_from_vector(p, v)
-                
-                    ## Run through all neighbors looking for an isometry
-                    new_flag = True
-                    for j in range(len(Neighbor_list)):
-                    
-                        ## Record any isometries with known forms  (in the upper triangular entries of A)
-                        if Q_neighbor.is_globally_equivalent_to(Neighbor_list[j]):
-                            new_flag = False
-                            if i <= j:
-                                if not ignore_multiplicity_check:
-                                    i_multiplicity_sum += 1          ## Count only the new neighbor edges
-                                A[i, j] += 1
-                            break              ## Don't test past one successful isometry
-
-                    ## If this form is new, record it and augment and increment the adjacency matrix (only upper-triangular entries)
-                    if new_flag:
-                        Neighbor_list.append(Q_neighbor)
-                        A = A.block_sum(small_zero_matrix)
-                        if not ignore_multiplicity_check:
-                            i_multiplicity_sum += 1                
-                        A[i, -1] += 1
-
-
-                    if not ignore_multiplicity_check:
-                        #print "p_neighbor_mutliplicity = ", p_neighbor_multiplicity
-                        #print "i_mutliplicity_sum = ", i_multiplicity_sum
-                        pass
-
-
-                    ## If there are no more neighbors to find, then move to the next form to look for neighbors
-                    if (not ignore_multiplicity_check) and (i_multiplicity_sum == p_neighbor_multiplicity):
-                        break
-
-                ## Move to the next vector if we don't have a neighbor from v
-                except AttributeError: 
-                    pass
-
-
-        ## Increment the starting form
-        i += 1
-        #print " len(Neighbor_list) = ", len(Neighbor_list) 
-        #print "===============  Finishing i = ", i, " ================="
-
-
-    ## Symmetrize the (presently upper-triangular) adjacency matrix
-    for i in range(1, A.nrows()):
-        for j in range(i):
-            A[i,j] = A[j,i]
-
-
-    ## Return the list of neighbors and the adjacency matrix
-    return Neighbor_list, A
-
-
-
-
-
-
-
-
-
-
-def compute_p_neighbor_once(self, p):
-    """
-    Compute exactly one p-neighbor of the given quadratic form.
-
-    RESTRICTIONS ON p???
-
-    """
-    ## TO DO: ADD SANITY CHECKS FOR THE PRIME p.
-
-
-    ## Look for the first p-neighbor form
-    for v in normalized_finite_projective_space_generator(Q_start.dim(), p):
-
-        ## Try to compute a p-neighboring form from the vector v
-        try:
-            Q_neighbor = Q_start.compute_p_neighbor_from_vector(p, v)
- 
-        ## Move to the next vector if we don't have a neighbor from v
-        except AttributeError: 
-            pass
-
-        ## Return the p-neighbor if we have one
-        if Q_neighbor != None:
-            return Q_neighbor
-
-
-
-
-
-
-
-
-
-## ----------------------------------------------------------------------------------------------------------------------
-
-
-## Routines from the paper of Scharlau/Hempkemeier for finding neighbors.
-
-
-
-def compute_p_neighbors(self, p, return_vectors=False):
-    """
-    Compute a list of all the (p^(n-1) - 1) p-neighbors of the
-    current quadratic form.  
-
-    return_vectors -- boolean -- returns pairs [Q', v'] where v' is the normalized projective vector giving the p-neighbor Q' of Q.
-
-
-    TO DO: If a neighbor_index >0 and < p^n is passed, then the
-    p-neighbor associated to the staring with the vector   
-
-    EXAMPLES:
-    """
-    ## Make a list of p-neighbors naively, excluding those vectors which produce bad p-neighbor lattices.
-    Neighbor_list = []
-    for v in normalized_finite_projective_space_generator(self.dim(), p):
-        try:
-            Q_neighbor = self.compute_p_neighbor_from_vector(p, v)
-
-            if return_vectors:
-                Neighbor_list.append([Q_neighbor, v])
-            else:
-                Neighbor_list.append(Q_neighbor)
-        except AttributeError: 
-            pass
-
-    return Neighbor_list
-
-
-
-
-
-def compute_p_neighbor_from_vector(self, p, v, return_transformation=False):
-    """
-    Compute the p-neighbor of the current quadratic form associated to
-    the vector v, assuming that:
-
-        - p^2 divides Q(v) 
-        - v is not in p * (dual lattice of Z^n w.r.t. the Hessian bilinear form)
-        
-     (Note: A stronger condition is that p doesn't divide the Hessian determinant of Q)
-
-
-     INPUT:
-         return_transformation -- boolean -- returns the linear transformation.
-
-
-    TO DO: If a neighbor_index >0 and < p^n is passed, then the
-    p-neighbor associated to the staring with the vector   
-
-    EXAMPLES:
-    """
-    Q = self
-    n = Q.dim()
-    M = Q.matrix()
-
-
-    ## Sanity Checks:
-    ## --------------
-    #print
-    #print "Checking the vector v = ", v 
-    #print "Q(v) = ", Q(v)
-
-    ## TO DO: Perhaps check for primitivity or rescale the form?
-  
-      
-    ## Check if Q(v) = 0 (mod p) and <v,.> is not identically zero (mod p)  
-    ## (i.e., it is non-singular on the associated projective conic)
-    zero_vec = vector(n * [ZZ(0)])
-    if (Q(v) % p == 0) and ((vector(v) * M) % p != zero_vec):
-        #print "Found Q(v) = 0 (mod p) which is non-singular on the conic"
-        pass
-    else:
-        raise AttributeError, "The vector v isn't non-singular on the conic mod p."
-
-
-    #######################
-    ## This isn't required -- we can arrange for this (when p > 2?).
-    ############################################################################################################
-    ## Check that Q(v) = 0 (mod p^2), which is required for
-    ## integrality of the p-neighbor lattice.
-    #if Q(v) % p**2 == 0:
-    #    print "Q(v) = 0 (mod p^2), so the associated p-neighbor will be integer-valued."
-    #else:
-    #    raise AttributeError, "Q(v) = 0 (mod p^2), so the associated p-neighbor won't be integer-valued."
-    ############################################################################################################
-
-
-
-
-    ## STEP 1: Adjust the vector v to be isotropic mod p^2
-    ## ---------------------------------------------------
-
-    ## Find the index v_ind of the first non-zero coefficient of v (which should be 1 by our normalization convention)
-    for i in range(n):
-        if v[i] % p != 0:
-            if v[i] != 1:          ## This is just a safety check -- not needed at all.
-                raise RuntimeError, "Something is very wrong with the normalized vector "+ str(v) + \
-                    " -- it's first non-zero coeff should be 1."
-            v_ind = i
-            break
-
-    ## Find a basis vector e_m which has non-zero pairing with v (mod p)
-    v_pairing_vec = vector(v) * M
-    for i in range(n):
-        if (i != v_ind) and (v_pairing_vec[i] % p != 0):
-            v_pairing_non_singular_index = i
-            v_pairing_non_zero_basis_vec = vector([0  for j in range(i)] + [1] + [0  for j in range(i+1, n)])
-            vb_coeff = v_pairing_vec[i]
-            break
-
-    #print "v_pairing_vec = ", v_pairing_vec
-    #print "v_pairing_non_singular_index = ", v_pairing_non_singular_index
-    #print "v_pairing_non_zero_basis_vec = ", v_pairing_non_zero_basis_vec
-    #print "vb_coeff = ", vb_coeff
-            
-            
-
-
-    ## Adjust v (to a new vector v1) so that Q(v1) = 0 (mod p^2) 
-    ## by adding a multiple of an independent basis vector
-    ## whose bilinear pairing with v doesn't vanish
-    c = -Q(v) / (p * vb_coeff) % p
-    v1 = v + p * c * v_pairing_non_zero_basis_vec
-
-    #print "v1 = ", v1
-    #print "Q(v1) = ", Q(v1)
-
-
-    ## Check that Q(v1) = 0 (mod p^2)
-    if Q(v1) % p*p != 0:
-        raise RuntimeError, "The adjusted vector v1 is not isotropic mod p^2!"
-
-
-    ## STEP 2: Compute the associated p-neighbor
-    ## -----------------------------------------
-
-    ## Find the associated (non-integral) change of basis matrix
-    X = matrix(self.base_ring().fraction_field(), n, n, 1)
-    ns_ind = v_pairing_non_singular_index
-    for i in range(n):
-        if i == v_ind:
-            X.set_column(i, v1/p)     ## Scale v1 by 1/p
-        elif i == ns_ind:
-            X[i,i] = p                ## Scale the dual basis vector to v1 by p
-        else:
-            X[ns_ind,i] = -v_pairing_vec[i] / v_pairing_vec[ns_ind] % p     ## Arrange for an orthogonal basis to v (mod p) at most vectors.
-            
-    #print "X = ", X
-
-
-    ## Change basis to find the assiciated p-neighbor
-    #Q1 = Q((p * X).inverse())
-    Q1 = Q(p * X)
-    Q2 = Q1.scale_by_factor(1/(p*p))      ## TO DO:  Simplify this code when the coefficient_ring is separated from the equivalence_ring
-    #print
-    #print "Found the neighbor: ", Q2
-    #print
-
-
-    ## Return the p-neighbor
-    return Q2
-
-
-
-
-
-## ----------------------------------------------------------------------------------------------
-
-def find_p_neighbor_from_vec(self, p, v):
-    """
-    Finds the p-neighbor of this quadratic form associated to a given
-    vector v satisfying:
-        a) Q(v) = 0  (mod p)
-        b) v is a non-singular point of the conic Q(v) = 0 (mod p).
-
-    Reference:  Gonzalo Tornaria's Thesis, Thrm 3.5, p34.
-
-    EXAMPLES:
-        sage: Q = DiagonalQuadraticForm(ZZ,[1,1,1,1])
-        sage: v = vector([0,2,1,1])
-        sage: X = Q.find_p_neighbor_from_vec(3,v); X
-        Quadratic form in 4 variables over Integer Ring with coefficients: 
-        [ 3 10 0 -4 ]
-        [ * 9 0 -6 ]
-        [ * * 1 0 ]
-        [ * * * 2 ]
-
-    """
-    R = self.base_ring()
-    n = self.dim()
-    B2 = self.matrix()
-
-    ## Find a (dual) vector w with B(v,w) != 0 (mod p)
-    v_dual = B2 * vector(v)     ## We want the dot product with this to not be divisible by 2*p.
-    y_ind = 0
-    while ((y_ind < n) and (v_dual[y_ind] % p) == 0):   ## Check the dot product for the std basis vectors!
-        y_ind += 1
-    if y_ind == n:
-        raise RuntimeError, "Oops!  One of the standard basis vectors should have worked."
-    w = vector([R(i == y_ind)  for i in range(n)])
-    vw_prod = (v * self.matrix()).dot_product(w)
-
-    ## DIAGNOSTIC
-    #if vw_prod == 0:
-    #   print "v = ", v
-    #   print "v_dual = ", v_dual
-    #   print "v_dual[y_ind] = ", v_dual[y_ind]
-    #   print "(v_dual[y_ind] % p) = ", (v_dual[y_ind] % p)
-    #   print "w = ", w
-    #   print "p = ", p
-    #   print "vw_prod = ", vw_prod
-    #   raise RuntimeError, "ERROR: Why is vw_prod = 0?"
-
-    ## DIAGNOSTIC
-    #print "v = ", v
-    #print "w = ", w
-    #print "vw_prod = ", vw_prod
-
-
-    ## Lift the vector v to a vector v1 s.t. Q(v1) = 0 (mod p^2)
-    s = self(v)
-    if (s % p**2 != 0):
-        al = (-s / (p * vw_prod)) % p
-        v1 = v + p * al * w
-        v1w_prod = (v1 * self.matrix()).dot_product(w)
-    else:
-        v1 = v
-        v1w_prod = vw_prod
-
-    ## DIAGNOSTIC
-    #if (s % p**2 != 0):
-    #    print "al = ", al
-    #print "v1 = ", v1
-    #print "v1w_prod = ", v1w_prod
-
-
-    ## Construct a special p-divisible basis to use for the p-neighbor switch
-    good_basis = extend_to_primitive([v1, w])
-    for i in range(2,n):
-        ith_prod = (good_basis[i] * self.matrix()).dot_product(v)
-        c = (ith_prod / v1w_prod) % p
-        good_basis[i] = good_basis[i] - c * w  ## Ensures that this extenstion has <v_i, v> = 0 (mod p)
-
-    ## DIAGNOSTIC
-    #print "original good_basis = ", good_basis
-
-    ## Perform the p-neighbor switch
-    good_basis[0]  = vector([x/p  for x in good_basis[0]])    ## Divide v1 by p
-    good_basis[1]  = good_basis[1] * p                          ## Multiply w by p
-
-    ## Return the associated quadratic form
-    M = matrix(good_basis)
-    new_Q = deepcopy(self)                        ## Note: This avoids a circular import of QuadraticForm!
-    new_Q.__init__(R, M * self.matrix() * M.transpose())
-    return new_Q
-    return QuadraticForm(R, M * self.matrix() * M.transpose())
-
-
-## ----------------------------------------------------------------------------------------------
-
-
-#def find_classes_in_genus(self):
-
-
diff -r 01ac57b92113 -r b4a2b705be3a sage/quadratic_forms/quadratic_form__neighbors__OLD.py
--- a/sage/quadratic_forms/quadratic_form__neighbors__OLD.py	Sat Jan 08 20:16:37 2011 -0500
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,257 +0,0 @@
-"""
-Neighbors
-"""
-from sage.modules.free_module_element import vector
-from sage.rings.integer_ring import ZZ
-from copy import deepcopy
-from sage.quadratic_forms.extras import extend_to_primitive
-from sage.matrix.constructor import matrix
-#from sage.quadratic_forms.quadratic_form import QuadraticForm    ## This creates a circular import! =(
-
-
-####################################################################################
-## Routines used for understanding p-neighbors, and computing classes in a genus. ##
-####################################################################################
-
-
-def find_primitive_p_divisible_vector__random(self, p):
-    """
-    Finds a random `p`-primitive vector in `L/pL` whose value is `p`-divisible.
-
-    .. note::
-    
-        Since there are about `p^{(n-2)}` of these lines, we have a `1/p`
-        chance of randomly finding an appropriate vector.
-
-    .. warning::
-    
-        If there are local obstructions for this to happen, then this algorithm
-        will never terminate... =(  We should check for this too!
-
-    EXAMPLES::
-    
-        sage: Q = QuadraticForm(ZZ, 2, [10,1,4])
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (1, 1)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (1, 0)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (2, 0)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (2, 2)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (3, 3)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (3, 3)
-        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
-        (2, 0)
-
-    """
-    n = self.dim()
-    v = vector([ZZ.random_element(p)  for i in range(n)])
-
-    ## Repeatedly choose random vectors, and evaluate until the value is p-divisible.
-    while True:
-        if (self(v) % p == 0) and (v != 0):         
-            return v
-        else: 
-            v[ZZ.random_element(n)] = ZZ.random_element(p)      ## Replace a random entry and try again.
-
-
-
-
-#def find_primitive_p_divisible_vector__all(self, p):
-#    """
-#    Finds all random p-primitive vectors (up to scaling) in L/pL whose
-#    value is p-divisible.
-#
-#    Note: Since there are about p^(n-2) of these lines, we should avoid this for large n.
-#    """
-#    pass
-
-
-def find_primitive_p_divisible_vector__next(self, p, v=None):
-    """
-    Finds the next `p`-primitive vector (up to scaling) in `L/pL` whose
-    value is `p`-divisible, where the last vector returned was `v`.  For
-    an intial call, no `v` needs to be passed.
-
-    Returns vectors whose last non-zero entry is normalized to 0 or 1 (so no
-    lines are counted repeatedly).  The ordering is by increasing the
-    first non-normalized entry.  If we have tested all (lines of)
-    vectors, then return None.
-
-    OUTPUT:
-        vector or None
-
-    EXAMPLES::
-    
-        sage: Q = QuadraticForm(ZZ, 2, [10,1,4])
-        sage: v = Q.find_primitive_p_divisible_vector__next(5); v
-        (1, 1)
-        sage: v = Q.find_primitive_p_divisible_vector__next(5, v); v
-        (1, 0)
-        sage: v = Q.find_primitive_p_divisible_vector__next(5, v); v
-
-
-    """
-    ## Initialize 
-    n = self.dim()
-    if v == None:
-        w = vector([ZZ(0) for i in range(n-1)] + [ZZ(1)])
-    else:
-        w = deepcopy(v)
-
-
-    ## Handle n = 1 separately.
-    if n <= 1:
-        raise RuntimeError, "Sorry -- Not implemented yet!"
-
-
-    ## Look for the last non-zero entry (which must be 1)
-    nz = n - 1
-    while w[nz] == 0:
-        nz += -1
-
-    ## Test that the last non-zero entry is 1 (to detect tampering).
-    if w[nz] != 1:
-        print "Warning: The input vector to QuadraticForm.find_primitive_p_divisible_vector__next() is not normalized properly."
-
-
-
-    ## Look for the next vector, until w == 0
-    while True:
-
-
-        ## Look for the first non-maximal (non-normalized) entry
-        ind = 0
-        while (ind < nz) and (w[ind] == p-1):
-            ind += 1
-
-        #print ind, nz, w
-
-        ## Increment 
-        if (ind < nz):
-            w[ind] += 1
-            for j in range(ind):
-                w[j] = 0        
-        else:  
-            for j in range(ind+1):    ## Clear all entries
-                w[j] = 0        
-
-            if nz != 0:               ## Move the non-zero normalized index over by one, or return the zero vector
-                w[nz-1] = 1
-                nz += -1
-
-
-        ## Test for zero vector
-        if w == 0:
-            return None
-
-        ## Test for p-divisibility
-        if (self(w) % p == 0):
-            return w
-
-
-
-
-## ----------------------------------------------------------------------------------------------
-
-def find_p_neighbor_from_vec(self, p, v):
-    """
-    Finds the `p`-neighbor of this quadratic form associated to a given
-    vector `v` satisfying:
-
-    #. `Q(v) = 0  \pmod p`
-    #. `v` is a non-singular point of the conic `Q(v) = 0 \pmod p`.
-
-    Reference:  Gonzalo Tornaria's Thesis, Thrm 3.5, p34.
-
-    EXAMPLES::
-    
-        sage: Q = DiagonalQuadraticForm(ZZ,[1,1,1,1])
-        sage: v = vector([0,2,1,1])
-        sage: X = Q.find_p_neighbor_from_vec(3,v); X
-        Quadratic form in 4 variables over Integer Ring with coefficients: 
-        [ 3 10 0 -4 ]
-        [ * 9 0 -6 ]
-        [ * * 1 0 ]
-        [ * * * 2 ]
-
-    """
-    R = self.base_ring()
-    n = self.dim()
-    B2 = self.matrix()
-
-    ## Find a (dual) vector w with B(v,w) != 0 (mod p)
-    v_dual = B2 * vector(v)     ## We want the dot product with this to not be divisible by 2*p.
-    y_ind = 0
-    while ((y_ind < n) and (v_dual[y_ind] % p) == 0):   ## Check the dot product for the std basis vectors!
-        y_ind += 1
-    if y_ind == n:
-        raise RuntimeError, "Oops!  One of the standard basis vectors should have worked."
-    w = vector([R(i == y_ind)  for i in range(n)])
-    vw_prod = (v * self.matrix()).dot_product(w)
-
-    ## DIAGNOSTIC
-    #if vw_prod == 0:
-    #   print "v = ", v
-    #   print "v_dual = ", v_dual
-    #   print "v_dual[y_ind] = ", v_dual[y_ind]
-    #   print "(v_dual[y_ind] % p) = ", (v_dual[y_ind] % p)
-    #   print "w = ", w
-    #   print "p = ", p
-    #   print "vw_prod = ", vw_prod
-    #   raise RuntimeError, "ERROR: Why is vw_prod = 0?"
-
-    ## DIAGNOSTIC
-    #print "v = ", v
-    #print "w = ", w
-    #print "vw_prod = ", vw_prod
-
-
-    ## Lift the vector v to a vector v1 s.t. Q(v1) = 0 (mod p^2)
-    s = self(v)
-    if (s % p**2 != 0):
-        al = (-s / (p * vw_prod)) % p
-        v1 = v + p * al * w
-        v1w_prod = (v1 * self.matrix()).dot_product(w)
-    else:
-        v1 = v
-        v1w_prod = vw_prod
-
-    ## DIAGNOSTIC
-    #if (s % p**2 != 0):
-    #    print "al = ", al
-    #print "v1 = ", v1
-    #print "v1w_prod = ", v1w_prod
-
-
-    ## Construct a special p-divisible basis to use for the p-neighbor switch
-    good_basis = extend_to_primitive([v1, w])
-    for i in range(2,n):
-        ith_prod = (good_basis[i] * self.matrix()).dot_product(v)
-        c = (ith_prod / v1w_prod) % p
-        good_basis[i] = good_basis[i] - c * w  ## Ensures that this extenstion has <v_i, v> = 0 (mod p)
-
-    ## DIAGNOSTIC
-    #print "original good_basis = ", good_basis
-
-    ## Perform the p-neighbor switch
-    good_basis[0]  = vector([x/p  for x in good_basis[0]])    ## Divide v1 by p
-    good_basis[1]  = good_basis[1] * p                          ## Multiply w by p
-
-    ## Return the associated quadratic form
-    M = matrix(good_basis)
-    new_Q = deepcopy(self)                        ## Note: This avoids a circular import of QuadraticForm!
-    new_Q.__init__(R, M * self.matrix() * M.transpose())
-    return new_Q
-    return QuadraticForm(R, M * self.matrix() * M.transpose())
-
-
-## ----------------------------------------------------------------------------------------------
-
-
-#def find_classes_in_genus(self):
-
-
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1295210502 18000
# Node ID 063731ed80720a7889e934ccdc287d3e256cdd17
# Parent  b4a2b705be3a007ea6b064a3314a96d022fe5672
Added a few QuadraticForm methods, and fixed a few bugs, so we now correctly compute all ternary maximal lattices of class number one.

Added QuadraticForm.LLL_reduced().
Fixed a serieus bug in SquareClass.is_square_element() for p-adic fields.
Other misc changes.

diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/quadratic_form.py
--- a/sage/quadratic_forms/quadratic_form.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form.py	Sun Jan 16 15:41:42 2011 -0500
@@ -311,6 +311,7 @@
             
     ## Routines to reduce a given quadratic form
     from sage.quadratic_forms.quadratic_form__reduction_theory import \
+            LLL_reduced, \
             reduced_binary_form1, \
             reduced_ternary_form__Dickson, \
             reduced_binary_form, \
@@ -390,6 +391,9 @@
             is_locally_equivalent_to, \
             has_equivalent_Jordan_decomposition_at_prime
 
+
+
+
     def __init__(self, R, n=None, entries=None, unsafe_initialization=False, number_of_automorphisms=None, \
                  determinant=None, init_from_gram_matrix=False):
         """
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/quadratic_form__automorphisms.py
--- a/sage/quadratic_forms/quadratic_form__automorphisms.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form__automorphisms.py	Sun Jan 16 15:41:42 2011 -0500
@@ -136,6 +136,9 @@
     self.__basis_of_short_vectors = basis
     self.__basis_of_short_vectors_lenghts = pivot_lengths
 
+    ## Clear the GP prompts (since we only have about 65,000 of them!)
+    gp.clear_prompts()
+
 
     ## Return the appropriate result
     if show_lengths:
@@ -209,6 +212,9 @@
     zero_vec = vector([ZZ(0)  for _ in range(self.dim())])
     vec_list[0].append(zero_vec)  
 
+    ## Clear the GP prompts (since we only have about 65,000 of them!)
+    gp.clear_prompts()
+
     ## Return the sorted list
     return vec_list
 
@@ -445,6 +451,8 @@
         3840
     
     """
+    ## Find an LLL-reduced quadratic form globally equivalent to this one
+    Q1 = self.LLL_reduced()
     
     ## Write an input text file
     F_filename = '/tmp/tmp_isom_input' + str(random()) + ".txt"
@@ -456,9 +464,9 @@
     for i in range(n):
         for j in range(i+1):
             if i == j:
-                F.write(str(2 * self[i,j]) + " ")
+                F.write(str(2 * Q1[i,j]) + " ")
             else:
-                F.write(str(self[i,j]) + " ")
+                F.write(str(Q1[i,j]) + " ")
         F.write("\n")
     F.flush()
     #print "Input filename = ", F.name
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/quadratic_form__equivalence_testing.py
--- a/sage/quadratic_forms/quadratic_form__equivalence_testing.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form__equivalence_testing.py	Sun Jan 16 15:41:42 2011 -0500
@@ -25,7 +25,7 @@
 
 def is_globally_equivalent__souvigner(self, other, return_transformation=False):
     """
-    Uses the Souvigner code to compute the number of automorphisms.
+    Uses the Souvigner code to test for global equivalence of positive definite quadratic forms!
     
     INPUT:
         a QuadraticForm
@@ -45,6 +45,15 @@
         True
         
     """
+    ## SANITY CHECK:  The Souvigner code requires matrices to be positive definite!
+    if not (self.is_positive_definite() and other.is_positive_definite()):
+        raise TypeError, "Both quadratic forms need to be positive definite to use the Souvigner code!"
+    
+    
+    ## Find LLL-reduced quadratic forms globally equivalent to our given ones
+    Q1 = self.LLL_reduced()
+    Q2 = other.LLL_reduced()
+    
     ## Write an input text file
     F_filename = '/tmp/tmp_isom_input' + str(random()) + ".txt"
     F = open(F_filename, 'w')
@@ -57,9 +66,9 @@
     for i in range(n):
         for j in range(i+1):
             if i == j:
-                F.write(str(2 * self[i,j]) + " ")
+                F.write(str(2 * Q1[i,j]) + " ")
             else:
-                F.write(str(self[i,j]) + " ")
+                F.write(str(Q1[i,j]) + " ")
         F.write("\n")
 
     ## Write the second form
@@ -69,9 +78,9 @@
     for i in range(n):
         for j in range(i+1):
             if i == j:
-                F.write(str(2 * other[i,j]) + " ")
+                F.write(str(2 * Q2[i,j]) + " ")
             else:
-                F.write(str(other[i,j]) + " ")
+                F.write(str(Q2[i,j]) + " ")
         F.write("\n")
     F.flush()
     #print "Input filename = ", F.name
@@ -79,7 +88,7 @@
 
     ## Call the Souvigner automorphism code
     souvigner_isom_path = SAGE_ROOT + "/local/bin/Souvigner_ISOM" 
-    G1 = tempfile.NamedTemporaryFile(prefix='tmp_isom_ouput', suffix=".txt")
+    G1 = tempfile.NamedTemporaryFile(prefix='tmp_isom_output', suffix=".txt")
     #print "Output filename = ", G1.name
     #print  "Executing the shell command:   " + souvigner_isom_path + " '" +  F.name + "' > '" + G1.name + "'"
     os.system(souvigner_isom_path + " '" +  F.name + "' > '" + G1.name +"'")
@@ -90,7 +99,7 @@
     line = G2.readline()
     if line.startswith("Error:"):
         raise RuntimeError, "There is a problem using the souvigner code...  " + line
-    elif line.find("not isomorphic") != -1:     ## Checking if this text appears, if so then they're not isomorphic!
+    elif line.find("not iso") != -1:     ## Checking if this text appears, if so then they're not isomorphic/isometric!
         return False
     else:
         ## Decide whether to read the transformation matrix, and return true
@@ -125,7 +134,7 @@
 
 
 
-def is_globally_equivalent_to(self, other, return_matrix=False, check_theta_to_precision='sturm', check_local_equivalence=True):
+def is_globally_equivalent_to(self, other, return_matrix=False, check_theta_to_precision=30, check_local_equivalence=True, use_code="Souvigner"):
     """
     Determines if the current quadratic form is equivalent to the
     given form over ZZ.  If return_matrix is True, then we also return
@@ -183,57 +192,60 @@
         raise TypeError, "Oops!  You must compare two quadratic forms, but the argument is not a quadratic form. =("
 
 
-    ## Now use the Souvigner code by default! =)
-    return other.is_globally_equivalent__souvigner(self, return_matrix)    ## Note: We switch this because the Souvigner code has the opposite mapping convention to us.  (It takes the second argument to the first!)
 
-
-
-    ## ----------------------------------  Unused Code below  ---------------------------------------------------------
-
-    ## Check if the forms are locally equivalent
-    if (check_local_equivalence == True):
-        if not self.is_locally_equivalent_to(other):
-            return False
-
-    ## Check that the forms have the same theta function up to the desired precision (this can be set so that it determines the cusp form)
-    if check_theta_to_precision != None:
-        if self.theta_series(check_theta_to_precision, var_str='', safe_flag=False) != other.theta_series(check_theta_to_precision, var_str='', safe_flag=False):
-            return False
-
-
-    ## Make all possible matrices which give an isomorphism -- can we do this more intelligently?
-    ## ------------------------------------------------------------------------------------------
-
-    ## Find a basis of short vectors for one form, and try to match them with vectors of that length in the other one.
-    basis_for_self, self_lengths = self.basis_of_short_vectors(show_lengths=True)
-    max_len = max(self_lengths)
-    short_vectors_of_other = other.short_vector_list_up_to_length(max_len + 1)
-
-    ## Make the matrix A:e_i |--> v_i to our new basis.
-    A = Matrix(basis_for_self).transpose()
-    Q2 = A.transpose() * self.matrix() * A       ## This is the matrix of 'self' in the new basis
-    Q3 = other.matrix()
+    if use_code == "Souvigner":
+        ## Now use the Souvigner code by default! =)
+        return other.is_globally_equivalent__souvigner(self, return_matrix)    ## Note: We switch this because the Souvigner code has the opposite mapping convention to us.  (It takes the second argument to the first!)
+    
+    
+    elif use_code == "Python":
+        ## Check if the forms are locally equivalent
+        if (check_local_equivalence == True):
+            if not self.is_locally_equivalent_to(other):
+                return False
+    
+        ## Check that the forms have the same theta function up to the desired precision (this can be set so that it determines the cusp form)
+        if check_theta_to_precision != None:
+            if self.theta_series(check_theta_to_precision, var_str='', safe_flag=False) != other.theta_series(check_theta_to_precision, var_str='', safe_flag=False):
+                return False
+    
+    
+        ## Make all possible matrices which give an isomorphism -- can we do this more intelligently?
+        ## ------------------------------------------------------------------------------------------
+    
+        ## Find a basis of short vectors for one form, and try to match them with vectors of that length in the other one.
+        basis_for_self, self_lengths = self.basis_of_short_vectors(show_lengths=True)
+        max_len = max(self_lengths)
+        short_vectors_of_other = other.short_vector_list_up_to_length(max_len + 1)
+    
+        ## Make the matrix A:e_i |--> v_i to our new basis.
+        A = Matrix(basis_for_self).transpose()
+        Q2 = A.transpose() * self.matrix() * A       ## This is the matrix of 'self' in the new basis
+        Q3 = other.matrix()
+            
+        ## Determine all automorphisms
+        n = self.dim()
+        Auto_list = []
         
-    ## Determine all automorphisms
-    n = self.dim()
-    Auto_list = []
+        ## DIAGNOSTIC
+        #print "n = " + str(n)
+        #print "pivot_lengths = " + str(pivot_lengths)
+        #print "vector_list_by_length = " + str(vector_list_by_length)
+        #print "length of vector_list_by_length = " + str(len(vector_list_by_length))
+        
+        for index_vec in mrange([len(short_vectors_of_other[self_lengths[i]])  for i in range(n)]):
+            M = Matrix([short_vectors_of_other[self_lengths[i]][index_vec[i]]   for i in range(n)]).transpose()
+            if M.transpose() * Q3 * M == Q2:
+                if return_matrix:
+                    return A * M.inverse()
+                else:
+                    return True
+                            
+        ## If we got here, then there is no isomorphism
+        return False
     
-    ## DIAGNOSTIC
-    #print "n = " + str(n)
-    #print "pivot_lengths = " + str(pivot_lengths)
-    #print "vector_list_by_length = " + str(vector_list_by_length)
-    #print "length of vector_list_by_length = " + str(len(vector_list_by_length))
-    
-    for index_vec in mrange([len(short_vectors_of_other[self_lengths[i]])  for i in range(n)]):
-        M = Matrix([short_vectors_of_other[self_lengths[i]][index_vec[i]]   for i in range(n)]).transpose()
-        if M.transpose() * Q3 * M == Q2:
-            if return_matrix:
-                return A * M.inverse()
-            else:
-                return True
-                        
-    ## If we got here, then there is no isomorphism
-    return False
+    else:
+        raise TypeError, "The use_code argument must be either 'Python' or 'Souvigner'."
 
     
 def is_locally_equivalent_to(self, other, check_primes_only=False, force_jordan_equivalence_test=False):
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/quadratic_form__local_field_invariants.py
--- a/sage/quadratic_forms/quadratic_form__local_field_invariants.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form__local_field_invariants.py	Sun Jan 16 15:41:42 2011 -0500
@@ -102,11 +102,25 @@
         ## Deal with rows where the diagonal entry is zero.
         if Q[i,i] == 0:
 
+            ## SANITY CHECK:  Raise an error in characteristic 2!
+            R = self.base_ring()
+            if R(2) == R(0):
+                raise NotImplementedError, "In characteristic 2 we can't make non-zero pivots in without more work!"
+
             ## Look for a non-zero entry and use it to make the diagonal non-zero (if it exists)
             for j in range(i+1, n):
                 if Q[i,j] != 0:
+
+                    ## Find a shearing that makes the diagonal entry non-zero
+                    bad_shearing_factor = -Q[j,j] / Q[i,j]
+                    if bad_shearing_factor == 1:
+                        shear_factor = 2
+                    else:
+                        shear_factor = 1
+
+                    ## Make the shearing transformation
                     temp = MS(1)
-                    temp[j, i] = 1
+                    temp[j, i] = shear_factor
 
                     ## Apply the transformation
                     Q = Q(temp)
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/quadratic_form__neighbors.py
--- a/sage/quadratic_forms/quadratic_form__neighbors.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form__neighbors.py	Sun Jan 16 15:41:42 2011 -0500
@@ -275,6 +275,10 @@
                     ## Run through all neighbors looking for an isometry
                     new_flag = True
                     for j in range(len(Neighbor_list)):
+
+                        print "Q_neighbor = " + str(Q_neighbor)
+                        print "Neighbor_list[j] = " + str(Neighbor_list[j])
+                        print "\n\n"
                     
                         ## Record any isometries with known forms  (in the upper triangular entries of A)
                         if Q_neighbor.is_globally_equivalent_to(Neighbor_list[j]):
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/quadratic_form__reduction_theory.py
--- a/sage/quadratic_forms/quadratic_form__reduction_theory.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form__reduction_theory.py	Sun Jan 16 15:41:42 2011 -0500
@@ -8,6 +8,21 @@
 from sage.modules.free_module_element import vector
 from sage.rings.integer_ring import ZZ
 
+def LLL_reduced(self, give_transformation=False):
+        """
+        Returns a globally equivalent LLL-reduced quadratic form.  
+        If give_transformation=True then we additionally return the
+        transformation (on column vectors) used to produce the new basis.        
+        """
+        H = self.Hessian_matrix()
+        U = H.LLL_gram()
+        if give_transformation:
+            return self(U), U
+        else:
+            return self(U)
+    
+
+
 
 def reduced_binary_form1(self):
     r"""
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/quadratic_lattice.py
--- a/sage/quadratic_forms/quadratic_lattice.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/quadratic_lattice.py	Sun Jan 16 15:41:42 2011 -0500
@@ -76,6 +76,14 @@
         self.__lattice_free_module = LM
 
 
+        ## ADD THIS SOMEHOW...  to allow us to choose the basis for a quadratic lattice (as with SBSs already)!
+        #self.__ambient_bilinear_space = V
+        #self.__lattice_module = FreeModule_submodule_with_basis_pid(V.vector_space(), basis)
+        #self.__base_ring = V.base_field().ring_of_integers()
+
+
+
+
 
 
     def __repr__(self):
@@ -802,6 +810,11 @@
         new_L = QuadraticLattice(self.quadratic_space(), (M * T).columns())
         return new_L
 
+        #gens = self.generators()
+        #T_transpose = T.transpose()
+        #new_L = QuadraticLattice(self.quadratic_space(), [T_transpose * gens[i]  for i in range(len(gens))])
+        #return new_L
+
 
 
 
@@ -890,6 +903,30 @@
         
 
 
+
+    #def LLL_reduced(self, give_transformation=False):
+    #    """
+    #    Returns the same quadratic lattice in an LLL-reduced basis.
+    #    If return_transformation=True then we additionally return the
+    #    transformation (on column vectors) used to produce the new basis.
+    #    
+    #    """
+    #    H = self.Hessian_matrix()
+    #    U = H.LLL_gram()
+    #    if give_transformation:
+    #        return self.apply_linear_transformation_on_right(U), U
+    #    else:
+    #        return self.apply_linear_transformation_on_right(U)
+    
+    
+#############################################################################################
+#############################################################################################
+#############################################################################################
+####  BELOW THIS POINT WE IGNORE THE CODE!
+#############################################################################################
+#############################################################################################
+#############################################################################################
+
 def Watson_superlattice(self):
     """
     
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/quadratic_space.py
--- a/sage/quadratic_forms/quadratic_space.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/quadratic_space.py	Sun Jan 16 15:41:42 2011 -0500
@@ -44,7 +44,7 @@
 
 
 from sage.rings.rational_field import is_RationalField, QQ, RationalField
-from sage.rings.real_mpfr import RealField
+from sage.rings.real_mpfr import is_RealField, RealField
 from sage.rings.all import is_ComplexField, is_pAdicField, is_FiniteField
 
 
@@ -377,7 +377,7 @@
                         return 2
 
         ## Case 2: p-adic fields Q_p
-        elif is_pAdicField(F) or (is_RationalField(F) and is_prime(QQ_place)):
+        elif is_pAdicField(F) or (is_RationalField(F) and (QQ_place != None) and is_prime(QQ_place)):
             d = self.determinant().representative()
             p = self.base_field().prime()
             if not is_prime(p):
@@ -385,7 +385,7 @@
             return local_quadratic_space_anisotropic_dimension_by_invariants(p, n, d, self.hasse_invariant(p))
 
         ## Case 3: Real Fields
-        elif isinstance(F, RealField) or (is_RationalField(F) and (QQ_place == Infinity)):
+        elif is_RealField(F) or (is_RationalField(F) and (QQ_place == Infinity)):
             return abs(self.__quadratic_form.signature())
 
         ## Case 4: Complex Fields
@@ -1045,7 +1045,7 @@
         ## Check that x and y are vectors of the appropriate length, and defined over the base_field.
 
         
-        ## Compute the (Gram) inner product
+        ## Compute the (Hessian) inner product
         n = self.dim()
         tmp_sum = self.__quadratic_form.base_ring()(0)
         for i in range(n):
@@ -1485,16 +1485,19 @@
         ## Find a maximal lattice for the associated Hessian bilinear space
         Hessian_maximal_lattice = self.__hessian_bilinear_space.maximal_bilinear_lattice()
 
-        print "Hessian_maximal_lattice = " + str(Hessian_maximal_lattice)
+        #print "Hessian_maximal_lattice = " + str(Hessian_maximal_lattice)
 
         ## Find the even sublattice, and look for a maximal even superlattice of it
         Even_sublattice = Hessian_maximal_lattice.even_sublattice()
 
-        print "Even_sublattice = " + str(Even_sublattice)
+        #print "Even_sublattice = " + str(Even_sublattice)
 
-        Pn_Z2 = mrange(4*[2])[1:]   ## This runs over all vectors of P^n(GF(2))
+        Pn_Z2 = mrange(n*[2])[1:]   ## This runs over all non-zero vectors of P^n(GF(2))
         ## Loop through all index 2 superlattices, looking for an even one
-        for v in Pn_Z2:              
+        for v in Pn_Z2:
+            #print "v = " + str(v)
+            #print "Even_sublattice.basis_matrix_of_rows() = " + str(Even_sublattice.basis_matrix_of_rows())
+            #print "Matrix(F, vector(F, v) * (ZZ(1)/ZZ(2))) = " + str(Matrix(F, vector(F, v) * (ZZ(1)/ZZ(2))))
             v1_list = (Matrix(F, vector(F, v) * (ZZ(1)/ZZ(2))) * Even_sublattice.basis_matrix_of_rows()).rows()
             L = Even_sublattice.sum_with(v1_list)
             if L.is_even():
@@ -1911,7 +1914,7 @@
         if (self.base_field() != other.base_field()):                ## SERIOUS WARNING:  HERE WE ARE TESTING FIELD EQUALITY -- NOT FIELD ISOMORPHISM!  Be *especially* careful about precisions for inexact/real fields!
             return False
 
-        ## Check their dimensions  agree
+        ## Check their total and anisotropic dimensions agree
         if (self.dim() != other.dim())  or (self.anisotropic_dim() != other.anisotropic_dim()):
             return False
 
@@ -1935,19 +1938,19 @@
 
 
         ## Test for Finite Fields:
-        elif isinstance(self.base_field(), FiniteField):
+        elif is_FiniteField(self.base_field()):
             return True
 
         ## Test for CC:
-        elif isinstance(self.base_field(), ComplexField):
+        elif is_ComplexField(self.base_field()):
             return True
 
         ## Test for RR:
-        elif isinstance(self.base_field(), RealField):
+        elif is_RealField(self.base_field()):
             self.__quadratic_form.signature() == other.quadratic_form.signature()
 
         ## Test for p-adic Fields:
-        elif isinstance(self.base_field(), pAdicField):
+        elif is_pAdicFields(elf.base_field()):
 
             ## Test that we're over Q_p
             p = self.base_field().prime()
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/square_classes.py
--- a/sage/quadratic_forms/square_classes.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/square_classes.py	Sun Jan 16 15:41:42 2011 -0500
@@ -8,7 +8,7 @@
 
 
 from sage.rings.rational_field import is_RationalField, QQ
-from sage.rings.real_mpfr import is_RealField
+from sage.rings.real_mpfr import is_RealField, RealField
 
 from sage.rings.all import is_ComplexField, is_pAdicField, is_FiniteField
 
@@ -620,7 +620,7 @@
         ## Compute normalized representatives for each of the supported fields
         if is_ComplexField(F):
             return 1
-        elif isinstance(F, RealField):
+        elif is_RealField(F):
             return sgn(elt)    ## Use the sign 1 or -1 for RR
         elif is_RationalField(F):
             return squarefree_part(elt)    ## Use a squarefree integer for QQ
@@ -761,7 +761,7 @@
         ## Return the valuation for a local or finite field
         if is_pAdicField(F):
             return self.representative().valuation() % 2
-        elif is_ComplexField(F) or isinstance(F, RealField) or is_FiniteField(F):
+        elif is_ComplexField(F) or is_RealField(F) or is_FiniteField(F):
             return 0
 
         ## Return the valuation at a place of QQ
@@ -865,6 +865,8 @@
 
     def is_unit_squares(self):
         """
+        THIS SHOULD BE RENAMED is_squareclass_of_nonzero_squares()!
+        
         Determines if this squareclass is the unit squareclass, which
         is the squareclass of all unit squares.  This uses the method
         self.is_square_element() to decide if the representative is a
@@ -952,7 +954,7 @@
         if is_ComplexField(F):
             return True           ## All elements are squares in CC
 
-        elif isinstance(F, RealField):
+        elif is_RealField(F):
             return x>0            ## All positive elements are squares in RR
 
         elif is_RationalField(F):
@@ -975,6 +977,10 @@
             #new_p_part = QQ(p**(v % 2))
             #unit_part = x / (p**v)
 
+            ## Deal with elements of odd valuation
+            if v % 2 != 0:
+                return False
+
             ## Check if the unit part is a square
             if p == 2:
                 return (unit_part.lift() % 8) == 1                      ## BUG -- Ticket 7016: We should be able to just say "unit_part % 8" here!
@@ -1087,7 +1093,7 @@
                 S2 = self
 
             ## Compute the appropriate Hilbert symbol
-            if isinstance(S2.base_field(), RealField):
+            if is_RealField(S2.base_field()):
                 return (S1.representative() < 0) and (S2.representative() < 0)
             else:
                 try:
@@ -1109,7 +1115,7 @@
 
         if is_ComplexField(self.base_field()):
             return 1
-        elif isinstance(self.base_field(), RealField):
+        elif is_RealField(self.base_field()):
                 if (self.representative() < 0) and (other.representative() < 0):
                     return -1
                 else:
diff -r b4a2b705be3a -r 063731ed8072 sage/quadratic_forms/symmetric_bilinear.py
--- a/sage/quadratic_forms/symmetric_bilinear.py	Sat Jan 08 23:18:28 2011 -0500
+++ b/sage/quadratic_forms/symmetric_bilinear.py	Sun Jan 16 15:41:42 2011 -0500
@@ -449,8 +449,11 @@
             [0 0 0 0 0 5]
 
         """
-        return deepcopy(self.__vector_space.inner_product_matrix())
+        ## This should work -- but it fails due to a deepcopy bug -- see Trac Ticket #10606!
+        #return deepcopy(self.__vector_space.inner_product_matrix())
 
+        ## This is our workaround for now
+        return self.gram_matrix_for_vectors(self.basis())
 
 
     def gram_matrix_for_vectors(self, vec_list):
@@ -1189,82 +1192,70 @@
         #print "nz_diag_elements = " + str(nz_diag_elements)
         #print "nz_vec_index_list = " + str(nz_vec_index_list)
         #print "zero_basis = " + str(zero_basis)
-        #print "nz_vec_index_list = " + str(nz_vec_index_list)
         #print self.gram_matrix_for_vectors(zero_basis + nz_diag_basis)
 
 
         ## Step 2.  Split off hyperbolic planes:
         ## -------------------------------------
         hyperbolic_pair_list = [] 
-                
-        ## Find a non-zero (off-diagonal) entry, if one exists
-        z_len = len(zero_basis)
-        for (i,j) in mrange([z_len, z_len]):                     ## This is a little redundant, but at least we can use a single "break" to escape!
-            b = self.inner_product(zero_basis[i], zero_basis[j])
-            if (b != 0):
-                B = b
-                if i < j:
-                    I = i
-                    J = j
-                else:
-                    I = j
-                    J = i
-                break
-
-
-        ## If one exists, then split off a hyperbolic plane
+        b = 1
+        
+        ## Loop through all strictly upper triangular entries until they're all zero
         while b != 0:
 
-            ## Note: We now have I, J, and b
-            #print "B = " + str(B)
-            #print "I = " + str(I)
-            #print "J = " + str(J)
-    
-            ## Normalize to get a hyperbolic plane from the (i,j) vectors, and remember the plane
-            zero_basis[J] = zero_basis[J] / b
-            v = zero_basis[I]
-            w = zero_basis[J]
-            hyperbolic_pair_list.append([v,w])        
-            
-            ## Split off the hyperbolic plane (top row and then bottom row, for the hyperbolic plane rows)
-            for k in range(len(zero_basis)):
-                M_ik = self.inner_product(v, zero_basis[k])
-                if (k != J) and (M_ik != 0):
-                    zero_basis[k]  =  zero_basis[k] - (M_ik * w)
-                
-            for k in range(len(zero_basis)):
-                M_jk = self.inner_product(w, zero_basis[k])
-                if (k != I) and (M_jk != 0):
-                    zero_basis[k]  =  zero_basis[k] - (M_jk * v)
-
-            for k in range(len(nz_diag_basis)):
-                M_ik = self.inner_product(v, nz_diag_basis[k])
-                if (k != J) and (M_ik != 0):
-                    nz_diag_basis[k]  =  nz_diag_basis[k] - (M_ik * w)
-                
-            for k in range(len(nz_diag_basis)):
-                M_jk = self.inner_product(w, nz_diag_basis[k])
-                if (k != I) and (M_jk != 0):
-                    nz_diag_basis[k]  =  nz_diag_basis[k] - (M_jk * v)
-
-    
-            ## Remove the hyperbolic plane vectors, so we get a smaller space to look in 
-            zero_basis = zero_basis[:I] + zero_basis[I+1:J] + zero_basis[J+1:]
-    
-    
-            ## Find a non-zero (off-diagonal) entry, to see if we can do another splitting
+            ## Find a non-zero (off-diagonal) entry, if one exists
             z_len = len(zero_basis)
-            for (i,j) in mrange([z_len, z_len]):
+            upper_diag_list = [(i,j)  for i in range(z_len)  for j in range(i+1,z_len)]
+            b = 0  ## Needed if there are no strictly upper-triangular entries!
+            for (i,j) in upper_diag_list:                     ## This is a little redundant, but at least we can use a single "break" to escape!
                 b = self.inner_product(zero_basis[i], zero_basis[j])
                 if (b != 0):
                     B = b
-                    if i < j:
-                        I = i
-                        J = j
-                    else:
-                        I = j
-                        J = i    
+                    I = i
+                    J = j
                     break
+    
+    
+            ## If one exists, then split off a hyperbolic plane
+            if b != 0:
+    
+                ## Note: We now have I, J, and b
+                #print "B = " + str(B)
+                #print "I = " + str(I)
+                #print "J = " + str(J)
+                #print "--------"
+        
+                ## Normalize to get a hyperbolic plane from the (i,j) vectors, and remember the plane
+                zero_basis[J] = zero_basis[J] / b
+                v = zero_basis[I]
+                w = zero_basis[J]
+                hyperbolic_pair_list.append([v,w])        
+                
+                ## Split off the hyperbolic plane (top row and then bottom row, for the hyperbolic plane rows)
+                for k in range(len(zero_basis)):
+                    M_ik = self.inner_product(v, zero_basis[k])
+                    if (k != J) and (M_ik != 0):
+                        zero_basis[k]  =  zero_basis[k] - (M_ik * w)
+                    
+                for k in range(len(zero_basis)):
+                    M_jk = self.inner_product(w, zero_basis[k])
+                    if (k != I) and (M_jk != 0):
+                        zero_basis[k]  =  zero_basis[k] - (M_jk * v)
+    
+                for k in range(len(nz_diag_basis)):
+                    M_ik = self.inner_product(v, nz_diag_basis[k])
+                    if (k != J) and (M_ik != 0):
+                        nz_diag_basis[k]  =  nz_diag_basis[k] - (M_ik * w)
+                    
+                for k in range(len(nz_diag_basis)):
+                    M_jk = self.inner_product(w, nz_diag_basis[k])
+                    if (k != I) and (M_jk != 0):
+                        nz_diag_basis[k]  =  nz_diag_basis[k] - (M_jk * v)
+    
+        
+                ## Remove the hyperbolic plane vectors, so we get a smaller space to look in 
+                zero_basis = zero_basis[:I] + zero_basis[I+1:J] + zero_basis[J+1:]
+        
 
         #print "\n\n Finished Step 2 -- Split off all hyperbolic planes:"
         #print "hyperbolic_pair_list = " + str(hyperbolic_pair_list)
@@ -1275,6 +1266,7 @@
 
         ## Step 3:  Split off the metabolic planes
         ## ----------------------------------------
+        metabolic_pair_list = [] 
         z_len = len(zero_basis)
         nz_len = len(nz_diag_basis)
         
@@ -1282,8 +1274,10 @@
         
             ## Compute the upper-right Gram matrix block
             M = Matrix(F, z_len, nz_len)
-            for v in zero_basis:
-                for w in nz_diag_basis:
+            for i in range(len(zero_basis)):
+                v = zero_basis[i]
+                for j in range(len(nz_diag_basis)):
+                    w = nz_diag_basis[j]
                     M[i,j] = self.inner_product(v, w)
 
             #print "M = " + str(M)
@@ -1302,7 +1296,6 @@
             zero_basis = (T * z_rows_matrix).rows()
     
             ## Split off the metabolic planes
-            metabolic_pair_list = []
             M0 = M1.subdivision(0,0)    ## This is the RREF of the upper-right gram matrix
             pivot_columns = M0.pivots()
             pivot_rows = M0.pivot_rows()
@@ -1581,6 +1574,7 @@
 
         ## DIAGNOTSIC
         verbose("\n L = " + str(L))
+        verbose("\n L.gram_matrix() = \n" + str(L.gram_matrix(rational_matrix=False)))
         verbose("\n ====================== ")
 
         ## Enlarge the integral symmetric bilinear lattice so its discriminant module L^#/L is a product of quadratic spaces
@@ -1595,6 +1589,7 @@
             ## DIAGNOSTIC
             verbose("\n big_sq_factor = " + str(big_sq_factor))
             verbose("\n L = " + str(L))
+            verbose("\n L.gram_matrix() \n= " + str(L.gram_matrix(rational_matrix=False)))
             verbose("\n ====================== ")
 
             ## Prepare to check if we're done
@@ -1609,7 +1604,7 @@
         A = Matrix(ZZ, L_dual.gram_matrix(rational_matrix=True).inverse())     ## This matrix describes L in the given basis of L^#
         D, U, V = A.smith_form()
         iso_eligible_primes = prime_divisors(D[-2,-2])        ## The list of primes which have at most a 2-dim'l subspace in L^#/L
-        iso_prime_product = prod(iso_eligible_primes)
+        dual_prime_product = D[-1,-1]          ## This is the product of all primes dividing |L^#/L|
         #L1_dual = L_dual.apply_linear_transformation_on_right(U)        ## This is the dual lattice in the 'nice' basis, so a basis of L is multiples
         L1_dual = L_dual.apply_linear_transformation_on_right(U.inverse())        ## This is the dual lattice in the 'nice' basis, so a basis of L is multiples
         
@@ -1622,14 +1617,22 @@
         verbose("\n U = " + str(U))
         verbose("\n V = " + str(V))
         verbose("\n iso_eligible_primes = " + str(iso_eligible_primes))
+        verbose("\n dual_prime_product = " + str(dual_prime_product))
+        verbose("\n dual primes = " + str(prime_divisors(dual_prime_product)))
         verbose("\n L_dual = " + str(L_dual))
+        verbose("\n L_dual.gram_matrix() = \n" + str(L_dual.gram_matrix(rational_matrix=True)))
         verbose("\n L1_dual = " + str(L1_dual))
+        verbose("\n L1_dual.gram_matrix() = \n" + str(L1_dual.gram_matrix(rational_matrix=True)))
         verbose("\n ====================================== ")
         
         ## Loop through all primes to find a maximal isotropic space for each.
         T_huge = deepcopy(D)    ## This will hold the final list of generators for the isotropic submodule (of L^#), together with a basis of L
         for p in iso_eligible_primes:
 
+            ## DIAGNOSTIC
+            verbose("\n \n\n\n\n Starting to compute a maximal totally isotropic subspace for p = " + str(p))
+            verbose("\n ===================================================================== \n")
+
             ## Compute the dimension d_p of L^#/L at p -- (Since (1/p) * D gives the L1_dual basis relative to some basis of L)
             d_p = 0
             for i in range(n):
@@ -1640,8 +1643,12 @@
             ## Create the Gram matrix for the smaller subspace 
             small_gram = L1_dual.gram_matrix(rational_matrix=True)[(n-d_p):, (n-d_p):]
 
+            verbose("\n small_gram = " + str(small_gram))
+
+
             ## Create the bilinear lattice in the basis
             small_SBS = SymmetricBilinearSpace(GF(p), p * small_gram)  ## This mult-by-p makes the gram matrix p-integral
+            verbose("\n small_SBS = " + str(small_SBS))
             Tp = small_SBS.find_basis_of_maximal_totally_isotropic_subspace(return_type="row_matrix")
 
             ## DIAGNOSTIC
@@ -1661,8 +1668,8 @@
  
 
                 ## Find the appropriate lift factor to multiply the (mod p) vector by to lift it to ZZ only at p (and is the zero vector at other primes!).
-                iso_prime_prod_not_p = ZZ(iso_prime_product / p)
-                iso_prime_lift_multiplier = (iso_prime_prod_not_p) * (GF(p)(iso_prime_prod_not_p)**(-1)).lift()
+                dual_prime_prod_not_p = ZZ(dual_prime_product / p)
+                dual_prime_lift_multiplier = (dual_prime_prod_not_p) * (GF(p)(dual_prime_prod_not_p)**(-1)).lift()
 
 
                 ## Find integer lifts of our vectors (being careful to have the vectors to initially be primitive relative to all other primes)
@@ -1671,7 +1678,7 @@
                     v1 = vector(ZZ, v.lift())
                     g = GCD(list(v1))
                     v2 = v1 * (1/g) 
-                    Tp_lift_list.append(v2 * iso_prime_lift_multiplier)
+                    Tp_lift_list.append(v2 * dual_prime_lift_multiplier)
                 
 
                 ## Add lifts of this subspace to our matrix of generators
@@ -1685,9 +1692,9 @@
                 ## DIAGNOSTIC
                 verbose("\n \n\n This prime gives the lifts:")
                 verbose("\n ----------------------------")
-                verbose("\n iso_prime_product = " + str(iso_prime_product))
-                verbose("\n iso_prime_prod_not_p = " + str(iso_prime_prod_not_p))
-                verbose("\n iso_prime_lift_multiplier = " + str(iso_prime_lift_multiplier))
+                verbose("\n dual_prime_product = " + str(dual_prime_product))
+                verbose("\n dual_prime_prod_not_p = " + str(dual_prime_prod_not_p))
+                verbose("\n dual_prime_lift_multiplier = " + str(dual_prime_lift_multiplier))
                 verbose("\n TZ_top_as_rows = " + str(TZ_top_as_rows))
                 verbose("\n TZ_bottom_as_rows = " + str(TZ_bottom_as_rows))
                 verbose("\n TZ = " + str(TZ))
@@ -1860,7 +1867,7 @@
         """
         ## Check that V is a symmetric bilinear space 
         if not isinstance(V, SymmetricBilinearSpace):
-            raise TypeError, "The first argumont must be a symmetric bilinear space!"
+            raise TypeError, "The first argument must be a symmetric bilinear space!"
 
 
         ## Check that V is a defined over a number field or its completion at a place
@@ -1876,7 +1883,7 @@
 
         ## Initilize the lattice
 #        Lattice.__init__(self, V, basis)
-        self.__ambient_bilinear_space = V
+        self.__ambient_bilinear_space = V     ## We completely ignore the inner product structure on this!
         self.__lattice_module = FreeModule_submodule_with_basis_pid(V.vector_space(), basis)
         self.__base_ring = V.base_field().ring_of_integers()
 
@@ -2016,7 +2023,10 @@
 
         ## Here the lattice is already even
         if odd_ind == -1:
-            return self, X, True
+            if return_extended_info:
+                return self, X, True    
+            else:
+                return self
 
         ## Make the transformation matrix (on row vectors!)
         X[odd_ind, odd_ind] = 2
@@ -2025,10 +2035,14 @@
                 X[i, odd_ind] = 1
 
 
+        #print "return_extended_info = " + str(return_extended_info)
+
         ## Return the even sublattice
         if return_extended_info:
+            #print "Returning a tuple"
             return SymmetricBilinearLattice(self.ambient_space(), (X * self.basis_matrix_of_rows()).rows()), X, False
         else:
+            #print "Returning a Symmetric Bilinear lattice"
             return SymmetricBilinearLattice(self.ambient_space(), (X * self.basis_matrix_of_rows()).rows())
 
 
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1296430701 18000
# Node ID 51ce1171a8013979360b3b9d0239090b6d520a2d
# Parent  063731ed80720a7889e934ccdc287d3e256cdd17
Allow QuadraticLattice to sum with another quadratic lattice, or a set of generators.

diff -r 063731ed8072 -r 51ce1171a801 sage/quadratic_forms/quadratic_lattice.py
--- a/sage/quadratic_forms/quadratic_lattice.py	Sun Jan 16 15:41:42 2011 -0500
+++ b/sage/quadratic_forms/quadratic_lattice.py	Sun Jan 30 18:38:21 2011 -0500
@@ -629,7 +629,7 @@
         quadratic space, or an error is raised).
 
         INPUT:
-            other -- a quadratic lattice on the smae ambient quadratic space
+            other -- a quadratic lattice on the same ambient quadratic space
 
         OUTPUT:
             a quadratic lattice on the same quadratic space
@@ -657,13 +657,25 @@
             spanned by ((1, 1),).
 
         """
-        ## Check that both lattices live on the same quadratic space
-        if not self.has_same_quadratic_space(other):
-            raise TypeError, "The two quadratic lattices live on different quadratic spaces!"
+        ## Do the sum with another quadratic lattice
+        if isinstance(other, QuadraticLattice):
+        
+            ## Check that both lattices live on the same quadratic space
+            if not self.has_same_quadratic_space(other):
+                raise TypeError, "The two quadratic lattices live on different quadratic spaces!"
+    
+            ## Return the lattice generated by generators of both lattices
+            return QuadraticLattice(self.quadratic_space(), self.generators() + other.generators())
 
-        ## Return the lattice generated by generators of both lattices
-        return QuadraticLattice(self.quadratic_space(), self.generators() + other.generators())
+        ## Otherwise do the sum with a list of vectors (taken to generate some other possibly non full rank lattice) we're passing in
+        elif isinstance(other, list):
 
+            ## Return the lattice generated by generators of both lattices
+            return QuadraticLattice(self.quadratic_space(), self.generators() + other)
+
+        ## Otherwise raise an error
+        else:
+            raise TypeError, "You must sum with eithe a QuadraticLattice or a list of vectors coercible to the ambient quadratic space."
 
 
 
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1297649937 18000
# Node ID 49a030a4ab3aa466922a6fddf64533ead7302e1e
# Parent  51ce1171a8013979360b3b9d0239090b6d520a2d
Minor bugfixes to quadratic forms code.

diff -r 51ce1171a801 -r 49a030a4ab3a doc/en/tutorial/index.rst
--- a/doc/en/tutorial/index.rst	Sun Jan 30 18:38:21 2011 -0500
+++ b/doc/en/tutorial/index.rst	Sun Feb 13 21:18:57 2011 -0500
@@ -27,6 +27,7 @@
 .. toctree::
    :maxdepth: 2
 
+   QuadraticForms__my_docs
    introduction
    tour
    interactive_shell
diff -r 51ce1171a801 -r 49a030a4ab3a sage/quadratic_forms/quadratic_form__equivalence_testing.py
--- a/sage/quadratic_forms/quadratic_form__equivalence_testing.py	Sun Jan 30 18:38:21 2011 -0500
+++ b/sage/quadratic_forms/quadratic_form__equivalence_testing.py	Sun Feb 13 21:18:57 2011 -0500
@@ -55,7 +55,7 @@
     Q2 = other.LLL_reduced()
     
     ## Write an input text file
-    F_filename = '/tmp/tmp_isom_input' + str(random()) + ".txt"
+    F_filename = '/tmp/tmp_isom_input__' + str(ZZ.random_element(100000)) + ".txt"
     F = open(F_filename, 'w')
     #F = tempfile.NamedTemporaryFile(prefix='tmp_isom_input', suffix=".txt")  ## This failed because it may have hyphens, which are interpreted badly by the Souvigner code.
     F.write("\n #1 \n")
diff -r 51ce1171a801 -r 49a030a4ab3a sage/quadratic_forms/quadratic_space.py
--- a/sage/quadratic_forms/quadratic_space.py	Sun Jan 30 18:38:21 2011 -0500
+++ b/sage/quadratic_forms/quadratic_space.py	Sun Feb 13 21:18:57 2011 -0500
@@ -2181,7 +2181,10 @@
 
 
     ## Construct the anisotropic subspace
-    if n1 == 1:
+    if n1 == 0:
+        Q1 = QuadraticForm(Qp(p), 0, [])
+
+    elif n1 == 1:
         Q1 = QuadraticForm(Qp(p), 1, [d1])
 
     elif n1 == 2:
@@ -2223,7 +2226,7 @@
                 if Q1.hasse_invariant(2) == 1:        ## The Hasse invariant must be 1 for the 4-dim'l anisotropic form at p=2
                     break
     else:
-        raise RuntimeError, "There is a problem, since the anisotropic dimension must be <= 4 for Q_p."
+        raise RuntimeError, "There is a problem, since we got n1 = " + str(n1) + ", but the anisotropic dimension must be <= 4 for Q_p."
 
         
     ## Append hyperbolic planes to get the correct dimension
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1296965977 18000
# Node ID d0db6b8af69a5a3fdd9769964d3635ac0b865dea
# Parent  120c07be6358d93bcff503363d379c26b8342f2b
Added some ellipse info, plotting and spectral decomposition routines for BinaryQFs.

diff -r 120c07be6358 -r d0db6b8af69a sage/quadratic_forms/binary_qf.py
--- a/sage/quadratic_forms/binary_qf.py	Sat Oct 30 16:00:40 2010 -0700
+++ b/sage/quadratic_forms/binary_qf.py	Sat Feb 05 23:19:37 2011 -0500
@@ -33,10 +33,11 @@
 - Nick Alexander: add doctests and clean code for Doc Days 2
 - William Stein (2009-08-05): composition; some ReSTification.
 - William Stein (2009-09-18): make immutable.
+- Jon Hanke (2011-02-05):  Add spectral decomp. and some nice pictures.
 """
 
 #*****************************************************************************
-#       Copyright (C) 2006--2009 William Stein and Jon Hanke
+#       Copyright (C) 2006--2011 William Stein and Jon Hanke
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -51,10 +52,17 @@
 #*****************************************************************************
 
 from sage.libs.pari.all import pari
-from sage.rings.all import (is_fundamental_discriminant, ZZ, divisors)
+from sage.rings.all import (is_fundamental_discriminant, ZZ, divisors, QQ, RR)
 from sage.structure.sage_object import SageObject
 from sage.misc.cachefunc import cached_method
 
+from sage.matrix.constructor import Matrix
+from sage.modules.free_module_element import vector
+from sage.functions.other import sqrt, ceil
+from sage.functions.trig import arccos
+from sage.plot.all import Graphics, point, ellipse, text
+
+
 class BinaryQF(SageObject):
     """
     A binary quadratic form over `\ZZ`.
@@ -639,6 +647,290 @@
         b1 = self(v + w) - a1 - c1
         return BinaryQF([a1, b1, c1])
 
+
+
+    def matrix_Gram(self):
+        """
+        Returns the (symmetric) Gram matrix G of the
+        quadratic form, which expresses Q(x,y) as the
+        matrix product Q(x,y) = [x y] * G * [x]
+                                            [y].
+                                            
+        This matrix has base_ring QQ.
+
+        """
+        return Matrix(QQ, 2, 2, [QQ(self._a), QQ(self._b)/2, QQ(self._b)/2, QQ(self._c)])
+
+
+    def matrix_Hessian(self):
+        """
+        Returns the Hessian matrix (of mixed partial derivatives)
+        of the quadratic form, which is twice the Gram matrix.
+        This matrix has base_ring ZZ.
+        """
+        return Matrix(ZZ, 2, 2, [2 * self._a, self._b, self._b, 2*self._c])
+
+
+
+    def eigenspaces(self):
+        """
+        Return the eigenspaces of the Hessian matrix of this quadratic form.
+
+        TO DO: Cache this, and make sure the BQF is immutable!
+        """
+        return self.matrix_Hessian().eigenspaces()
+
+
+
+    def spectral_decomposition(self):
+        """
+        Return the spectral decomposition matrices (D, X) so that
+        the Hessian matrix H (which is twice the Gram matrix of Q)
+        can be written as H = X^{t} * D * X where D is a diagonal
+        matrix and X is an orthogonal matrix.
+        
+        INPUT:
+            None
+        
+        OUTPUT:
+            D -- a diagonal matrix
+            X -- an orthogonal matrix
+
+        EXAMPLES:
+            sage: B = BinaryQF([1,1,1])
+            sage: B.eigenspaces()
+            [
+            (3, Vector space of degree 2 and dimension 1 over Rational Field
+            User basis matrix:
+            [1 1]),
+            (1, Vector space of degree 2 and dimension 1 over Rational Field
+            User basis matrix:
+            [ 1 -1])
+            ]
+            
+            sage: B = BinaryQF([1,0,2])
+            sage: B.eigenspaces()
+            [
+            (4, Vector space of degree 2 and dimension 1 over Rational Field
+            User basis matrix:
+            [0 1]),
+            (2, Vector space of degree 2 and dimension 1 over Rational Field
+            User basis matrix:
+            [1 0])
+            ]
+        """
+        E = self.eigenspaces()
+
+        ## Make the diagonal matrix D
+        D_list = []
+        for W in E:
+            D_list += [W[0][0]] * W[0][1].dimension()
+        D = Matrix(QQ, 2, 2, 0)
+        for i in range(2):
+            D[i,i] = D_list[i] 
+        
+
+        ## Make the orthogonal matrix X
+        M_rows = []
+        for W in E:
+            for v in W.basis():
+                v_len = sqrt(v.dot_product(v))
+                M_rows.append(v / v_len)
+        X = Matrix(M_rows).transpose()
+
+        ## Return the spectral decomposition
+        return D, X
+
+
+
+    def major_axis(self):
+        """
+        This assumes that the quadratic form is definite,
+        and returns a vector in the eigenspace with the largest
+        size eigenvalue.  If there is a single eigenspace, then
+        we return the standard basis vector e1 = (1,0)! 
+    
+        INPUT:
+            None
+            
+        OUTPUT:
+            a vector
+
+        EXAMPLES:
+            sage: B = BinaryQF([1,1,1])
+            sage: B.major_axis()
+            (1, -1)
+            sage: B.minor_axis()
+            (1, 1)
+
+            sage: B = BinaryQF([1,0,2])
+            sage: B.major_axis()
+            (1, 0)
+            sage: B.minor_axis()
+            (0, 1)
+ 
+            sage: B = BinaryQF([1,0,1])
+            sage: B.major_axis()
+            (1, 0)
+            sage: B.minor_axis()
+            (0, 1)
+        
+        """
+        E = self.eigenspaces()
+        if len(E) == 1:
+            return vector([1,0])
+        else:
+            ## Choose the *smallest* eigenvalue for the major axis
+            if abs(E[0][0]) < abs(E[1][0]):
+                return E[0][1].basis()[0]
+            else:
+                return E[1][1].basis()[0]
+    
+
+    def minor_axis(self):
+        """
+        This assumes that the quadratic form is definite,
+        and returns a vector in the eigenspace with the largest
+        size eigenvalue.  If there is a single eigenspace, then
+        we return the standard basis vector e2 = (0,1). 
+
+        INPUT:
+            None
+            
+        OUTPUT:
+            a vector
+
+        EXAMPLES:
+            sage: B = BinaryQF([1,1,1])
+            sage: B.major_axis()
+            (1, -1)
+            sage: B.minor_axis()
+            (1, 1)
+
+            sage: B = BinaryQF([1,0,2])
+            sage: B.major_axis()
+            (1, 0)
+            sage: B.minor_axis()
+            (0, 1)
+ 
+            sage: B = BinaryQF([1,0,1])
+            sage: B.major_axis()
+            (1, 0)
+            sage: B.minor_axis()
+            (0, 1)
+ 
+        """
+        E = self.eigenspaces()
+        if len(E) == 1:
+            return vector([0,1])
+        else:
+            ## Choose the *largest* eigenvalue for the major axis
+            if abs(E[0][0]) > abs(E[1][0]):
+                return E[0][1].basis()[0]
+            else:
+                return E[1][1].basis()[0]
+
+    
+
+    def plot_level_set(self, m, x_max = None, y_max = None, legend_center=None):
+        """
+        Returns a graphic object that shows the level set of
+        this binary quadratic form with respect to the standard
+        basis, showing both the background lattice, the level set
+        ellipse, and the lattice points on this level set.
+        
+        TO DO: Allow arguments for:
+            x_max
+            y_max
+            legend_center -- ok
+            ---------------
+            x_range
+            y_range
+            point_color
+            point_size
+            ellipse_color
+            ellipse_thickness
+            intersection_point_size
+            intersection_point_color
+            return_plot
+            aspect_ratio
+            legend_center
+            hide_legend
+
+        INPUT:
+            m -- an integer
+
+        OUTPUT:
+            a graphics object
+            
+        EXAMPLES:
+            B = BinaryQF([1,1,1])
+            sage: B.plot_level_set(13)
+            sage: B.plot_level_set(409)
+            sage: B.plot_level_set(11, legend_center=(3,3.5))
+        """
+    
+        ## legend_label='$x^2 + xy + y^2$'
+        ##  legend_label = str(Q([i,j]))
+    
+                    #G += point([(i,j)], size=15, rgbcolor=(1,0,0))            
+        #G += circle((0,0), sqrt(13), rgbcolor=(1,0,0))
+    
+    
+        sqrt_m = sqrt(m)
+    
+        ## Find the eigenvalues and eigenvectors
+        v1 = self.major_axis()
+        v2 = self.minor_axis()
+        euclid_len1 = sqrt(v1.dot_product(v1))
+        euclid_len2 = sqrt(v2.dot_product(v2))
+        Q_len1 = sqrt(self(v1))
+        Q_len2 = sqrt(self(v2))
+    
+        ## Find the ellipse information
+        if v1[1] < 0:
+            upper_v1 = -v1   ## ensure the major axis vector is in upper half-plane, so Arccos gives the correct angle!
+        else:
+            upper_v1 = v1
+        angle = arccos(RR(upper_v1[0])/euclid_len1)
+        major_radius = sqrt_m * euclid_len1 / Q_len1
+        minor_radius = sqrt_m * euclid_len2 / Q_len2
+    
+    
+        ## Determine bounds for our lattice point region
+        x_max = ceil(major_radius)
+        y_max = x_max
+    
+        ## Draw the lattice and intersection points
+        G = Graphics()
+        for i in range(-x_max, x_max + 1):
+            for j in range(-y_max, y_max + 1):
+                if self([i,j]) != m:
+                    G += point([(i,j)], size=4)
+                else:
+                    G += point([(i,j)], size=15)            
+    
+    
+        ## Draw the shaded ellipse
+        G += ellipse((0,0), major_radius, minor_radius, angle,fill=True,alpha=0.3)
+    
+    
+        ## Add a label
+        if legend_center == None:
+            legend_center = (x_max - 1, y_max - 1 + .5)
+        G += text('$' + str(self.polynomial()).replace('*', '') + ' = ' + str(m) + '$', legend_center, fontsize=15,rgbcolor=(0,0,1))
+    
+    
+        ## Return the plotted graphic
+        G.axes_labels(['$x$','$y$'])
+        G.set_aspect_ratio(1)
+        return G.show()
+
+
+
+
+
+
 def BinaryQF_reduced_representatives(D, primitive_only=False):
     r"""
     Returns a list of inequivalent reduced representatives for the
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1297650662 18000
# Node ID b26a749bd20bc1cd3d46bd62a050f459b5c20153
# Parent  49a030a4ab3aa466922a6fddf64533ead7302e1e
# Parent  d0db6b8af69a5a3fdd9769964d3635ac0b865dea
Merged the BinaryQF Graphics changeset bundle.

diff -r 49a030a4ab3a -r b26a749bd20b sage/quadratic_forms/binary_qf.py
--- a/sage/quadratic_forms/binary_qf.py	Sun Feb 13 21:18:57 2011 -0500
+++ b/sage/quadratic_forms/binary_qf.py	Sun Feb 13 21:31:02 2011 -0500
@@ -33,10 +33,11 @@
 - Nick Alexander: add doctests and clean code for Doc Days 2
 - William Stein (2009-08-05): composition; some ReSTification.
 - William Stein (2009-09-18): make immutable.
+- Jon Hanke (2011-02-05):  Add spectral decomp. and some nice pictures.
 """
 
 #*****************************************************************************
-#       Copyright (C) 2006--2009 William Stein and Jon Hanke
+#       Copyright (C) 2006--2011 William Stein and Jon Hanke
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -51,10 +52,17 @@
 #*****************************************************************************
 
 from sage.libs.pari.all import pari
-from sage.rings.all import (is_fundamental_discriminant, ZZ, divisors)
+from sage.rings.all import (is_fundamental_discriminant, ZZ, divisors, QQ, RR)
 from sage.structure.sage_object import SageObject
 from sage.misc.cachefunc import cached_method
 
+from sage.matrix.constructor import Matrix
+from sage.modules.free_module_element import vector
+from sage.functions.other import sqrt, ceil
+from sage.functions.trig import arccos
+from sage.plot.all import Graphics, point, ellipse, text
+
+
 class BinaryQF(SageObject):
     """
     A binary quadratic form over `\ZZ`.
@@ -639,6 +647,290 @@
         b1 = self(v + w) - a1 - c1
         return BinaryQF([a1, b1, c1])
 
+
+
+    def matrix_Gram(self):
+        """
+        Returns the (symmetric) Gram matrix G of the
+        quadratic form, which expresses Q(x,y) as the
+        matrix product Q(x,y) = [x y] * G * [x]
+                                            [y].
+                                            
+        This matrix has base_ring QQ.
+
+        """
+        return Matrix(QQ, 2, 2, [QQ(self._a), QQ(self._b)/2, QQ(self._b)/2, QQ(self._c)])
+
+
+    def matrix_Hessian(self):
+        """
+        Returns the Hessian matrix (of mixed partial derivatives)
+        of the quadratic form, which is twice the Gram matrix.
+        This matrix has base_ring ZZ.
+        """
+        return Matrix(ZZ, 2, 2, [2 * self._a, self._b, self._b, 2*self._c])
+
+
+
+    def eigenspaces(self):
+        """
+        Return the eigenspaces of the Hessian matrix of this quadratic form.
+
+        TO DO: Cache this, and make sure the BQF is immutable!
+        """
+        return self.matrix_Hessian().eigenspaces()
+
+
+
+    def spectral_decomposition(self):
+        """
+        Return the spectral decomposition matrices (D, X) so that
+        the Hessian matrix H (which is twice the Gram matrix of Q)
+        can be written as H = X^{t} * D * X where D is a diagonal
+        matrix and X is an orthogonal matrix.
+        
+        INPUT:
+            None
+        
+        OUTPUT:
+            D -- a diagonal matrix
+            X -- an orthogonal matrix
+
+        EXAMPLES:
+            sage: B = BinaryQF([1,1,1])
+            sage: B.eigenspaces()
+            [
+            (3, Vector space of degree 2 and dimension 1 over Rational Field
+            User basis matrix:
+            [1 1]),
+            (1, Vector space of degree 2 and dimension 1 over Rational Field
+            User basis matrix:
+            [ 1 -1])
+            ]
+            
+            sage: B = BinaryQF([1,0,2])
+            sage: B.eigenspaces()
+            [
+            (4, Vector space of degree 2 and dimension 1 over Rational Field
+            User basis matrix:
+            [0 1]),
+            (2, Vector space of degree 2 and dimension 1 over Rational Field
+            User basis matrix:
+            [1 0])
+            ]
+        """
+        E = self.eigenspaces()
+
+        ## Make the diagonal matrix D
+        D_list = []
+        for W in E:
+            D_list += [W[0][0]] * W[0][1].dimension()
+        D = Matrix(QQ, 2, 2, 0)
+        for i in range(2):
+            D[i,i] = D_list[i] 
+        
+
+        ## Make the orthogonal matrix X
+        M_rows = []
+        for W in E:
+            for v in W.basis():
+                v_len = sqrt(v.dot_product(v))
+                M_rows.append(v / v_len)
+        X = Matrix(M_rows).transpose()
+
+        ## Return the spectral decomposition
+        return D, X
+
+
+
+    def major_axis(self):
+        """
+        This assumes that the quadratic form is definite,
+        and returns a vector in the eigenspace with the largest
+        size eigenvalue.  If there is a single eigenspace, then
+        we return the standard basis vector e1 = (1,0)! 
+    
+        INPUT:
+            None
+            
+        OUTPUT:
+            a vector
+
+        EXAMPLES:
+            sage: B = BinaryQF([1,1,1])
+            sage: B.major_axis()
+            (1, -1)
+            sage: B.minor_axis()
+            (1, 1)
+
+            sage: B = BinaryQF([1,0,2])
+            sage: B.major_axis()
+            (1, 0)
+            sage: B.minor_axis()
+            (0, 1)
+ 
+            sage: B = BinaryQF([1,0,1])
+            sage: B.major_axis()
+            (1, 0)
+            sage: B.minor_axis()
+            (0, 1)
+        
+        """
+        E = self.eigenspaces()
+        if len(E) == 1:
+            return vector([1,0])
+        else:
+            ## Choose the *smallest* eigenvalue for the major axis
+            if abs(E[0][0]) < abs(E[1][0]):
+                return E[0][1].basis()[0]
+            else:
+                return E[1][1].basis()[0]
+    
+
+    def minor_axis(self):
+        """
+        This assumes that the quadratic form is definite,
+        and returns a vector in the eigenspace with the largest
+        size eigenvalue.  If there is a single eigenspace, then
+        we return the standard basis vector e2 = (0,1). 
+
+        INPUT:
+            None
+            
+        OUTPUT:
+            a vector
+
+        EXAMPLES:
+            sage: B = BinaryQF([1,1,1])
+            sage: B.major_axis()
+            (1, -1)
+            sage: B.minor_axis()
+            (1, 1)
+
+            sage: B = BinaryQF([1,0,2])
+            sage: B.major_axis()
+            (1, 0)
+            sage: B.minor_axis()
+            (0, 1)
+ 
+            sage: B = BinaryQF([1,0,1])
+            sage: B.major_axis()
+            (1, 0)
+            sage: B.minor_axis()
+            (0, 1)
+ 
+        """
+        E = self.eigenspaces()
+        if len(E) == 1:
+            return vector([0,1])
+        else:
+            ## Choose the *largest* eigenvalue for the major axis
+            if abs(E[0][0]) > abs(E[1][0]):
+                return E[0][1].basis()[0]
+            else:
+                return E[1][1].basis()[0]
+
+    
+
+    def plot_level_set(self, m, x_max = None, y_max = None, legend_center=None):
+        """
+        Returns a graphic object that shows the level set of
+        this binary quadratic form with respect to the standard
+        basis, showing both the background lattice, the level set
+        ellipse, and the lattice points on this level set.
+        
+        TO DO: Allow arguments for:
+            x_max
+            y_max
+            legend_center -- ok
+            ---------------
+            x_range
+            y_range
+            point_color
+            point_size
+            ellipse_color
+            ellipse_thickness
+            intersection_point_size
+            intersection_point_color
+            return_plot
+            aspect_ratio
+            legend_center
+            hide_legend
+
+        INPUT:
+            m -- an integer
+
+        OUTPUT:
+            a graphics object
+            
+        EXAMPLES:
+            B = BinaryQF([1,1,1])
+            sage: B.plot_level_set(13)
+            sage: B.plot_level_set(409)
+            sage: B.plot_level_set(11, legend_center=(3,3.5))
+        """
+    
+        ## legend_label='$x^2 + xy + y^2$'
+        ##  legend_label = str(Q([i,j]))
+    
+                    #G += point([(i,j)], size=15, rgbcolor=(1,0,0))            
+        #G += circle((0,0), sqrt(13), rgbcolor=(1,0,0))
+    
+    
+        sqrt_m = sqrt(m)
+    
+        ## Find the eigenvalues and eigenvectors
+        v1 = self.major_axis()
+        v2 = self.minor_axis()
+        euclid_len1 = sqrt(v1.dot_product(v1))
+        euclid_len2 = sqrt(v2.dot_product(v2))
+        Q_len1 = sqrt(self(v1))
+        Q_len2 = sqrt(self(v2))
+    
+        ## Find the ellipse information
+        if v1[1] < 0:
+            upper_v1 = -v1   ## ensure the major axis vector is in upper half-plane, so Arccos gives the correct angle!
+        else:
+            upper_v1 = v1
+        angle = arccos(RR(upper_v1[0])/euclid_len1)
+        major_radius = sqrt_m * euclid_len1 / Q_len1
+        minor_radius = sqrt_m * euclid_len2 / Q_len2
+    
+    
+        ## Determine bounds for our lattice point region
+        x_max = ceil(major_radius)
+        y_max = x_max
+    
+        ## Draw the lattice and intersection points
+        G = Graphics()
+        for i in range(-x_max, x_max + 1):
+            for j in range(-y_max, y_max + 1):
+                if self([i,j]) != m:
+                    G += point([(i,j)], size=4)
+                else:
+                    G += point([(i,j)], size=15)            
+    
+    
+        ## Draw the shaded ellipse
+        G += ellipse((0,0), major_radius, minor_radius, angle,fill=True,alpha=0.3)
+    
+    
+        ## Add a label
+        if legend_center == None:
+            legend_center = (x_max - 1, y_max - 1 + .5)
+        G += text('$' + str(self.polynomial()).replace('*', '') + ' = ' + str(m) + '$', legend_center, fontsize=15,rgbcolor=(0,0,1))
+    
+    
+        ## Return the plotted graphic
+        G.axes_labels(['$x$','$y$'])
+        G.set_aspect_ratio(1)
+        return G.show()
+
+
+
+
+
+
 def BinaryQF_reduced_representatives(D, primitive_only=False):
     r"""
     Returns a list of inequivalent reduced representatives for the
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1303297930 14400
# Node ID 84e02f957a5afa854b662fe281b6fe3a8a3e91d2
# Parent  b26a749bd20bc1cd3d46bd62a050f459b5c20153
Added several options to the plot_level_set() method for BinaryQFs.

This includes some support for graphics arrays.

diff -r b26a749bd20b -r 84e02f957a5a sage/quadratic_forms/binary_qf.py
--- a/sage/quadratic_forms/binary_qf.py	Sun Feb 13 21:31:02 2011 -0500
+++ b/sage/quadratic_forms/binary_qf.py	Wed Apr 20 07:12:10 2011 -0400
@@ -60,7 +60,7 @@
 from sage.modules.free_module_element import vector
 from sage.functions.other import sqrt, ceil
 from sage.functions.trig import arccos
-from sage.plot.all import Graphics, point, ellipse, text
+from sage.plot.all import Graphics, point, ellipse, text, graphics_array
 
 
 class BinaryQF(SageObject):
@@ -832,7 +832,10 @@
 
     
 
-    def plot_level_set(self, m, x_max = None, y_max = None, legend_center=None):
+    def plot_level_set(self, m, x_max = None, y_max = None, legend_option=None, return_graphic_object=True, opacity=None, \
+                       ellipse_alpha=0.3, ellipse_fill=True, ellipse_rgbcolor=(1,0,0), \
+                       intersection_point_rgbcolor=(0,0,1), intersection_point_size=15, \
+                       background_point_rgbcolor=(0,0,1), background_point_size=4):
         """
         Returns a graphic object that shows the level set of
         this binary quadratic form with respect to the standard
@@ -906,25 +909,51 @@
         for i in range(-x_max, x_max + 1):
             for j in range(-y_max, y_max + 1):
                 if self([i,j]) != m:
-                    G += point([(i,j)], size=4)
+                    G += point([(i,j)], rgbcolor=background_point_rgbcolor, size=background_point_size)
                 else:
-                    G += point([(i,j)], size=15)            
+                    G += point([(i,j)], rgbcolor=intersection_point_rgbcolor, size=intersection_point_size)            
     
     
         ## Draw the shaded ellipse
-        G += ellipse((0,0), major_radius, minor_radius, angle,fill=True,alpha=0.3)
+        G += ellipse((0,0), major_radius, minor_radius, angle, fill=ellipse_fill, alpha=ellipse_alpha, rgbcolor=ellipse_rgbcolor)
     
     
         ## Add a label
-        if legend_center == None:
+        if legend_option == None:
             legend_center = (x_max - 1, y_max - 1 + .5)
-        G += text('$' + str(self.polynomial()).replace('*', '') + ' = ' + str(m) + '$', legend_center, fontsize=15,rgbcolor=(0,0,1))
+        elif legend_option == "top_right":
+            legend_center = (.5 * x_max, 1.2 * y_max)
+        elif isinstance(legend_option, (tuple, list)) and len(legend_option) == 2:
+            legend_center = legend_option
+        else:
+            legend_center = (0,0)
+        Label = text('$' + str(self.polynomial()).replace('*', '') + ' = ' + str(m) + '$', legend_center, fontsize=15, rgbcolor=(0,0,1))
+        Label.axes(False)
+
+        #print "legend_option = " + str(legend_option)
+        #print "legend_center = " + str(legend_center)
+
+        if not legend_option in ["hidden", "bottom", "top", "separate"]:
+            print "Adding the label!"
+            G += Label
     
     
         ## Return the plotted graphic
         G.axes_labels(['$x$','$y$'])
         G.set_aspect_ratio(1)
-        return G.show()
+        if return_graphic_object:
+            if legend_option == "separate":
+                return G, Label
+            elif legend_option == "top":
+                GA = graphics_array([[Label],[G]])
+                return GA
+            elif legend_option == "bottom":
+                GA = graphics_array([[G],[Label]])
+                return GA
+            else:
+                return G
+        else:
+            return G.show()
 
 
 
# HG changeset patch
# User Jonathan Hanke <jonhanke@gmail.com>
# Date 1303420271 14400
# Node ID f764a1d07b5bdcd0028161c07a6cc79868276042
# Parent  84e02f957a5afa854b662fe281b6fe3a8a3e91d2
Some minor (and incomplete) additions to allow one to test bounded class number w/o computing it fully!

diff -r 84e02f957a5a -r f764a1d07b5b sage/quadratic_forms/quadratic_form__genus_enumeration.py
--- a/sage/quadratic_forms/quadratic_form__genus_enumeration.py	Wed Apr 20 07:12:10 2011 -0400
+++ b/sage/quadratic_forms/quadratic_form__genus_enumeration.py	Thu Apr 21 17:11:11 2011 -0400
@@ -51,21 +51,46 @@
 
 
 
+def has_class_number_larger_than(B):
+    """
+    Returns True if the class number is <= B, and False otherwise.
+    
+    This enumerates enough neighbors to make this decision, but no more.
 
+    INPUT:
+        B -- an integer >=1
+        
+    OUTPUT:
+        boolean
+        
+    EXAMPLES:
+    """
+    ## Sanity Check -- B is a positive integer
+    
+    
+    return self.genus_representatives(false_if_CN_is_larger_than=B)
 
 
-def genus_representatives(self):
+
+
+def genus_representatives(self, false_if_CN_is_larger_than=None):
     """
     Find a set of inequivalent representatives for the classes in the
     genus of the given quadratic form.
 
+    Optional Argument:
+    ------------------
+    If false_if_CN_is_larger_than is set to some integer B >=1,
+    then it will return False if there are > B classes, and True
+    if there are <= B classes.
+
     Warning: If there is a problem now -- the algorithm will not
     terminate.  It's better to compute the spinor genera in the gennus
     adelically first, so we know which primes to use!
 
     
     INPUT:
-        None
+        return_if_CN_is_larger_than -- an optional integer argument
 
     OUTPUT:
         A list of non-isometric quadratic forms representing all classes in the genus.
